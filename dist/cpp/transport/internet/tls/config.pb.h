// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport/internet/tls/config.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2ftls_2fconfig_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2ftls_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_transport_2finternet_2ftls_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_transport_2finternet_2ftls_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_transport_2finternet_2ftls_2fconfig_2eproto;
namespace xray {
namespace transport {
namespace internet {
namespace tls {
class Certificate;
struct CertificateDefaultTypeInternal;
extern CertificateDefaultTypeInternal _Certificate_default_instance_;
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
}  // namespace tls
}  // namespace internet
}  // namespace transport
}  // namespace xray
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xray {
namespace transport {
namespace internet {
namespace tls {
enum Certificate_Usage : int {
  Certificate_Usage_ENCIPHERMENT = 0,
  Certificate_Usage_AUTHORITY_VERIFY = 1,
  Certificate_Usage_AUTHORITY_ISSUE = 2,
  Certificate_Usage_Certificate_Usage_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Certificate_Usage_Certificate_Usage_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Certificate_Usage_IsValid(int value);
extern const uint32_t Certificate_Usage_internal_data_[];
constexpr Certificate_Usage Certificate_Usage_Usage_MIN = static_cast<Certificate_Usage>(0);
constexpr Certificate_Usage Certificate_Usage_Usage_MAX = static_cast<Certificate_Usage>(2);
constexpr int Certificate_Usage_Usage_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Certificate_Usage_descriptor();
template <typename T>
const std::string& Certificate_Usage_Name(T value) {
  static_assert(std::is_same<T, Certificate_Usage>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Usage_Name().");
  return Certificate_Usage_Name(static_cast<Certificate_Usage>(value));
}
template <>
inline const std::string& Certificate_Usage_Name(Certificate_Usage value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Certificate_Usage_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Certificate_Usage_Parse(absl::string_view name, Certificate_Usage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Certificate_Usage>(
      Certificate_Usage_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Certificate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.tls.Certificate) */ {
 public:
  inline Certificate() : Certificate(nullptr) {}
  ~Certificate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Certificate(::google::protobuf::internal::ConstantInitialized);

  inline Certificate(const Certificate& from)
      : Certificate(nullptr, from) {}
  Certificate(Certificate&& from) noexcept
    : Certificate() {
    *this = ::std::move(from);
  }

  inline Certificate& operator=(const Certificate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Certificate& operator=(Certificate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Certificate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Certificate* internal_default_instance() {
    return reinterpret_cast<const Certificate*>(
               &_Certificate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Certificate& a, Certificate& b) {
    a.Swap(&b);
  }
  inline void Swap(Certificate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Certificate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Certificate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Certificate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Certificate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Certificate& from) {
    Certificate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Certificate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.tls.Certificate";
  }
  protected:
  explicit Certificate(::google::protobuf::Arena* arena);
  Certificate(::google::protobuf::Arena* arena, const Certificate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Usage = Certificate_Usage;
  static constexpr Usage ENCIPHERMENT = Certificate_Usage_ENCIPHERMENT;
  static constexpr Usage AUTHORITY_VERIFY = Certificate_Usage_AUTHORITY_VERIFY;
  static constexpr Usage AUTHORITY_ISSUE = Certificate_Usage_AUTHORITY_ISSUE;
  static inline bool Usage_IsValid(int value) {
    return Certificate_Usage_IsValid(value);
  }
  static constexpr Usage Usage_MIN = Certificate_Usage_Usage_MIN;
  static constexpr Usage Usage_MAX = Certificate_Usage_Usage_MAX;
  static constexpr int Usage_ARRAYSIZE = Certificate_Usage_Usage_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Usage_descriptor() {
    return Certificate_Usage_descriptor();
  }
  template <typename T>
  static inline const std::string& Usage_Name(T value) {
    return Certificate_Usage_Name(value);
  }
  static inline bool Usage_Parse(absl::string_view name, Usage* value) {
    return Certificate_Usage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateFieldNumber = 1,
    kKeyFieldNumber = 2,
    kCertificatePathFieldNumber = 5,
    kKeyPathFieldNumber = 6,
    kOcspStaplingFieldNumber = 4,
    kUsageFieldNumber = 3,
    kOneTimeLoadingFieldNumber = 7,
  };
  // bytes certificate = 1;
  void clear_certificate() ;
  const std::string& certificate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_certificate(Arg_&& arg, Args_... args);
  std::string* mutable_certificate();
  PROTOBUF_NODISCARD std::string* release_certificate();
  void set_allocated_certificate(std::string* value);

  private:
  const std::string& _internal_certificate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_certificate(
      const std::string& value);
  std::string* _internal_mutable_certificate();

  public:
  // bytes key = 2;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string certificate_path = 5;
  void clear_certificate_path() ;
  const std::string& certificate_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_certificate_path(Arg_&& arg, Args_... args);
  std::string* mutable_certificate_path();
  PROTOBUF_NODISCARD std::string* release_certificate_path();
  void set_allocated_certificate_path(std::string* value);

  private:
  const std::string& _internal_certificate_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_certificate_path(
      const std::string& value);
  std::string* _internal_mutable_certificate_path();

  public:
  // string key_path = 6;
  void clear_key_path() ;
  const std::string& key_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_path(Arg_&& arg, Args_... args);
  std::string* mutable_key_path();
  PROTOBUF_NODISCARD std::string* release_key_path();
  void set_allocated_key_path(std::string* value);

  private:
  const std::string& _internal_key_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_path(
      const std::string& value);
  std::string* _internal_mutable_key_path();

  public:
  // uint64 ocsp_stapling = 4;
  void clear_ocsp_stapling() ;
  ::uint64_t ocsp_stapling() const;
  void set_ocsp_stapling(::uint64_t value);

  private:
  ::uint64_t _internal_ocsp_stapling() const;
  void _internal_set_ocsp_stapling(::uint64_t value);

  public:
  // .xray.transport.internet.tls.Certificate.Usage usage = 3;
  void clear_usage() ;
  ::xray::transport::internet::tls::Certificate_Usage usage() const;
  void set_usage(::xray::transport::internet::tls::Certificate_Usage value);

  private:
  ::xray::transport::internet::tls::Certificate_Usage _internal_usage() const;
  void _internal_set_usage(::xray::transport::internet::tls::Certificate_Usage value);

  public:
  // bool One_time_loading = 7;
  void clear_one_time_loading() ;
  bool one_time_loading() const;
  void set_one_time_loading(bool value);

  private:
  bool _internal_one_time_loading() const;
  void _internal_set_one_time_loading(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.tls.Certificate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      72, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr certificate_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr certificate_path_;
    ::google::protobuf::internal::ArenaStringPtr key_path_;
    ::uint64_t ocsp_stapling_;
    int usage_;
    bool one_time_loading_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2ftls_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.tls.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Config(::google::protobuf::internal::ConstantInitialized);

  inline Config(const Config& from)
      : Config(nullptr, from) {}
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.tls.Config";
  }
  protected:
  explicit Config(::google::protobuf::Arena* arena);
  Config(::google::protobuf::Arena* arena, const Config& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateFieldNumber = 2,
    kNextProtocolFieldNumber = 4,
    kPinnedPeerCertificateChainSha256FieldNumber = 13,
    kPinnedPeerCertificatePublicKeySha256FieldNumber = 14,
    kServerNameFieldNumber = 3,
    kMinVersionFieldNumber = 7,
    kMaxVersionFieldNumber = 8,
    kCipherSuitesFieldNumber = 9,
    kFingerprintFieldNumber = 11,
    kMasterKeyLogFieldNumber = 15,
    kAllowInsecureFieldNumber = 1,
    kEnableSessionResumptionFieldNumber = 5,
    kDisableSystemRootFieldNumber = 6,
    kPreferServerCipherSuitesFieldNumber = 10,
    kRejectUnknownSniFieldNumber = 12,
  };
  // repeated .xray.transport.internet.tls.Certificate certificate = 2;
  int certificate_size() const;
  private:
  int _internal_certificate_size() const;

  public:
  void clear_certificate() ;
  ::xray::transport::internet::tls::Certificate* mutable_certificate(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::transport::internet::tls::Certificate >*
      mutable_certificate();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::transport::internet::tls::Certificate>& _internal_certificate() const;
  ::google::protobuf::RepeatedPtrField<::xray::transport::internet::tls::Certificate>* _internal_mutable_certificate();
  public:
  const ::xray::transport::internet::tls::Certificate& certificate(int index) const;
  ::xray::transport::internet::tls::Certificate* add_certificate();
  const ::google::protobuf::RepeatedPtrField< ::xray::transport::internet::tls::Certificate >&
      certificate() const;
  // repeated string next_protocol = 4;
  int next_protocol_size() const;
  private:
  int _internal_next_protocol_size() const;

  public:
  void clear_next_protocol() ;
  const std::string& next_protocol(int index) const;
  std::string* mutable_next_protocol(int index);
  void set_next_protocol(int index, const std::string& value);
  void set_next_protocol(int index, std::string&& value);
  void set_next_protocol(int index, const char* value);
  void set_next_protocol(int index, const char* value, std::size_t size);
  void set_next_protocol(int index, absl::string_view value);
  std::string* add_next_protocol();
  void add_next_protocol(const std::string& value);
  void add_next_protocol(std::string&& value);
  void add_next_protocol(const char* value);
  void add_next_protocol(const char* value, std::size_t size);
  void add_next_protocol(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& next_protocol() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_next_protocol();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_next_protocol() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_next_protocol();

  public:
  // repeated bytes pinned_peer_certificate_chain_sha256 = 13;
  int pinned_peer_certificate_chain_sha256_size() const;
  private:
  int _internal_pinned_peer_certificate_chain_sha256_size() const;

  public:
  void clear_pinned_peer_certificate_chain_sha256() ;
  const std::string& pinned_peer_certificate_chain_sha256(int index) const;
  std::string* mutable_pinned_peer_certificate_chain_sha256(int index);
  void set_pinned_peer_certificate_chain_sha256(int index, const std::string& value);
  void set_pinned_peer_certificate_chain_sha256(int index, std::string&& value);
  void set_pinned_peer_certificate_chain_sha256(int index, const char* value);
  void set_pinned_peer_certificate_chain_sha256(int index, const void* value, std::size_t size);
  void set_pinned_peer_certificate_chain_sha256(int index, absl::string_view value);
  std::string* add_pinned_peer_certificate_chain_sha256();
  void add_pinned_peer_certificate_chain_sha256(const std::string& value);
  void add_pinned_peer_certificate_chain_sha256(std::string&& value);
  void add_pinned_peer_certificate_chain_sha256(const char* value);
  void add_pinned_peer_certificate_chain_sha256(const void* value, std::size_t size);
  void add_pinned_peer_certificate_chain_sha256(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& pinned_peer_certificate_chain_sha256() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_pinned_peer_certificate_chain_sha256();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_pinned_peer_certificate_chain_sha256() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_pinned_peer_certificate_chain_sha256();

  public:
  // repeated bytes pinned_peer_certificate_public_key_sha256 = 14;
  int pinned_peer_certificate_public_key_sha256_size() const;
  private:
  int _internal_pinned_peer_certificate_public_key_sha256_size() const;

  public:
  void clear_pinned_peer_certificate_public_key_sha256() ;
  const std::string& pinned_peer_certificate_public_key_sha256(int index) const;
  std::string* mutable_pinned_peer_certificate_public_key_sha256(int index);
  void set_pinned_peer_certificate_public_key_sha256(int index, const std::string& value);
  void set_pinned_peer_certificate_public_key_sha256(int index, std::string&& value);
  void set_pinned_peer_certificate_public_key_sha256(int index, const char* value);
  void set_pinned_peer_certificate_public_key_sha256(int index, const void* value, std::size_t size);
  void set_pinned_peer_certificate_public_key_sha256(int index, absl::string_view value);
  std::string* add_pinned_peer_certificate_public_key_sha256();
  void add_pinned_peer_certificate_public_key_sha256(const std::string& value);
  void add_pinned_peer_certificate_public_key_sha256(std::string&& value);
  void add_pinned_peer_certificate_public_key_sha256(const char* value);
  void add_pinned_peer_certificate_public_key_sha256(const void* value, std::size_t size);
  void add_pinned_peer_certificate_public_key_sha256(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& pinned_peer_certificate_public_key_sha256() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_pinned_peer_certificate_public_key_sha256();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_pinned_peer_certificate_public_key_sha256() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_pinned_peer_certificate_public_key_sha256();

  public:
  // string server_name = 3;
  void clear_server_name() ;
  const std::string& server_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_name(Arg_&& arg, Args_... args);
  std::string* mutable_server_name();
  PROTOBUF_NODISCARD std::string* release_server_name();
  void set_allocated_server_name(std::string* value);

  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(
      const std::string& value);
  std::string* _internal_mutable_server_name();

  public:
  // string min_version = 7;
  void clear_min_version() ;
  const std::string& min_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_version(Arg_&& arg, Args_... args);
  std::string* mutable_min_version();
  PROTOBUF_NODISCARD std::string* release_min_version();
  void set_allocated_min_version(std::string* value);

  private:
  const std::string& _internal_min_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_version(
      const std::string& value);
  std::string* _internal_mutable_min_version();

  public:
  // string max_version = 8;
  void clear_max_version() ;
  const std::string& max_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_version(Arg_&& arg, Args_... args);
  std::string* mutable_max_version();
  PROTOBUF_NODISCARD std::string* release_max_version();
  void set_allocated_max_version(std::string* value);

  private:
  const std::string& _internal_max_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_version(
      const std::string& value);
  std::string* _internal_mutable_max_version();

  public:
  // string cipher_suites = 9;
  void clear_cipher_suites() ;
  const std::string& cipher_suites() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cipher_suites(Arg_&& arg, Args_... args);
  std::string* mutable_cipher_suites();
  PROTOBUF_NODISCARD std::string* release_cipher_suites();
  void set_allocated_cipher_suites(std::string* value);

  private:
  const std::string& _internal_cipher_suites() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cipher_suites(
      const std::string& value);
  std::string* _internal_mutable_cipher_suites();

  public:
  // string fingerprint = 11;
  void clear_fingerprint() ;
  const std::string& fingerprint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fingerprint(Arg_&& arg, Args_... args);
  std::string* mutable_fingerprint();
  PROTOBUF_NODISCARD std::string* release_fingerprint();
  void set_allocated_fingerprint(std::string* value);

  private:
  const std::string& _internal_fingerprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fingerprint(
      const std::string& value);
  std::string* _internal_mutable_fingerprint();

  public:
  // string master_key_log = 15;
  void clear_master_key_log() ;
  const std::string& master_key_log() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_master_key_log(Arg_&& arg, Args_... args);
  std::string* mutable_master_key_log();
  PROTOBUF_NODISCARD std::string* release_master_key_log();
  void set_allocated_master_key_log(std::string* value);

  private:
  const std::string& _internal_master_key_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master_key_log(
      const std::string& value);
  std::string* _internal_mutable_master_key_log();

  public:
  // bool allow_insecure = 1;
  void clear_allow_insecure() ;
  bool allow_insecure() const;
  void set_allow_insecure(bool value);

  private:
  bool _internal_allow_insecure() const;
  void _internal_set_allow_insecure(bool value);

  public:
  // bool enable_session_resumption = 5;
  void clear_enable_session_resumption() ;
  bool enable_session_resumption() const;
  void set_enable_session_resumption(bool value);

  private:
  bool _internal_enable_session_resumption() const;
  void _internal_set_enable_session_resumption(bool value);

  public:
  // bool disable_system_root = 6;
  void clear_disable_system_root() ;
  bool disable_system_root() const;
  void set_disable_system_root(bool value);

  private:
  bool _internal_disable_system_root() const;
  void _internal_set_disable_system_root(bool value);

  public:
  // bool prefer_server_cipher_suites = 10;
  void clear_prefer_server_cipher_suites() ;
  bool prefer_server_cipher_suites() const;
  void set_prefer_server_cipher_suites(bool value);

  private:
  bool _internal_prefer_server_cipher_suites() const;
  void _internal_set_prefer_server_cipher_suites(bool value);

  public:
  // bool reject_unknown_sni = 12;
  void clear_reject_unknown_sni() ;
  bool reject_unknown_sni() const;
  void set_reject_unknown_sni(bool value);

  private:
  bool _internal_reject_unknown_sni() const;
  void _internal_set_reject_unknown_sni(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.tls.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 1,
      135, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::transport::internet::tls::Certificate > certificate_;
    ::google::protobuf::RepeatedPtrField<std::string> next_protocol_;
    ::google::protobuf::RepeatedPtrField<std::string> pinned_peer_certificate_chain_sha256_;
    ::google::protobuf::RepeatedPtrField<std::string> pinned_peer_certificate_public_key_sha256_;
    ::google::protobuf::internal::ArenaStringPtr server_name_;
    ::google::protobuf::internal::ArenaStringPtr min_version_;
    ::google::protobuf::internal::ArenaStringPtr max_version_;
    ::google::protobuf::internal::ArenaStringPtr cipher_suites_;
    ::google::protobuf::internal::ArenaStringPtr fingerprint_;
    ::google::protobuf::internal::ArenaStringPtr master_key_log_;
    bool allow_insecure_;
    bool enable_session_resumption_;
    bool disable_system_root_;
    bool prefer_server_cipher_suites_;
    bool reject_unknown_sni_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2ftls_2fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Certificate

// bytes certificate = 1;
inline void Certificate::clear_certificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.certificate_.ClearToEmpty();
}
inline const std::string& Certificate::certificate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Certificate.certificate)
  return _internal_certificate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Certificate::set_certificate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.certificate_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Certificate.certificate)
}
inline std::string* Certificate::mutable_certificate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_certificate();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Certificate.certificate)
  return _s;
}
inline const std::string& Certificate::_internal_certificate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.certificate_.Get();
}
inline void Certificate::_internal_set_certificate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.certificate_.Set(value, GetArena());
}
inline std::string* Certificate::_internal_mutable_certificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.certificate_.Mutable( GetArena());
}
inline std::string* Certificate::release_certificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Certificate.certificate)
  return _impl_.certificate_.Release();
}
inline void Certificate::set_allocated_certificate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.certificate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.certificate_.IsDefault()) {
          _impl_.certificate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Certificate.certificate)
}

// bytes key = 2;
inline void Certificate::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Certificate::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Certificate.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Certificate::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Certificate.key)
}
inline std::string* Certificate::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Certificate.key)
  return _s;
}
inline const std::string& Certificate::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void Certificate::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* Certificate::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* Certificate::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Certificate.key)
  return _impl_.key_.Release();
}
inline void Certificate::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Certificate.key)
}

// .xray.transport.internet.tls.Certificate.Usage usage = 3;
inline void Certificate::clear_usage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usage_ = 0;
}
inline ::xray::transport::internet::tls::Certificate_Usage Certificate::usage() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Certificate.usage)
  return _internal_usage();
}
inline void Certificate::set_usage(::xray::transport::internet::tls::Certificate_Usage value) {
  _internal_set_usage(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Certificate.usage)
}
inline ::xray::transport::internet::tls::Certificate_Usage Certificate::_internal_usage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::transport::internet::tls::Certificate_Usage>(_impl_.usage_);
}
inline void Certificate::_internal_set_usage(::xray::transport::internet::tls::Certificate_Usage value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usage_ = value;
}

// uint64 ocsp_stapling = 4;
inline void Certificate::clear_ocsp_stapling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ocsp_stapling_ = ::uint64_t{0u};
}
inline ::uint64_t Certificate::ocsp_stapling() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Certificate.ocsp_stapling)
  return _internal_ocsp_stapling();
}
inline void Certificate::set_ocsp_stapling(::uint64_t value) {
  _internal_set_ocsp_stapling(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Certificate.ocsp_stapling)
}
inline ::uint64_t Certificate::_internal_ocsp_stapling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ocsp_stapling_;
}
inline void Certificate::_internal_set_ocsp_stapling(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ocsp_stapling_ = value;
}

// string certificate_path = 5;
inline void Certificate::clear_certificate_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.certificate_path_.ClearToEmpty();
}
inline const std::string& Certificate::certificate_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Certificate.certificate_path)
  return _internal_certificate_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Certificate::set_certificate_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.certificate_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Certificate.certificate_path)
}
inline std::string* Certificate::mutable_certificate_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_certificate_path();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Certificate.certificate_path)
  return _s;
}
inline const std::string& Certificate::_internal_certificate_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.certificate_path_.Get();
}
inline void Certificate::_internal_set_certificate_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.certificate_path_.Set(value, GetArena());
}
inline std::string* Certificate::_internal_mutable_certificate_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.certificate_path_.Mutable( GetArena());
}
inline std::string* Certificate::release_certificate_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Certificate.certificate_path)
  return _impl_.certificate_path_.Release();
}
inline void Certificate::set_allocated_certificate_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.certificate_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.certificate_path_.IsDefault()) {
          _impl_.certificate_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Certificate.certificate_path)
}

// string key_path = 6;
inline void Certificate::clear_key_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_path_.ClearToEmpty();
}
inline const std::string& Certificate::key_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Certificate.key_path)
  return _internal_key_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Certificate::set_key_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Certificate.key_path)
}
inline std::string* Certificate::mutable_key_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_path();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Certificate.key_path)
  return _s;
}
inline const std::string& Certificate::_internal_key_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_path_.Get();
}
inline void Certificate::_internal_set_key_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_path_.Set(value, GetArena());
}
inline std::string* Certificate::_internal_mutable_key_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_path_.Mutable( GetArena());
}
inline std::string* Certificate::release_key_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Certificate.key_path)
  return _impl_.key_path_.Release();
}
inline void Certificate::set_allocated_key_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_path_.IsDefault()) {
          _impl_.key_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Certificate.key_path)
}

// bool One_time_loading = 7;
inline void Certificate::clear_one_time_loading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.one_time_loading_ = false;
}
inline bool Certificate::one_time_loading() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Certificate.One_time_loading)
  return _internal_one_time_loading();
}
inline void Certificate::set_one_time_loading(bool value) {
  _internal_set_one_time_loading(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Certificate.One_time_loading)
}
inline bool Certificate::_internal_one_time_loading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.one_time_loading_;
}
inline void Certificate::_internal_set_one_time_loading(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.one_time_loading_ = value;
}

// -------------------------------------------------------------------

// Config

// bool allow_insecure = 1;
inline void Config::clear_allow_insecure() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_insecure_ = false;
}
inline bool Config::allow_insecure() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.allow_insecure)
  return _internal_allow_insecure();
}
inline void Config::set_allow_insecure(bool value) {
  _internal_set_allow_insecure(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.allow_insecure)
}
inline bool Config::_internal_allow_insecure() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_insecure_;
}
inline void Config::_internal_set_allow_insecure(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allow_insecure_ = value;
}

// repeated .xray.transport.internet.tls.Certificate certificate = 2;
inline int Config::_internal_certificate_size() const {
  return _internal_certificate().size();
}
inline int Config::certificate_size() const {
  return _internal_certificate_size();
}
inline void Config::clear_certificate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.certificate_.Clear();
}
inline ::xray::transport::internet::tls::Certificate* Config::mutable_certificate(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.certificate)
  return _internal_mutable_certificate()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::transport::internet::tls::Certificate>* Config::mutable_certificate()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.transport.internet.tls.Config.certificate)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_certificate();
}
inline const ::xray::transport::internet::tls::Certificate& Config::certificate(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.certificate)
  return _internal_certificate().Get(index);
}
inline ::xray::transport::internet::tls::Certificate* Config::add_certificate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::transport::internet::tls::Certificate* _add = _internal_mutable_certificate()->Add();
  // @@protoc_insertion_point(field_add:xray.transport.internet.tls.Config.certificate)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::transport::internet::tls::Certificate>& Config::certificate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.transport.internet.tls.Config.certificate)
  return _internal_certificate();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::transport::internet::tls::Certificate>&
Config::_internal_certificate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.certificate_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::transport::internet::tls::Certificate>*
Config::_internal_mutable_certificate() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.certificate_;
}

// string server_name = 3;
inline void Config::clear_server_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_name_.ClearToEmpty();
}
inline const std::string& Config::server_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.server_name)
  return _internal_server_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_server_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.server_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.server_name)
}
inline std::string* Config::mutable_server_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.server_name)
  return _s;
}
inline const std::string& Config::_internal_server_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_name_.Get();
}
inline void Config::_internal_set_server_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.server_name_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_server_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.server_name_.Mutable( GetArena());
}
inline std::string* Config::release_server_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Config.server_name)
  return _impl_.server_name_.Release();
}
inline void Config::set_allocated_server_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.server_name_.IsDefault()) {
          _impl_.server_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Config.server_name)
}

// repeated string next_protocol = 4;
inline int Config::_internal_next_protocol_size() const {
  return _internal_next_protocol().size();
}
inline int Config::next_protocol_size() const {
  return _internal_next_protocol_size();
}
inline void Config::clear_next_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_protocol_.Clear();
}
inline std::string* Config::add_next_protocol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_next_protocol()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.transport.internet.tls.Config.next_protocol)
  return _s;
}
inline const std::string& Config::next_protocol(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.next_protocol)
  return _internal_next_protocol().Get(index);
}
inline std::string* Config::mutable_next_protocol(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.next_protocol)
  return _internal_mutable_next_protocol()->Mutable(index);
}
inline void Config::set_next_protocol(int index, const std::string& value) {
  _internal_mutable_next_protocol()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::set_next_protocol(int index, std::string&& value) {
  _internal_mutable_next_protocol()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::set_next_protocol(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_next_protocol()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::set_next_protocol(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_next_protocol()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::set_next_protocol(int index, absl::string_view value) {
  _internal_mutable_next_protocol()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::add_next_protocol(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_next_protocol()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::add_next_protocol(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_next_protocol()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::add_next_protocol(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_next_protocol()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::add_next_protocol(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_next_protocol()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.transport.internet.tls.Config.next_protocol)
}
inline void Config::add_next_protocol(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_next_protocol()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.transport.internet.tls.Config.next_protocol)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config::next_protocol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.transport.internet.tls.Config.next_protocol)
  return _internal_next_protocol();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config::mutable_next_protocol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.transport.internet.tls.Config.next_protocol)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_next_protocol();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config::_internal_next_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_protocol_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config::_internal_mutable_next_protocol() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.next_protocol_;
}

// bool enable_session_resumption = 5;
inline void Config::clear_enable_session_resumption() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_session_resumption_ = false;
}
inline bool Config::enable_session_resumption() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.enable_session_resumption)
  return _internal_enable_session_resumption();
}
inline void Config::set_enable_session_resumption(bool value) {
  _internal_set_enable_session_resumption(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.enable_session_resumption)
}
inline bool Config::_internal_enable_session_resumption() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_session_resumption_;
}
inline void Config::_internal_set_enable_session_resumption(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_session_resumption_ = value;
}

// bool disable_system_root = 6;
inline void Config::clear_disable_system_root() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_system_root_ = false;
}
inline bool Config::disable_system_root() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.disable_system_root)
  return _internal_disable_system_root();
}
inline void Config::set_disable_system_root(bool value) {
  _internal_set_disable_system_root(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.disable_system_root)
}
inline bool Config::_internal_disable_system_root() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_system_root_;
}
inline void Config::_internal_set_disable_system_root(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disable_system_root_ = value;
}

// string min_version = 7;
inline void Config::clear_min_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_version_.ClearToEmpty();
}
inline const std::string& Config::min_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.min_version)
  return _internal_min_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_min_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.min_version)
}
inline std::string* Config::mutable_min_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_min_version();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.min_version)
  return _s;
}
inline const std::string& Config::_internal_min_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_version_.Get();
}
inline void Config::_internal_set_min_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_version_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_min_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.min_version_.Mutable( GetArena());
}
inline std::string* Config::release_min_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Config.min_version)
  return _impl_.min_version_.Release();
}
inline void Config::set_allocated_min_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_version_.IsDefault()) {
          _impl_.min_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Config.min_version)
}

// string max_version = 8;
inline void Config::clear_max_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_version_.ClearToEmpty();
}
inline const std::string& Config::max_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.max_version)
  return _internal_max_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_max_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.max_version)
}
inline std::string* Config::mutable_max_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_max_version();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.max_version)
  return _s;
}
inline const std::string& Config::_internal_max_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_version_.Get();
}
inline void Config::_internal_set_max_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_version_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_max_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.max_version_.Mutable( GetArena());
}
inline std::string* Config::release_max_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Config.max_version)
  return _impl_.max_version_.Release();
}
inline void Config::set_allocated_max_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.max_version_.IsDefault()) {
          _impl_.max_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Config.max_version)
}

// string cipher_suites = 9;
inline void Config::clear_cipher_suites() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cipher_suites_.ClearToEmpty();
}
inline const std::string& Config::cipher_suites() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.cipher_suites)
  return _internal_cipher_suites();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_cipher_suites(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cipher_suites_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.cipher_suites)
}
inline std::string* Config::mutable_cipher_suites() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cipher_suites();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.cipher_suites)
  return _s;
}
inline const std::string& Config::_internal_cipher_suites() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cipher_suites_.Get();
}
inline void Config::_internal_set_cipher_suites(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cipher_suites_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_cipher_suites() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.cipher_suites_.Mutable( GetArena());
}
inline std::string* Config::release_cipher_suites() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Config.cipher_suites)
  return _impl_.cipher_suites_.Release();
}
inline void Config::set_allocated_cipher_suites(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cipher_suites_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cipher_suites_.IsDefault()) {
          _impl_.cipher_suites_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Config.cipher_suites)
}

// bool prefer_server_cipher_suites = 10;
inline void Config::clear_prefer_server_cipher_suites() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prefer_server_cipher_suites_ = false;
}
inline bool Config::prefer_server_cipher_suites() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.prefer_server_cipher_suites)
  return _internal_prefer_server_cipher_suites();
}
inline void Config::set_prefer_server_cipher_suites(bool value) {
  _internal_set_prefer_server_cipher_suites(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.prefer_server_cipher_suites)
}
inline bool Config::_internal_prefer_server_cipher_suites() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prefer_server_cipher_suites_;
}
inline void Config::_internal_set_prefer_server_cipher_suites(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prefer_server_cipher_suites_ = value;
}

// string fingerprint = 11;
inline void Config::clear_fingerprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fingerprint_.ClearToEmpty();
}
inline const std::string& Config::fingerprint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.fingerprint)
  return _internal_fingerprint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_fingerprint(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fingerprint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.fingerprint)
}
inline std::string* Config::mutable_fingerprint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.fingerprint)
  return _s;
}
inline const std::string& Config::_internal_fingerprint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fingerprint_.Get();
}
inline void Config::_internal_set_fingerprint(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fingerprint_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_fingerprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fingerprint_.Mutable( GetArena());
}
inline std::string* Config::release_fingerprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Config.fingerprint)
  return _impl_.fingerprint_.Release();
}
inline void Config::set_allocated_fingerprint(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fingerprint_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fingerprint_.IsDefault()) {
          _impl_.fingerprint_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Config.fingerprint)
}

// bool reject_unknown_sni = 12;
inline void Config::clear_reject_unknown_sni() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reject_unknown_sni_ = false;
}
inline bool Config::reject_unknown_sni() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.reject_unknown_sni)
  return _internal_reject_unknown_sni();
}
inline void Config::set_reject_unknown_sni(bool value) {
  _internal_set_reject_unknown_sni(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.reject_unknown_sni)
}
inline bool Config::_internal_reject_unknown_sni() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reject_unknown_sni_;
}
inline void Config::_internal_set_reject_unknown_sni(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reject_unknown_sni_ = value;
}

// repeated bytes pinned_peer_certificate_chain_sha256 = 13;
inline int Config::_internal_pinned_peer_certificate_chain_sha256_size() const {
  return _internal_pinned_peer_certificate_chain_sha256().size();
}
inline int Config::pinned_peer_certificate_chain_sha256_size() const {
  return _internal_pinned_peer_certificate_chain_sha256_size();
}
inline void Config::clear_pinned_peer_certificate_chain_sha256() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pinned_peer_certificate_chain_sha256_.Clear();
}
inline std::string* Config::add_pinned_peer_certificate_chain_sha256()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_pinned_peer_certificate_chain_sha256()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
  return _s;
}
inline const std::string& Config::pinned_peer_certificate_chain_sha256(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
  return _internal_pinned_peer_certificate_chain_sha256().Get(index);
}
inline std::string* Config::mutable_pinned_peer_certificate_chain_sha256(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
  return _internal_mutable_pinned_peer_certificate_chain_sha256()->Mutable(index);
}
inline void Config::set_pinned_peer_certificate_chain_sha256(int index, const std::string& value) {
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::set_pinned_peer_certificate_chain_sha256(int index, std::string&& value) {
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::set_pinned_peer_certificate_chain_sha256(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::set_pinned_peer_certificate_chain_sha256(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::set_pinned_peer_certificate_chain_sha256(int index, absl::string_view value) {
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::add_pinned_peer_certificate_chain_sha256(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::add_pinned_peer_certificate_chain_sha256(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::add_pinned_peer_certificate_chain_sha256(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::add_pinned_peer_certificate_chain_sha256(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline void Config::add_pinned_peer_certificate_chain_sha256(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_chain_sha256()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config::pinned_peer_certificate_chain_sha256() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
  return _internal_pinned_peer_certificate_chain_sha256();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config::mutable_pinned_peer_certificate_chain_sha256() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.transport.internet.tls.Config.pinned_peer_certificate_chain_sha256)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_pinned_peer_certificate_chain_sha256();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config::_internal_pinned_peer_certificate_chain_sha256() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pinned_peer_certificate_chain_sha256_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config::_internal_mutable_pinned_peer_certificate_chain_sha256() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.pinned_peer_certificate_chain_sha256_;
}

// repeated bytes pinned_peer_certificate_public_key_sha256 = 14;
inline int Config::_internal_pinned_peer_certificate_public_key_sha256_size() const {
  return _internal_pinned_peer_certificate_public_key_sha256().size();
}
inline int Config::pinned_peer_certificate_public_key_sha256_size() const {
  return _internal_pinned_peer_certificate_public_key_sha256_size();
}
inline void Config::clear_pinned_peer_certificate_public_key_sha256() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pinned_peer_certificate_public_key_sha256_.Clear();
}
inline std::string* Config::add_pinned_peer_certificate_public_key_sha256()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_pinned_peer_certificate_public_key_sha256()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
  return _s;
}
inline const std::string& Config::pinned_peer_certificate_public_key_sha256(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
  return _internal_pinned_peer_certificate_public_key_sha256().Get(index);
}
inline std::string* Config::mutable_pinned_peer_certificate_public_key_sha256(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
  return _internal_mutable_pinned_peer_certificate_public_key_sha256()->Mutable(index);
}
inline void Config::set_pinned_peer_certificate_public_key_sha256(int index, const std::string& value) {
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::set_pinned_peer_certificate_public_key_sha256(int index, std::string&& value) {
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::set_pinned_peer_certificate_public_key_sha256(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::set_pinned_peer_certificate_public_key_sha256(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::set_pinned_peer_certificate_public_key_sha256(int index, absl::string_view value) {
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::add_pinned_peer_certificate_public_key_sha256(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::add_pinned_peer_certificate_public_key_sha256(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::add_pinned_peer_certificate_public_key_sha256(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::add_pinned_peer_certificate_public_key_sha256(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline void Config::add_pinned_peer_certificate_public_key_sha256(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_pinned_peer_certificate_public_key_sha256()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config::pinned_peer_certificate_public_key_sha256() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
  return _internal_pinned_peer_certificate_public_key_sha256();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config::mutable_pinned_peer_certificate_public_key_sha256() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.transport.internet.tls.Config.pinned_peer_certificate_public_key_sha256)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_pinned_peer_certificate_public_key_sha256();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config::_internal_pinned_peer_certificate_public_key_sha256() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pinned_peer_certificate_public_key_sha256_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config::_internal_mutable_pinned_peer_certificate_public_key_sha256() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.pinned_peer_certificate_public_key_sha256_;
}

// string master_key_log = 15;
inline void Config::clear_master_key_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.master_key_log_.ClearToEmpty();
}
inline const std::string& Config::master_key_log() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.tls.Config.master_key_log)
  return _internal_master_key_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_master_key_log(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.master_key_log_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.tls.Config.master_key_log)
}
inline std::string* Config::mutable_master_key_log() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_master_key_log();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.tls.Config.master_key_log)
  return _s;
}
inline const std::string& Config::_internal_master_key_log() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.master_key_log_.Get();
}
inline void Config::_internal_set_master_key_log(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.master_key_log_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_master_key_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.master_key_log_.Mutable( GetArena());
}
inline std::string* Config::release_master_key_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.tls.Config.master_key_log)
  return _impl_.master_key_log_.Release();
}
inline void Config::set_allocated_master_key_log(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.master_key_log_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.master_key_log_.IsDefault()) {
          _impl_.master_key_log_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.tls.Config.master_key_log)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tls
}  // namespace internet
}  // namespace transport
}  // namespace xray


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::xray::transport::internet::tls::Certificate_Usage> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::transport::internet::tls::Certificate_Usage>() {
  return ::xray::transport::internet::tls::Certificate_Usage_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2ftls_2fconfig_2eproto_2epb_2eh
