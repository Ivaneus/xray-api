// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport/internet/config.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2fconfig_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common/serial/typed_message.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_transport_2finternet_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_transport_2finternet_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_transport_2finternet_2fconfig_2eproto;
namespace xray {
namespace transport {
namespace internet {
class ProxyConfig;
struct ProxyConfigDefaultTypeInternal;
extern ProxyConfigDefaultTypeInternal _ProxyConfig_default_instance_;
class SocketConfig;
struct SocketConfigDefaultTypeInternal;
extern SocketConfigDefaultTypeInternal _SocketConfig_default_instance_;
class StreamConfig;
struct StreamConfigDefaultTypeInternal;
extern StreamConfigDefaultTypeInternal _StreamConfig_default_instance_;
class TransportConfig;
struct TransportConfigDefaultTypeInternal;
extern TransportConfigDefaultTypeInternal _TransportConfig_default_instance_;
}  // namespace internet
}  // namespace transport
}  // namespace xray
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xray {
namespace transport {
namespace internet {
enum SocketConfig_TProxyMode : int {
  SocketConfig_TProxyMode_Off = 0,
  SocketConfig_TProxyMode_TProxy = 1,
  SocketConfig_TProxyMode_Redirect = 2,
  SocketConfig_TProxyMode_SocketConfig_TProxyMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SocketConfig_TProxyMode_SocketConfig_TProxyMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SocketConfig_TProxyMode_IsValid(int value);
extern const uint32_t SocketConfig_TProxyMode_internal_data_[];
constexpr SocketConfig_TProxyMode SocketConfig_TProxyMode_TProxyMode_MIN = static_cast<SocketConfig_TProxyMode>(0);
constexpr SocketConfig_TProxyMode SocketConfig_TProxyMode_TProxyMode_MAX = static_cast<SocketConfig_TProxyMode>(2);
constexpr int SocketConfig_TProxyMode_TProxyMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SocketConfig_TProxyMode_descriptor();
template <typename T>
const std::string& SocketConfig_TProxyMode_Name(T value) {
  static_assert(std::is_same<T, SocketConfig_TProxyMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TProxyMode_Name().");
  return SocketConfig_TProxyMode_Name(static_cast<SocketConfig_TProxyMode>(value));
}
template <>
inline const std::string& SocketConfig_TProxyMode_Name(SocketConfig_TProxyMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SocketConfig_TProxyMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SocketConfig_TProxyMode_Parse(absl::string_view name, SocketConfig_TProxyMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SocketConfig_TProxyMode>(
      SocketConfig_TProxyMode_descriptor(), name, value);
}
enum TransportProtocol : int {
  TCP = 0,
  UDP = 1,
  MKCP = 2,
  WebSocket = 3,
  HTTP = 4,
  DomainSocket = 5,
  TransportProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TransportProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TransportProtocol_IsValid(int value);
extern const uint32_t TransportProtocol_internal_data_[];
constexpr TransportProtocol TransportProtocol_MIN = static_cast<TransportProtocol>(0);
constexpr TransportProtocol TransportProtocol_MAX = static_cast<TransportProtocol>(5);
constexpr int TransportProtocol_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TransportProtocol_descriptor();
template <typename T>
const std::string& TransportProtocol_Name(T value) {
  static_assert(std::is_same<T, TransportProtocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TransportProtocol_Name().");
  return TransportProtocol_Name(static_cast<TransportProtocol>(value));
}
template <>
inline const std::string& TransportProtocol_Name(TransportProtocol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TransportProtocol_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TransportProtocol_Parse(absl::string_view name, TransportProtocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransportProtocol>(
      TransportProtocol_descriptor(), name, value);
}
enum DomainStrategy : int {
  AS_IS = 0,
  USE_IP = 1,
  USE_IP4 = 2,
  USE_IP6 = 3,
  USE_IP46 = 4,
  USE_IP64 = 5,
  FORCE_IP = 6,
  FORCE_IP4 = 7,
  FORCE_IP6 = 8,
  FORCE_IP46 = 9,
  FORCE_IP64 = 10,
  DomainStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DomainStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DomainStrategy_IsValid(int value);
extern const uint32_t DomainStrategy_internal_data_[];
constexpr DomainStrategy DomainStrategy_MIN = static_cast<DomainStrategy>(0);
constexpr DomainStrategy DomainStrategy_MAX = static_cast<DomainStrategy>(10);
constexpr int DomainStrategy_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
DomainStrategy_descriptor();
template <typename T>
const std::string& DomainStrategy_Name(T value) {
  static_assert(std::is_same<T, DomainStrategy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DomainStrategy_Name().");
  return DomainStrategy_Name(static_cast<DomainStrategy>(value));
}
template <>
inline const std::string& DomainStrategy_Name(DomainStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DomainStrategy_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool DomainStrategy_Parse(absl::string_view name, DomainStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DomainStrategy>(
      DomainStrategy_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SocketConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.SocketConfig) */ {
 public:
  inline SocketConfig() : SocketConfig(nullptr) {}
  ~SocketConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SocketConfig(::google::protobuf::internal::ConstantInitialized);

  inline SocketConfig(const SocketConfig& from)
      : SocketConfig(nullptr, from) {}
  SocketConfig(SocketConfig&& from) noexcept
    : SocketConfig() {
    *this = ::std::move(from);
  }

  inline SocketConfig& operator=(const SocketConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SocketConfig& operator=(SocketConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SocketConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SocketConfig* internal_default_instance() {
    return reinterpret_cast<const SocketConfig*>(
               &_SocketConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SocketConfig& a, SocketConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SocketConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SocketConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SocketConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SocketConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SocketConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SocketConfig& from) {
    SocketConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SocketConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.SocketConfig";
  }
  protected:
  explicit SocketConfig(::google::protobuf::Arena* arena);
  SocketConfig(::google::protobuf::Arena* arena, const SocketConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TProxyMode = SocketConfig_TProxyMode;
  static constexpr TProxyMode Off = SocketConfig_TProxyMode_Off;
  static constexpr TProxyMode TProxy = SocketConfig_TProxyMode_TProxy;
  static constexpr TProxyMode Redirect = SocketConfig_TProxyMode_Redirect;
  static inline bool TProxyMode_IsValid(int value) {
    return SocketConfig_TProxyMode_IsValid(value);
  }
  static constexpr TProxyMode TProxyMode_MIN = SocketConfig_TProxyMode_TProxyMode_MIN;
  static constexpr TProxyMode TProxyMode_MAX = SocketConfig_TProxyMode_TProxyMode_MAX;
  static constexpr int TProxyMode_ARRAYSIZE = SocketConfig_TProxyMode_TProxyMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TProxyMode_descriptor() {
    return SocketConfig_TProxyMode_descriptor();
  }
  template <typename T>
  static inline const std::string& TProxyMode_Name(T value) {
    return SocketConfig_TProxyMode_Name(value);
  }
  static inline bool TProxyMode_Parse(absl::string_view name, TProxyMode* value) {
    return SocketConfig_TProxyMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBindAddressFieldNumber = 5,
    kDialerProxyFieldNumber = 9,
    kTcpCongestionFieldNumber = 12,
    kInterfaceFieldNumber = 13,
    kMarkFieldNumber = 1,
    kTfoFieldNumber = 2,
    kTproxyFieldNumber = 3,
    kBindPortFieldNumber = 6,
    kDomainStrategyFieldNumber = 8,
    kTcpKeepAliveIntervalFieldNumber = 10,
    kReceiveOriginalDestAddressFieldNumber = 4,
    kAcceptProxyProtocolFieldNumber = 7,
    kV6OnlyFieldNumber = 14,
    kTcpNoDelayFieldNumber = 18,
    kTcpKeepAliveIdleFieldNumber = 11,
    kTcpWindowClampFieldNumber = 15,
    kTcpUserTimeoutFieldNumber = 16,
    kTcpMaxSegFieldNumber = 17,
    kTcpMptcpFieldNumber = 19,
  };
  // bytes bind_address = 5;
  void clear_bind_address() ;
  const std::string& bind_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bind_address(Arg_&& arg, Args_... args);
  std::string* mutable_bind_address();
  PROTOBUF_NODISCARD std::string* release_bind_address();
  void set_allocated_bind_address(std::string* value);

  private:
  const std::string& _internal_bind_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bind_address(
      const std::string& value);
  std::string* _internal_mutable_bind_address();

  public:
  // string dialer_proxy = 9;
  void clear_dialer_proxy() ;
  const std::string& dialer_proxy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dialer_proxy(Arg_&& arg, Args_... args);
  std::string* mutable_dialer_proxy();
  PROTOBUF_NODISCARD std::string* release_dialer_proxy();
  void set_allocated_dialer_proxy(std::string* value);

  private:
  const std::string& _internal_dialer_proxy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialer_proxy(
      const std::string& value);
  std::string* _internal_mutable_dialer_proxy();

  public:
  // string tcp_congestion = 12;
  void clear_tcp_congestion() ;
  const std::string& tcp_congestion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tcp_congestion(Arg_&& arg, Args_... args);
  std::string* mutable_tcp_congestion();
  PROTOBUF_NODISCARD std::string* release_tcp_congestion();
  void set_allocated_tcp_congestion(std::string* value);

  private:
  const std::string& _internal_tcp_congestion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tcp_congestion(
      const std::string& value);
  std::string* _internal_mutable_tcp_congestion();

  public:
  // string interface = 13;
  void clear_interface() ;
  const std::string& interface() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface(Arg_&& arg, Args_... args);
  std::string* mutable_interface();
  PROTOBUF_NODISCARD std::string* release_interface();
  void set_allocated_interface(std::string* value);

  private:
  const std::string& _internal_interface() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface(
      const std::string& value);
  std::string* _internal_mutable_interface();

  public:
  // int32 mark = 1;
  void clear_mark() ;
  ::int32_t mark() const;
  void set_mark(::int32_t value);

  private:
  ::int32_t _internal_mark() const;
  void _internal_set_mark(::int32_t value);

  public:
  // int32 tfo = 2;
  void clear_tfo() ;
  ::int32_t tfo() const;
  void set_tfo(::int32_t value);

  private:
  ::int32_t _internal_tfo() const;
  void _internal_set_tfo(::int32_t value);

  public:
  // .xray.transport.internet.SocketConfig.TProxyMode tproxy = 3;
  void clear_tproxy() ;
  ::xray::transport::internet::SocketConfig_TProxyMode tproxy() const;
  void set_tproxy(::xray::transport::internet::SocketConfig_TProxyMode value);

  private:
  ::xray::transport::internet::SocketConfig_TProxyMode _internal_tproxy() const;
  void _internal_set_tproxy(::xray::transport::internet::SocketConfig_TProxyMode value);

  public:
  // uint32 bind_port = 6;
  void clear_bind_port() ;
  ::uint32_t bind_port() const;
  void set_bind_port(::uint32_t value);

  private:
  ::uint32_t _internal_bind_port() const;
  void _internal_set_bind_port(::uint32_t value);

  public:
  // .xray.transport.internet.DomainStrategy domain_strategy = 8;
  void clear_domain_strategy() ;
  ::xray::transport::internet::DomainStrategy domain_strategy() const;
  void set_domain_strategy(::xray::transport::internet::DomainStrategy value);

  private:
  ::xray::transport::internet::DomainStrategy _internal_domain_strategy() const;
  void _internal_set_domain_strategy(::xray::transport::internet::DomainStrategy value);

  public:
  // int32 tcp_keep_alive_interval = 10;
  void clear_tcp_keep_alive_interval() ;
  ::int32_t tcp_keep_alive_interval() const;
  void set_tcp_keep_alive_interval(::int32_t value);

  private:
  ::int32_t _internal_tcp_keep_alive_interval() const;
  void _internal_set_tcp_keep_alive_interval(::int32_t value);

  public:
  // bool receive_original_dest_address = 4;
  void clear_receive_original_dest_address() ;
  bool receive_original_dest_address() const;
  void set_receive_original_dest_address(bool value);

  private:
  bool _internal_receive_original_dest_address() const;
  void _internal_set_receive_original_dest_address(bool value);

  public:
  // bool accept_proxy_protocol = 7;
  void clear_accept_proxy_protocol() ;
  bool accept_proxy_protocol() const;
  void set_accept_proxy_protocol(bool value);

  private:
  bool _internal_accept_proxy_protocol() const;
  void _internal_set_accept_proxy_protocol(bool value);

  public:
  // bool v6only = 14;
  void clear_v6only() ;
  bool v6only() const;
  void set_v6only(bool value);

  private:
  bool _internal_v6only() const;
  void _internal_set_v6only(bool value);

  public:
  // bool tcp_no_delay = 18;
  void clear_tcp_no_delay() ;
  bool tcp_no_delay() const;
  void set_tcp_no_delay(bool value);

  private:
  bool _internal_tcp_no_delay() const;
  void _internal_set_tcp_no_delay(bool value);

  public:
  // int32 tcp_keep_alive_idle = 11;
  void clear_tcp_keep_alive_idle() ;
  ::int32_t tcp_keep_alive_idle() const;
  void set_tcp_keep_alive_idle(::int32_t value);

  private:
  ::int32_t _internal_tcp_keep_alive_idle() const;
  void _internal_set_tcp_keep_alive_idle(::int32_t value);

  public:
  // int32 tcp_window_clamp = 15;
  void clear_tcp_window_clamp() ;
  ::int32_t tcp_window_clamp() const;
  void set_tcp_window_clamp(::int32_t value);

  private:
  ::int32_t _internal_tcp_window_clamp() const;
  void _internal_set_tcp_window_clamp(::int32_t value);

  public:
  // int32 tcp_user_timeout = 16;
  void clear_tcp_user_timeout() ;
  ::int32_t tcp_user_timeout() const;
  void set_tcp_user_timeout(::int32_t value);

  private:
  ::int32_t _internal_tcp_user_timeout() const;
  void _internal_set_tcp_user_timeout(::int32_t value);

  public:
  // int32 tcp_max_seg = 17;
  void clear_tcp_max_seg() ;
  ::int32_t tcp_max_seg() const;
  void set_tcp_max_seg(::int32_t value);

  private:
  ::int32_t _internal_tcp_max_seg() const;
  void _internal_set_tcp_max_seg(::int32_t value);

  public:
  // bool tcp_mptcp = 19;
  void clear_tcp_mptcp() ;
  bool tcp_mptcp() const;
  void set_tcp_mptcp(bool value);

  private:
  bool _internal_tcp_mptcp() const;
  void _internal_set_tcp_mptcp(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.SocketConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 0,
      96, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr bind_address_;
    ::google::protobuf::internal::ArenaStringPtr dialer_proxy_;
    ::google::protobuf::internal::ArenaStringPtr tcp_congestion_;
    ::google::protobuf::internal::ArenaStringPtr interface_;
    ::int32_t mark_;
    ::int32_t tfo_;
    int tproxy_;
    ::uint32_t bind_port_;
    int domain_strategy_;
    ::int32_t tcp_keep_alive_interval_;
    bool receive_original_dest_address_;
    bool accept_proxy_protocol_;
    bool v6only_;
    bool tcp_no_delay_;
    ::int32_t tcp_keep_alive_idle_;
    ::int32_t tcp_window_clamp_;
    ::int32_t tcp_user_timeout_;
    ::int32_t tcp_max_seg_;
    bool tcp_mptcp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fconfig_2eproto;
};// -------------------------------------------------------------------

class ProxyConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.ProxyConfig) */ {
 public:
  inline ProxyConfig() : ProxyConfig(nullptr) {}
  ~ProxyConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProxyConfig(::google::protobuf::internal::ConstantInitialized);

  inline ProxyConfig(const ProxyConfig& from)
      : ProxyConfig(nullptr, from) {}
  ProxyConfig(ProxyConfig&& from) noexcept
    : ProxyConfig() {
    *this = ::std::move(from);
  }

  inline ProxyConfig& operator=(const ProxyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProxyConfig& operator=(ProxyConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProxyConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProxyConfig* internal_default_instance() {
    return reinterpret_cast<const ProxyConfig*>(
               &_ProxyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProxyConfig& a, ProxyConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProxyConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProxyConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProxyConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProxyConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProxyConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProxyConfig& from) {
    ProxyConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProxyConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.ProxyConfig";
  }
  protected:
  explicit ProxyConfig(::google::protobuf::Arena* arena);
  ProxyConfig(::google::protobuf::Arena* arena, const ProxyConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kTransportLayerProxyFieldNumber = 2,
  };
  // string tag = 1;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // bool transportLayerProxy = 2;
  void clear_transportlayerproxy() ;
  bool transportlayerproxy() const;
  void set_transportlayerproxy(bool value);

  private:
  bool _internal_transportlayerproxy() const;
  void _internal_set_transportlayerproxy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.ProxyConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr tag_;
    bool transportlayerproxy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fconfig_2eproto;
};// -------------------------------------------------------------------

class TransportConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.TransportConfig) */ {
 public:
  inline TransportConfig() : TransportConfig(nullptr) {}
  ~TransportConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransportConfig(::google::protobuf::internal::ConstantInitialized);

  inline TransportConfig(const TransportConfig& from)
      : TransportConfig(nullptr, from) {}
  TransportConfig(TransportConfig&& from) noexcept
    : TransportConfig() {
    *this = ::std::move(from);
  }

  inline TransportConfig& operator=(const TransportConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransportConfig& operator=(TransportConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransportConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransportConfig* internal_default_instance() {
    return reinterpret_cast<const TransportConfig*>(
               &_TransportConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransportConfig& a, TransportConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TransportConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransportConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransportConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransportConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransportConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransportConfig& from) {
    TransportConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransportConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.TransportConfig";
  }
  protected:
  explicit TransportConfig(::google::protobuf::Arena* arena);
  TransportConfig(::google::protobuf::Arena* arena, const TransportConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolNameFieldNumber = 3,
    kSettingsFieldNumber = 2,
    kProtocolFieldNumber = 1,
  };
  // string protocol_name = 3;
  void clear_protocol_name() ;
  const std::string& protocol_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocol_name(Arg_&& arg, Args_... args);
  std::string* mutable_protocol_name();
  PROTOBUF_NODISCARD std::string* release_protocol_name();
  void set_allocated_protocol_name(std::string* value);

  private:
  const std::string& _internal_protocol_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_name(
      const std::string& value);
  std::string* _internal_mutable_protocol_name();

  public:
  // .xray.common.serial.TypedMessage settings = 2;
  bool has_settings() const;
  void clear_settings() ;
  const ::xray::common::serial::TypedMessage& settings() const;
  PROTOBUF_NODISCARD ::xray::common::serial::TypedMessage* release_settings();
  ::xray::common::serial::TypedMessage* mutable_settings();
  void set_allocated_settings(::xray::common::serial::TypedMessage* value);
  void unsafe_arena_set_allocated_settings(::xray::common::serial::TypedMessage* value);
  ::xray::common::serial::TypedMessage* unsafe_arena_release_settings();

  private:
  const ::xray::common::serial::TypedMessage& _internal_settings() const;
  ::xray::common::serial::TypedMessage* _internal_mutable_settings();

  public:
  // .xray.transport.internet.TransportProtocol protocol = 1 [deprecated = true];
  [[deprecated]]  void clear_protocol() ;
  [[deprecated]] ::xray::transport::internet::TransportProtocol protocol() const;
  [[deprecated]] void set_protocol(::xray::transport::internet::TransportProtocol value);

  private:
  ::xray::transport::internet::TransportProtocol _internal_protocol() const;
  void _internal_set_protocol(::xray::transport::internet::TransportProtocol value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.TransportConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr protocol_name_;
    ::xray::common::serial::TypedMessage* settings_;
    int protocol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fconfig_2eproto;
};// -------------------------------------------------------------------

class StreamConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.StreamConfig) */ {
 public:
  inline StreamConfig() : StreamConfig(nullptr) {}
  ~StreamConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamConfig(::google::protobuf::internal::ConstantInitialized);

  inline StreamConfig(const StreamConfig& from)
      : StreamConfig(nullptr, from) {}
  StreamConfig(StreamConfig&& from) noexcept
    : StreamConfig() {
    *this = ::std::move(from);
  }

  inline StreamConfig& operator=(const StreamConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamConfig& operator=(StreamConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamConfig* internal_default_instance() {
    return reinterpret_cast<const StreamConfig*>(
               &_StreamConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StreamConfig& a, StreamConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StreamConfig& from) {
    StreamConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreamConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.StreamConfig";
  }
  protected:
  explicit StreamConfig(::google::protobuf::Arena* arena);
  StreamConfig(::google::protobuf::Arena* arena, const StreamConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransportSettingsFieldNumber = 2,
    kSecuritySettingsFieldNumber = 4,
    kSecurityTypeFieldNumber = 3,
    kProtocolNameFieldNumber = 5,
    kSocketSettingsFieldNumber = 6,
    kProtocolFieldNumber = 1,
  };
  // repeated .xray.transport.internet.TransportConfig transport_settings = 2;
  int transport_settings_size() const;
  private:
  int _internal_transport_settings_size() const;

  public:
  void clear_transport_settings() ;
  ::xray::transport::internet::TransportConfig* mutable_transport_settings(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::transport::internet::TransportConfig >*
      mutable_transport_settings();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::transport::internet::TransportConfig>& _internal_transport_settings() const;
  ::google::protobuf::RepeatedPtrField<::xray::transport::internet::TransportConfig>* _internal_mutable_transport_settings();
  public:
  const ::xray::transport::internet::TransportConfig& transport_settings(int index) const;
  ::xray::transport::internet::TransportConfig* add_transport_settings();
  const ::google::protobuf::RepeatedPtrField< ::xray::transport::internet::TransportConfig >&
      transport_settings() const;
  // repeated .xray.common.serial.TypedMessage security_settings = 4;
  int security_settings_size() const;
  private:
  int _internal_security_settings_size() const;

  public:
  void clear_security_settings() ;
  ::xray::common::serial::TypedMessage* mutable_security_settings(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::common::serial::TypedMessage >*
      mutable_security_settings();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::common::serial::TypedMessage>& _internal_security_settings() const;
  ::google::protobuf::RepeatedPtrField<::xray::common::serial::TypedMessage>* _internal_mutable_security_settings();
  public:
  const ::xray::common::serial::TypedMessage& security_settings(int index) const;
  ::xray::common::serial::TypedMessage* add_security_settings();
  const ::google::protobuf::RepeatedPtrField< ::xray::common::serial::TypedMessage >&
      security_settings() const;
  // string security_type = 3;
  void clear_security_type() ;
  const std::string& security_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_security_type(Arg_&& arg, Args_... args);
  std::string* mutable_security_type();
  PROTOBUF_NODISCARD std::string* release_security_type();
  void set_allocated_security_type(std::string* value);

  private:
  const std::string& _internal_security_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_type(
      const std::string& value);
  std::string* _internal_mutable_security_type();

  public:
  // string protocol_name = 5;
  void clear_protocol_name() ;
  const std::string& protocol_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocol_name(Arg_&& arg, Args_... args);
  std::string* mutable_protocol_name();
  PROTOBUF_NODISCARD std::string* release_protocol_name();
  void set_allocated_protocol_name(std::string* value);

  private:
  const std::string& _internal_protocol_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_name(
      const std::string& value);
  std::string* _internal_mutable_protocol_name();

  public:
  // .xray.transport.internet.SocketConfig socket_settings = 6;
  bool has_socket_settings() const;
  void clear_socket_settings() ;
  const ::xray::transport::internet::SocketConfig& socket_settings() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::SocketConfig* release_socket_settings();
  ::xray::transport::internet::SocketConfig* mutable_socket_settings();
  void set_allocated_socket_settings(::xray::transport::internet::SocketConfig* value);
  void unsafe_arena_set_allocated_socket_settings(::xray::transport::internet::SocketConfig* value);
  ::xray::transport::internet::SocketConfig* unsafe_arena_release_socket_settings();

  private:
  const ::xray::transport::internet::SocketConfig& _internal_socket_settings() const;
  ::xray::transport::internet::SocketConfig* _internal_mutable_socket_settings();

  public:
  // .xray.transport.internet.TransportProtocol protocol = 1 [deprecated = true];
  [[deprecated]]  void clear_protocol() ;
  [[deprecated]] ::xray::transport::internet::TransportProtocol protocol() const;
  [[deprecated]] void set_protocol(::xray::transport::internet::TransportProtocol value);

  private:
  ::xray::transport::internet::TransportProtocol _internal_protocol() const;
  void _internal_set_protocol(::xray::transport::internet::TransportProtocol value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.StreamConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xray::transport::internet::TransportConfig > transport_settings_;
    ::google::protobuf::RepeatedPtrField< ::xray::common::serial::TypedMessage > security_settings_;
    ::google::protobuf::internal::ArenaStringPtr security_type_;
    ::google::protobuf::internal::ArenaStringPtr protocol_name_;
    ::xray::transport::internet::SocketConfig* socket_settings_;
    int protocol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TransportConfig

// .xray.transport.internet.TransportProtocol protocol = 1 [deprecated = true];
inline void TransportConfig::clear_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_ = 0;
}
inline ::xray::transport::internet::TransportProtocol TransportConfig::protocol() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.TransportConfig.protocol)
  return _internal_protocol();
}
inline void TransportConfig::set_protocol(::xray::transport::internet::TransportProtocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.TransportConfig.protocol)
}
inline ::xray::transport::internet::TransportProtocol TransportConfig::_internal_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::transport::internet::TransportProtocol>(_impl_.protocol_);
}
inline void TransportConfig::_internal_set_protocol(::xray::transport::internet::TransportProtocol value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_ = value;
}

// string protocol_name = 3;
inline void TransportConfig::clear_protocol_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_name_.ClearToEmpty();
}
inline const std::string& TransportConfig::protocol_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.TransportConfig.protocol_name)
  return _internal_protocol_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransportConfig::set_protocol_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.TransportConfig.protocol_name)
}
inline std::string* TransportConfig::mutable_protocol_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocol_name();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.TransportConfig.protocol_name)
  return _s;
}
inline const std::string& TransportConfig::_internal_protocol_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_name_.Get();
}
inline void TransportConfig::_internal_set_protocol_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_name_.Set(value, GetArena());
}
inline std::string* TransportConfig::_internal_mutable_protocol_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.protocol_name_.Mutable( GetArena());
}
inline std::string* TransportConfig::release_protocol_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.TransportConfig.protocol_name)
  return _impl_.protocol_name_.Release();
}
inline void TransportConfig::set_allocated_protocol_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.protocol_name_.IsDefault()) {
          _impl_.protocol_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.TransportConfig.protocol_name)
}

// .xray.common.serial.TypedMessage settings = 2;
inline bool TransportConfig::has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline const ::xray::common::serial::TypedMessage& TransportConfig::_internal_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::serial::TypedMessage* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::serial::TypedMessage&>(::xray::common::serial::_TypedMessage_default_instance_);
}
inline const ::xray::common::serial::TypedMessage& TransportConfig::settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.TransportConfig.settings)
  return _internal_settings();
}
inline void TransportConfig::unsafe_arena_set_allocated_settings(::xray::common::serial::TypedMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.TransportConfig.settings)
}
inline ::xray::common::serial::TypedMessage* TransportConfig::release_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::serial::TypedMessage* released = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::serial::TypedMessage* TransportConfig::unsafe_arena_release_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.TransportConfig.settings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::serial::TypedMessage* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::xray::common::serial::TypedMessage* TransportConfig::_internal_mutable_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::serial::TypedMessage>(GetArena());
    _impl_.settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(p);
  }
  return _impl_.settings_;
}
inline ::xray::common::serial::TypedMessage* TransportConfig::mutable_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::serial::TypedMessage* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.TransportConfig.settings)
  return _msg;
}
inline void TransportConfig::set_allocated_settings(::xray::common::serial::TypedMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.TransportConfig.settings)
}

// -------------------------------------------------------------------

// StreamConfig

// .xray.transport.internet.TransportProtocol protocol = 1 [deprecated = true];
inline void StreamConfig::clear_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_ = 0;
}
inline ::xray::transport::internet::TransportProtocol StreamConfig::protocol() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.StreamConfig.protocol)
  return _internal_protocol();
}
inline void StreamConfig::set_protocol(::xray::transport::internet::TransportProtocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.StreamConfig.protocol)
}
inline ::xray::transport::internet::TransportProtocol StreamConfig::_internal_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::transport::internet::TransportProtocol>(_impl_.protocol_);
}
inline void StreamConfig::_internal_set_protocol(::xray::transport::internet::TransportProtocol value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_ = value;
}

// string protocol_name = 5;
inline void StreamConfig::clear_protocol_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_name_.ClearToEmpty();
}
inline const std::string& StreamConfig::protocol_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.StreamConfig.protocol_name)
  return _internal_protocol_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamConfig::set_protocol_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.StreamConfig.protocol_name)
}
inline std::string* StreamConfig::mutable_protocol_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocol_name();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.StreamConfig.protocol_name)
  return _s;
}
inline const std::string& StreamConfig::_internal_protocol_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_name_.Get();
}
inline void StreamConfig::_internal_set_protocol_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_name_.Set(value, GetArena());
}
inline std::string* StreamConfig::_internal_mutable_protocol_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.protocol_name_.Mutable( GetArena());
}
inline std::string* StreamConfig::release_protocol_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.StreamConfig.protocol_name)
  return _impl_.protocol_name_.Release();
}
inline void StreamConfig::set_allocated_protocol_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.protocol_name_.IsDefault()) {
          _impl_.protocol_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.StreamConfig.protocol_name)
}

// repeated .xray.transport.internet.TransportConfig transport_settings = 2;
inline int StreamConfig::_internal_transport_settings_size() const {
  return _internal_transport_settings().size();
}
inline int StreamConfig::transport_settings_size() const {
  return _internal_transport_settings_size();
}
inline void StreamConfig::clear_transport_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transport_settings_.Clear();
}
inline ::xray::transport::internet::TransportConfig* StreamConfig::mutable_transport_settings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.StreamConfig.transport_settings)
  return _internal_mutable_transport_settings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::transport::internet::TransportConfig>* StreamConfig::mutable_transport_settings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.transport.internet.StreamConfig.transport_settings)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transport_settings();
}
inline const ::xray::transport::internet::TransportConfig& StreamConfig::transport_settings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.StreamConfig.transport_settings)
  return _internal_transport_settings().Get(index);
}
inline ::xray::transport::internet::TransportConfig* StreamConfig::add_transport_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::transport::internet::TransportConfig* _add = _internal_mutable_transport_settings()->Add();
  // @@protoc_insertion_point(field_add:xray.transport.internet.StreamConfig.transport_settings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::transport::internet::TransportConfig>& StreamConfig::transport_settings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.transport.internet.StreamConfig.transport_settings)
  return _internal_transport_settings();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::transport::internet::TransportConfig>&
StreamConfig::_internal_transport_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transport_settings_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::transport::internet::TransportConfig>*
StreamConfig::_internal_mutable_transport_settings() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transport_settings_;
}

// string security_type = 3;
inline void StreamConfig::clear_security_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.security_type_.ClearToEmpty();
}
inline const std::string& StreamConfig::security_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.StreamConfig.security_type)
  return _internal_security_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamConfig::set_security_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.security_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.StreamConfig.security_type)
}
inline std::string* StreamConfig::mutable_security_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_security_type();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.StreamConfig.security_type)
  return _s;
}
inline const std::string& StreamConfig::_internal_security_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.security_type_.Get();
}
inline void StreamConfig::_internal_set_security_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.security_type_.Set(value, GetArena());
}
inline std::string* StreamConfig::_internal_mutable_security_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.security_type_.Mutable( GetArena());
}
inline std::string* StreamConfig::release_security_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.StreamConfig.security_type)
  return _impl_.security_type_.Release();
}
inline void StreamConfig::set_allocated_security_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.security_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.security_type_.IsDefault()) {
          _impl_.security_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.StreamConfig.security_type)
}

// repeated .xray.common.serial.TypedMessage security_settings = 4;
inline int StreamConfig::_internal_security_settings_size() const {
  return _internal_security_settings().size();
}
inline int StreamConfig::security_settings_size() const {
  return _internal_security_settings_size();
}
inline ::xray::common::serial::TypedMessage* StreamConfig::mutable_security_settings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.StreamConfig.security_settings)
  return _internal_mutable_security_settings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::common::serial::TypedMessage>* StreamConfig::mutable_security_settings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.transport.internet.StreamConfig.security_settings)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_security_settings();
}
inline const ::xray::common::serial::TypedMessage& StreamConfig::security_settings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.StreamConfig.security_settings)
  return _internal_security_settings().Get(index);
}
inline ::xray::common::serial::TypedMessage* StreamConfig::add_security_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::common::serial::TypedMessage* _add = _internal_mutable_security_settings()->Add();
  // @@protoc_insertion_point(field_add:xray.transport.internet.StreamConfig.security_settings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::common::serial::TypedMessage>& StreamConfig::security_settings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.transport.internet.StreamConfig.security_settings)
  return _internal_security_settings();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::common::serial::TypedMessage>&
StreamConfig::_internal_security_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.security_settings_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::common::serial::TypedMessage>*
StreamConfig::_internal_mutable_security_settings() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.security_settings_;
}

// .xray.transport.internet.SocketConfig socket_settings = 6;
inline bool StreamConfig::has_socket_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.socket_settings_ != nullptr);
  return value;
}
inline void StreamConfig::clear_socket_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.socket_settings_ != nullptr) _impl_.socket_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xray::transport::internet::SocketConfig& StreamConfig::_internal_socket_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::SocketConfig* p = _impl_.socket_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::SocketConfig&>(::xray::transport::internet::_SocketConfig_default_instance_);
}
inline const ::xray::transport::internet::SocketConfig& StreamConfig::socket_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.StreamConfig.socket_settings)
  return _internal_socket_settings();
}
inline void StreamConfig::unsafe_arena_set_allocated_socket_settings(::xray::transport::internet::SocketConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.socket_settings_);
  }
  _impl_.socket_settings_ = reinterpret_cast<::xray::transport::internet::SocketConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.StreamConfig.socket_settings)
}
inline ::xray::transport::internet::SocketConfig* StreamConfig::release_socket_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::transport::internet::SocketConfig* released = _impl_.socket_settings_;
  _impl_.socket_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::SocketConfig* StreamConfig::unsafe_arena_release_socket_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.StreamConfig.socket_settings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::transport::internet::SocketConfig* temp = _impl_.socket_settings_;
  _impl_.socket_settings_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::SocketConfig* StreamConfig::_internal_mutable_socket_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.socket_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::SocketConfig>(GetArena());
    _impl_.socket_settings_ = reinterpret_cast<::xray::transport::internet::SocketConfig*>(p);
  }
  return _impl_.socket_settings_;
}
inline ::xray::transport::internet::SocketConfig* StreamConfig::mutable_socket_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::SocketConfig* _msg = _internal_mutable_socket_settings();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.StreamConfig.socket_settings)
  return _msg;
}
inline void StreamConfig::set_allocated_socket_settings(::xray::transport::internet::SocketConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::SocketConfig*>(_impl_.socket_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::SocketConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.socket_settings_ = reinterpret_cast<::xray::transport::internet::SocketConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.StreamConfig.socket_settings)
}

// -------------------------------------------------------------------

// ProxyConfig

// string tag = 1;
inline void ProxyConfig::clear_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& ProxyConfig::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.ProxyConfig.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProxyConfig::set_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.ProxyConfig.tag)
}
inline std::string* ProxyConfig::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.ProxyConfig.tag)
  return _s;
}
inline const std::string& ProxyConfig::_internal_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tag_.Get();
}
inline void ProxyConfig::_internal_set_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(value, GetArena());
}
inline std::string* ProxyConfig::_internal_mutable_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tag_.Mutable( GetArena());
}
inline std::string* ProxyConfig::release_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.ProxyConfig.tag)
  return _impl_.tag_.Release();
}
inline void ProxyConfig::set_allocated_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tag_.IsDefault()) {
          _impl_.tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.ProxyConfig.tag)
}

// bool transportLayerProxy = 2;
inline void ProxyConfig::clear_transportlayerproxy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transportlayerproxy_ = false;
}
inline bool ProxyConfig::transportlayerproxy() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.ProxyConfig.transportLayerProxy)
  return _internal_transportlayerproxy();
}
inline void ProxyConfig::set_transportlayerproxy(bool value) {
  _internal_set_transportlayerproxy(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.ProxyConfig.transportLayerProxy)
}
inline bool ProxyConfig::_internal_transportlayerproxy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transportlayerproxy_;
}
inline void ProxyConfig::_internal_set_transportlayerproxy(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transportlayerproxy_ = value;
}

// -------------------------------------------------------------------

// SocketConfig

// int32 mark = 1;
inline void SocketConfig::clear_mark() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mark_ = 0;
}
inline ::int32_t SocketConfig::mark() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.mark)
  return _internal_mark();
}
inline void SocketConfig::set_mark(::int32_t value) {
  _internal_set_mark(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.mark)
}
inline ::int32_t SocketConfig::_internal_mark() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mark_;
}
inline void SocketConfig::_internal_set_mark(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mark_ = value;
}

// int32 tfo = 2;
inline void SocketConfig::clear_tfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tfo_ = 0;
}
inline ::int32_t SocketConfig::tfo() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tfo)
  return _internal_tfo();
}
inline void SocketConfig::set_tfo(::int32_t value) {
  _internal_set_tfo(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tfo)
}
inline ::int32_t SocketConfig::_internal_tfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tfo_;
}
inline void SocketConfig::_internal_set_tfo(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tfo_ = value;
}

// .xray.transport.internet.SocketConfig.TProxyMode tproxy = 3;
inline void SocketConfig::clear_tproxy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tproxy_ = 0;
}
inline ::xray::transport::internet::SocketConfig_TProxyMode SocketConfig::tproxy() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tproxy)
  return _internal_tproxy();
}
inline void SocketConfig::set_tproxy(::xray::transport::internet::SocketConfig_TProxyMode value) {
  _internal_set_tproxy(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tproxy)
}
inline ::xray::transport::internet::SocketConfig_TProxyMode SocketConfig::_internal_tproxy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::transport::internet::SocketConfig_TProxyMode>(_impl_.tproxy_);
}
inline void SocketConfig::_internal_set_tproxy(::xray::transport::internet::SocketConfig_TProxyMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tproxy_ = value;
}

// bool receive_original_dest_address = 4;
inline void SocketConfig::clear_receive_original_dest_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receive_original_dest_address_ = false;
}
inline bool SocketConfig::receive_original_dest_address() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.receive_original_dest_address)
  return _internal_receive_original_dest_address();
}
inline void SocketConfig::set_receive_original_dest_address(bool value) {
  _internal_set_receive_original_dest_address(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.receive_original_dest_address)
}
inline bool SocketConfig::_internal_receive_original_dest_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.receive_original_dest_address_;
}
inline void SocketConfig::_internal_set_receive_original_dest_address(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.receive_original_dest_address_ = value;
}

// bytes bind_address = 5;
inline void SocketConfig::clear_bind_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bind_address_.ClearToEmpty();
}
inline const std::string& SocketConfig::bind_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.bind_address)
  return _internal_bind_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SocketConfig::set_bind_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bind_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.bind_address)
}
inline std::string* SocketConfig::mutable_bind_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bind_address();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.SocketConfig.bind_address)
  return _s;
}
inline const std::string& SocketConfig::_internal_bind_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bind_address_.Get();
}
inline void SocketConfig::_internal_set_bind_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bind_address_.Set(value, GetArena());
}
inline std::string* SocketConfig::_internal_mutable_bind_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.bind_address_.Mutable( GetArena());
}
inline std::string* SocketConfig::release_bind_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.SocketConfig.bind_address)
  return _impl_.bind_address_.Release();
}
inline void SocketConfig::set_allocated_bind_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bind_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bind_address_.IsDefault()) {
          _impl_.bind_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.SocketConfig.bind_address)
}

// uint32 bind_port = 6;
inline void SocketConfig::clear_bind_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bind_port_ = 0u;
}
inline ::uint32_t SocketConfig::bind_port() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.bind_port)
  return _internal_bind_port();
}
inline void SocketConfig::set_bind_port(::uint32_t value) {
  _internal_set_bind_port(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.bind_port)
}
inline ::uint32_t SocketConfig::_internal_bind_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bind_port_;
}
inline void SocketConfig::_internal_set_bind_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bind_port_ = value;
}

// bool accept_proxy_protocol = 7;
inline void SocketConfig::clear_accept_proxy_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accept_proxy_protocol_ = false;
}
inline bool SocketConfig::accept_proxy_protocol() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.accept_proxy_protocol)
  return _internal_accept_proxy_protocol();
}
inline void SocketConfig::set_accept_proxy_protocol(bool value) {
  _internal_set_accept_proxy_protocol(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.accept_proxy_protocol)
}
inline bool SocketConfig::_internal_accept_proxy_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accept_proxy_protocol_;
}
inline void SocketConfig::_internal_set_accept_proxy_protocol(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accept_proxy_protocol_ = value;
}

// .xray.transport.internet.DomainStrategy domain_strategy = 8;
inline void SocketConfig::clear_domain_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_strategy_ = 0;
}
inline ::xray::transport::internet::DomainStrategy SocketConfig::domain_strategy() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.domain_strategy)
  return _internal_domain_strategy();
}
inline void SocketConfig::set_domain_strategy(::xray::transport::internet::DomainStrategy value) {
  _internal_set_domain_strategy(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.domain_strategy)
}
inline ::xray::transport::internet::DomainStrategy SocketConfig::_internal_domain_strategy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::transport::internet::DomainStrategy>(_impl_.domain_strategy_);
}
inline void SocketConfig::_internal_set_domain_strategy(::xray::transport::internet::DomainStrategy value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_strategy_ = value;
}

// string dialer_proxy = 9;
inline void SocketConfig::clear_dialer_proxy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dialer_proxy_.ClearToEmpty();
}
inline const std::string& SocketConfig::dialer_proxy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.dialer_proxy)
  return _internal_dialer_proxy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SocketConfig::set_dialer_proxy(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dialer_proxy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.dialer_proxy)
}
inline std::string* SocketConfig::mutable_dialer_proxy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dialer_proxy();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.SocketConfig.dialer_proxy)
  return _s;
}
inline const std::string& SocketConfig::_internal_dialer_proxy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dialer_proxy_.Get();
}
inline void SocketConfig::_internal_set_dialer_proxy(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dialer_proxy_.Set(value, GetArena());
}
inline std::string* SocketConfig::_internal_mutable_dialer_proxy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dialer_proxy_.Mutable( GetArena());
}
inline std::string* SocketConfig::release_dialer_proxy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.SocketConfig.dialer_proxy)
  return _impl_.dialer_proxy_.Release();
}
inline void SocketConfig::set_allocated_dialer_proxy(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dialer_proxy_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dialer_proxy_.IsDefault()) {
          _impl_.dialer_proxy_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.SocketConfig.dialer_proxy)
}

// int32 tcp_keep_alive_interval = 10;
inline void SocketConfig::clear_tcp_keep_alive_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_keep_alive_interval_ = 0;
}
inline ::int32_t SocketConfig::tcp_keep_alive_interval() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_keep_alive_interval)
  return _internal_tcp_keep_alive_interval();
}
inline void SocketConfig::set_tcp_keep_alive_interval(::int32_t value) {
  _internal_set_tcp_keep_alive_interval(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_keep_alive_interval)
}
inline ::int32_t SocketConfig::_internal_tcp_keep_alive_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_keep_alive_interval_;
}
inline void SocketConfig::_internal_set_tcp_keep_alive_interval(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_keep_alive_interval_ = value;
}

// int32 tcp_keep_alive_idle = 11;
inline void SocketConfig::clear_tcp_keep_alive_idle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_keep_alive_idle_ = 0;
}
inline ::int32_t SocketConfig::tcp_keep_alive_idle() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_keep_alive_idle)
  return _internal_tcp_keep_alive_idle();
}
inline void SocketConfig::set_tcp_keep_alive_idle(::int32_t value) {
  _internal_set_tcp_keep_alive_idle(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_keep_alive_idle)
}
inline ::int32_t SocketConfig::_internal_tcp_keep_alive_idle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_keep_alive_idle_;
}
inline void SocketConfig::_internal_set_tcp_keep_alive_idle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_keep_alive_idle_ = value;
}

// string tcp_congestion = 12;
inline void SocketConfig::clear_tcp_congestion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_congestion_.ClearToEmpty();
}
inline const std::string& SocketConfig::tcp_congestion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_congestion)
  return _internal_tcp_congestion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SocketConfig::set_tcp_congestion(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_congestion_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_congestion)
}
inline std::string* SocketConfig::mutable_tcp_congestion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tcp_congestion();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.SocketConfig.tcp_congestion)
  return _s;
}
inline const std::string& SocketConfig::_internal_tcp_congestion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_congestion_.Get();
}
inline void SocketConfig::_internal_set_tcp_congestion(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_congestion_.Set(value, GetArena());
}
inline std::string* SocketConfig::_internal_mutable_tcp_congestion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tcp_congestion_.Mutable( GetArena());
}
inline std::string* SocketConfig::release_tcp_congestion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.SocketConfig.tcp_congestion)
  return _impl_.tcp_congestion_.Release();
}
inline void SocketConfig::set_allocated_tcp_congestion(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_congestion_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tcp_congestion_.IsDefault()) {
          _impl_.tcp_congestion_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.SocketConfig.tcp_congestion)
}

// string interface = 13;
inline void SocketConfig::clear_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_.ClearToEmpty();
}
inline const std::string& SocketConfig::interface() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.interface)
  return _internal_interface();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SocketConfig::set_interface(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interface_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.interface)
}
inline std::string* SocketConfig::mutable_interface() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.SocketConfig.interface)
  return _s;
}
inline const std::string& SocketConfig::_internal_interface() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interface_.Get();
}
inline void SocketConfig::_internal_set_interface(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interface_.Set(value, GetArena());
}
inline std::string* SocketConfig::_internal_mutable_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interface_.Mutable( GetArena());
}
inline std::string* SocketConfig::release_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.SocketConfig.interface)
  return _impl_.interface_.Release();
}
inline void SocketConfig::set_allocated_interface(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_.IsDefault()) {
          _impl_.interface_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.SocketConfig.interface)
}

// bool v6only = 14;
inline void SocketConfig::clear_v6only() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.v6only_ = false;
}
inline bool SocketConfig::v6only() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.v6only)
  return _internal_v6only();
}
inline void SocketConfig::set_v6only(bool value) {
  _internal_set_v6only(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.v6only)
}
inline bool SocketConfig::_internal_v6only() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.v6only_;
}
inline void SocketConfig::_internal_set_v6only(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.v6only_ = value;
}

// int32 tcp_window_clamp = 15;
inline void SocketConfig::clear_tcp_window_clamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_window_clamp_ = 0;
}
inline ::int32_t SocketConfig::tcp_window_clamp() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_window_clamp)
  return _internal_tcp_window_clamp();
}
inline void SocketConfig::set_tcp_window_clamp(::int32_t value) {
  _internal_set_tcp_window_clamp(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_window_clamp)
}
inline ::int32_t SocketConfig::_internal_tcp_window_clamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_window_clamp_;
}
inline void SocketConfig::_internal_set_tcp_window_clamp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_window_clamp_ = value;
}

// int32 tcp_user_timeout = 16;
inline void SocketConfig::clear_tcp_user_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_user_timeout_ = 0;
}
inline ::int32_t SocketConfig::tcp_user_timeout() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_user_timeout)
  return _internal_tcp_user_timeout();
}
inline void SocketConfig::set_tcp_user_timeout(::int32_t value) {
  _internal_set_tcp_user_timeout(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_user_timeout)
}
inline ::int32_t SocketConfig::_internal_tcp_user_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_user_timeout_;
}
inline void SocketConfig::_internal_set_tcp_user_timeout(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_user_timeout_ = value;
}

// int32 tcp_max_seg = 17;
inline void SocketConfig::clear_tcp_max_seg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_max_seg_ = 0;
}
inline ::int32_t SocketConfig::tcp_max_seg() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_max_seg)
  return _internal_tcp_max_seg();
}
inline void SocketConfig::set_tcp_max_seg(::int32_t value) {
  _internal_set_tcp_max_seg(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_max_seg)
}
inline ::int32_t SocketConfig::_internal_tcp_max_seg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_max_seg_;
}
inline void SocketConfig::_internal_set_tcp_max_seg(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_max_seg_ = value;
}

// bool tcp_no_delay = 18;
inline void SocketConfig::clear_tcp_no_delay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_no_delay_ = false;
}
inline bool SocketConfig::tcp_no_delay() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_no_delay)
  return _internal_tcp_no_delay();
}
inline void SocketConfig::set_tcp_no_delay(bool value) {
  _internal_set_tcp_no_delay(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_no_delay)
}
inline bool SocketConfig::_internal_tcp_no_delay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_no_delay_;
}
inline void SocketConfig::_internal_set_tcp_no_delay(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_no_delay_ = value;
}

// bool tcp_mptcp = 19;
inline void SocketConfig::clear_tcp_mptcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_mptcp_ = false;
}
inline bool SocketConfig::tcp_mptcp() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.SocketConfig.tcp_mptcp)
  return _internal_tcp_mptcp();
}
inline void SocketConfig::set_tcp_mptcp(bool value) {
  _internal_set_tcp_mptcp(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.SocketConfig.tcp_mptcp)
}
inline bool SocketConfig::_internal_tcp_mptcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_mptcp_;
}
inline void SocketConfig::_internal_set_tcp_mptcp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_mptcp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace internet
}  // namespace transport
}  // namespace xray


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::xray::transport::internet::SocketConfig_TProxyMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::transport::internet::SocketConfig_TProxyMode>() {
  return ::xray::transport::internet::SocketConfig_TProxyMode_descriptor();
}
template <>
struct is_proto_enum<::xray::transport::internet::TransportProtocol> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::transport::internet::TransportProtocol>() {
  return ::xray::transport::internet::TransportProtocol_descriptor();
}
template <>
struct is_proto_enum<::xray::transport::internet::DomainStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::transport::internet::DomainStrategy>() {
  return ::xray::transport::internet::DomainStrategy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2fconfig_2eproto_2epb_2eh
