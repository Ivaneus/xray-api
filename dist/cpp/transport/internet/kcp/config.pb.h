// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport/internet/kcp/config.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2fkcp_2fconfig_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2fkcp_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "common/serial/typed_message.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_transport_2finternet_2fkcp_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_transport_2finternet_2fkcp_2fconfig_2eproto;
namespace xray {
namespace transport {
namespace internet {
namespace kcp {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class ConnectionReuse;
struct ConnectionReuseDefaultTypeInternal;
extern ConnectionReuseDefaultTypeInternal _ConnectionReuse_default_instance_;
class DownlinkCapacity;
struct DownlinkCapacityDefaultTypeInternal;
extern DownlinkCapacityDefaultTypeInternal _DownlinkCapacity_default_instance_;
class EncryptionSeed;
struct EncryptionSeedDefaultTypeInternal;
extern EncryptionSeedDefaultTypeInternal _EncryptionSeed_default_instance_;
class MTU;
struct MTUDefaultTypeInternal;
extern MTUDefaultTypeInternal _MTU_default_instance_;
class ReadBuffer;
struct ReadBufferDefaultTypeInternal;
extern ReadBufferDefaultTypeInternal _ReadBuffer_default_instance_;
class TTI;
struct TTIDefaultTypeInternal;
extern TTIDefaultTypeInternal _TTI_default_instance_;
class UplinkCapacity;
struct UplinkCapacityDefaultTypeInternal;
extern UplinkCapacityDefaultTypeInternal _UplinkCapacity_default_instance_;
class WriteBuffer;
struct WriteBufferDefaultTypeInternal;
extern WriteBufferDefaultTypeInternal _WriteBuffer_default_instance_;
}  // namespace kcp
}  // namespace internet
}  // namespace transport
}  // namespace xray
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xray {
namespace transport {
namespace internet {
namespace kcp {

// ===================================================================


// -------------------------------------------------------------------

class WriteBuffer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.WriteBuffer) */ {
 public:
  inline WriteBuffer() : WriteBuffer(nullptr) {}
  ~WriteBuffer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WriteBuffer(::google::protobuf::internal::ConstantInitialized);

  inline WriteBuffer(const WriteBuffer& from)
      : WriteBuffer(nullptr, from) {}
  WriteBuffer(WriteBuffer&& from) noexcept
    : WriteBuffer() {
    *this = ::std::move(from);
  }

  inline WriteBuffer& operator=(const WriteBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteBuffer& operator=(WriteBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteBuffer* internal_default_instance() {
    return reinterpret_cast<const WriteBuffer*>(
               &_WriteBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WriteBuffer& a, WriteBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteBuffer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteBuffer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteBuffer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WriteBuffer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WriteBuffer& from) {
    WriteBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WriteBuffer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.WriteBuffer";
  }
  protected:
  explicit WriteBuffer(::google::protobuf::Arena* arena);
  WriteBuffer(::google::protobuf::Arena* arena, const WriteBuffer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // uint32 size = 1;
  void clear_size() ;
  ::uint32_t size() const;
  void set_size(::uint32_t value);

  private:
  ::uint32_t _internal_size() const;
  void _internal_set_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.WriteBuffer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class UplinkCapacity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.UplinkCapacity) */ {
 public:
  inline UplinkCapacity() : UplinkCapacity(nullptr) {}
  ~UplinkCapacity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UplinkCapacity(::google::protobuf::internal::ConstantInitialized);

  inline UplinkCapacity(const UplinkCapacity& from)
      : UplinkCapacity(nullptr, from) {}
  UplinkCapacity(UplinkCapacity&& from) noexcept
    : UplinkCapacity() {
    *this = ::std::move(from);
  }

  inline UplinkCapacity& operator=(const UplinkCapacity& from) {
    CopyFrom(from);
    return *this;
  }
  inline UplinkCapacity& operator=(UplinkCapacity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UplinkCapacity& default_instance() {
    return *internal_default_instance();
  }
  static inline const UplinkCapacity* internal_default_instance() {
    return reinterpret_cast<const UplinkCapacity*>(
               &_UplinkCapacity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UplinkCapacity& a, UplinkCapacity& b) {
    a.Swap(&b);
  }
  inline void Swap(UplinkCapacity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UplinkCapacity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UplinkCapacity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UplinkCapacity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UplinkCapacity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UplinkCapacity& from) {
    UplinkCapacity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UplinkCapacity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.UplinkCapacity";
  }
  protected:
  explicit UplinkCapacity(::google::protobuf::Arena* arena);
  UplinkCapacity(::google::protobuf::Arena* arena, const UplinkCapacity& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.UplinkCapacity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class TTI final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.TTI) */ {
 public:
  inline TTI() : TTI(nullptr) {}
  ~TTI() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TTI(::google::protobuf::internal::ConstantInitialized);

  inline TTI(const TTI& from)
      : TTI(nullptr, from) {}
  TTI(TTI&& from) noexcept
    : TTI() {
    *this = ::std::move(from);
  }

  inline TTI& operator=(const TTI& from) {
    CopyFrom(from);
    return *this;
  }
  inline TTI& operator=(TTI&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TTI& default_instance() {
    return *internal_default_instance();
  }
  static inline const TTI* internal_default_instance() {
    return reinterpret_cast<const TTI*>(
               &_TTI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TTI& a, TTI& b) {
    a.Swap(&b);
  }
  inline void Swap(TTI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TTI* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TTI* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TTI>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TTI& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TTI& from) {
    TTI::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TTI* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.TTI";
  }
  protected:
  explicit TTI(::google::protobuf::Arena* arena);
  TTI(::google::protobuf::Arena* arena, const TTI& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.TTI)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class ReadBuffer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.ReadBuffer) */ {
 public:
  inline ReadBuffer() : ReadBuffer(nullptr) {}
  ~ReadBuffer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReadBuffer(::google::protobuf::internal::ConstantInitialized);

  inline ReadBuffer(const ReadBuffer& from)
      : ReadBuffer(nullptr, from) {}
  ReadBuffer(ReadBuffer&& from) noexcept
    : ReadBuffer() {
    *this = ::std::move(from);
  }

  inline ReadBuffer& operator=(const ReadBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadBuffer& operator=(ReadBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadBuffer* internal_default_instance() {
    return reinterpret_cast<const ReadBuffer*>(
               &_ReadBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReadBuffer& a, ReadBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadBuffer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadBuffer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadBuffer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadBuffer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ReadBuffer& from) {
    ReadBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReadBuffer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.ReadBuffer";
  }
  protected:
  explicit ReadBuffer(::google::protobuf::Arena* arena);
  ReadBuffer(::google::protobuf::Arena* arena, const ReadBuffer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // uint32 size = 1;
  void clear_size() ;
  ::uint32_t size() const;
  void set_size(::uint32_t value);

  private:
  ::uint32_t _internal_size() const;
  void _internal_set_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.ReadBuffer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class MTU final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.MTU) */ {
 public:
  inline MTU() : MTU(nullptr) {}
  ~MTU() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MTU(::google::protobuf::internal::ConstantInitialized);

  inline MTU(const MTU& from)
      : MTU(nullptr, from) {}
  MTU(MTU&& from) noexcept
    : MTU() {
    *this = ::std::move(from);
  }

  inline MTU& operator=(const MTU& from) {
    CopyFrom(from);
    return *this;
  }
  inline MTU& operator=(MTU&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MTU& default_instance() {
    return *internal_default_instance();
  }
  static inline const MTU* internal_default_instance() {
    return reinterpret_cast<const MTU*>(
               &_MTU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MTU& a, MTU& b) {
    a.Swap(&b);
  }
  inline void Swap(MTU* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MTU* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MTU* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MTU>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MTU& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MTU& from) {
    MTU::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MTU* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.MTU";
  }
  protected:
  explicit MTU(::google::protobuf::Arena* arena);
  MTU(::google::protobuf::Arena* arena, const MTU& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.MTU)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class EncryptionSeed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.EncryptionSeed) */ {
 public:
  inline EncryptionSeed() : EncryptionSeed(nullptr) {}
  ~EncryptionSeed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EncryptionSeed(::google::protobuf::internal::ConstantInitialized);

  inline EncryptionSeed(const EncryptionSeed& from)
      : EncryptionSeed(nullptr, from) {}
  EncryptionSeed(EncryptionSeed&& from) noexcept
    : EncryptionSeed() {
    *this = ::std::move(from);
  }

  inline EncryptionSeed& operator=(const EncryptionSeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptionSeed& operator=(EncryptionSeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncryptionSeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptionSeed* internal_default_instance() {
    return reinterpret_cast<const EncryptionSeed*>(
               &_EncryptionSeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EncryptionSeed& a, EncryptionSeed& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptionSeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptionSeed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncryptionSeed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncryptionSeed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncryptionSeed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EncryptionSeed& from) {
    EncryptionSeed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EncryptionSeed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.EncryptionSeed";
  }
  protected:
  explicit EncryptionSeed(::google::protobuf::Arena* arena);
  EncryptionSeed(::google::protobuf::Arena* arena, const EncryptionSeed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedFieldNumber = 1,
  };
  // string seed = 1;
  void clear_seed() ;
  const std::string& seed() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_seed(Arg_&& arg, Args_... args);
  std::string* mutable_seed();
  PROTOBUF_NODISCARD std::string* release_seed();
  void set_allocated_seed(std::string* value);

  private:
  const std::string& _internal_seed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seed(
      const std::string& value);
  std::string* _internal_mutable_seed();

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.EncryptionSeed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr seed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class DownlinkCapacity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.DownlinkCapacity) */ {
 public:
  inline DownlinkCapacity() : DownlinkCapacity(nullptr) {}
  ~DownlinkCapacity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownlinkCapacity(::google::protobuf::internal::ConstantInitialized);

  inline DownlinkCapacity(const DownlinkCapacity& from)
      : DownlinkCapacity(nullptr, from) {}
  DownlinkCapacity(DownlinkCapacity&& from) noexcept
    : DownlinkCapacity() {
    *this = ::std::move(from);
  }

  inline DownlinkCapacity& operator=(const DownlinkCapacity& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownlinkCapacity& operator=(DownlinkCapacity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownlinkCapacity& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownlinkCapacity* internal_default_instance() {
    return reinterpret_cast<const DownlinkCapacity*>(
               &_DownlinkCapacity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownlinkCapacity& a, DownlinkCapacity& b) {
    a.Swap(&b);
  }
  inline void Swap(DownlinkCapacity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownlinkCapacity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownlinkCapacity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownlinkCapacity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownlinkCapacity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownlinkCapacity& from) {
    DownlinkCapacity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DownlinkCapacity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.DownlinkCapacity";
  }
  protected:
  explicit DownlinkCapacity(::google::protobuf::Arena* arena);
  DownlinkCapacity(::google::protobuf::Arena* arena, const DownlinkCapacity& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.DownlinkCapacity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class ConnectionReuse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.ConnectionReuse) */ {
 public:
  inline ConnectionReuse() : ConnectionReuse(nullptr) {}
  ~ConnectionReuse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectionReuse(::google::protobuf::internal::ConstantInitialized);

  inline ConnectionReuse(const ConnectionReuse& from)
      : ConnectionReuse(nullptr, from) {}
  ConnectionReuse(ConnectionReuse&& from) noexcept
    : ConnectionReuse() {
    *this = ::std::move(from);
  }

  inline ConnectionReuse& operator=(const ConnectionReuse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionReuse& operator=(ConnectionReuse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionReuse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionReuse* internal_default_instance() {
    return reinterpret_cast<const ConnectionReuse*>(
               &_ConnectionReuse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConnectionReuse& a, ConnectionReuse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionReuse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionReuse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionReuse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionReuse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectionReuse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConnectionReuse& from) {
    ConnectionReuse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectionReuse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.ConnectionReuse";
  }
  protected:
  explicit ConnectionReuse(::google::protobuf::Arena* arena);
  ConnectionReuse(::google::protobuf::Arena* arena, const ConnectionReuse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.ConnectionReuse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool enable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.transport.internet.kcp.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Config(::google::protobuf::internal::ConstantInitialized);

  inline Config(const Config& from)
      : Config(nullptr, from) {}
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.transport.internet.kcp.Config";
  }
  protected:
  explicit Config(::google::protobuf::Arena* arena);
  Config(::google::protobuf::Arena* arena, const Config& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMtuFieldNumber = 1,
    kTtiFieldNumber = 2,
    kUplinkCapacityFieldNumber = 3,
    kDownlinkCapacityFieldNumber = 4,
    kWriteBufferFieldNumber = 6,
    kReadBufferFieldNumber = 7,
    kHeaderConfigFieldNumber = 8,
    kSeedFieldNumber = 10,
    kCongestionFieldNumber = 5,
  };
  // .xray.transport.internet.kcp.MTU mtu = 1;
  bool has_mtu() const;
  void clear_mtu() ;
  const ::xray::transport::internet::kcp::MTU& mtu() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::kcp::MTU* release_mtu();
  ::xray::transport::internet::kcp::MTU* mutable_mtu();
  void set_allocated_mtu(::xray::transport::internet::kcp::MTU* value);
  void unsafe_arena_set_allocated_mtu(::xray::transport::internet::kcp::MTU* value);
  ::xray::transport::internet::kcp::MTU* unsafe_arena_release_mtu();

  private:
  const ::xray::transport::internet::kcp::MTU& _internal_mtu() const;
  ::xray::transport::internet::kcp::MTU* _internal_mutable_mtu();

  public:
  // .xray.transport.internet.kcp.TTI tti = 2;
  bool has_tti() const;
  void clear_tti() ;
  const ::xray::transport::internet::kcp::TTI& tti() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::kcp::TTI* release_tti();
  ::xray::transport::internet::kcp::TTI* mutable_tti();
  void set_allocated_tti(::xray::transport::internet::kcp::TTI* value);
  void unsafe_arena_set_allocated_tti(::xray::transport::internet::kcp::TTI* value);
  ::xray::transport::internet::kcp::TTI* unsafe_arena_release_tti();

  private:
  const ::xray::transport::internet::kcp::TTI& _internal_tti() const;
  ::xray::transport::internet::kcp::TTI* _internal_mutable_tti();

  public:
  // .xray.transport.internet.kcp.UplinkCapacity uplink_capacity = 3;
  bool has_uplink_capacity() const;
  void clear_uplink_capacity() ;
  const ::xray::transport::internet::kcp::UplinkCapacity& uplink_capacity() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::kcp::UplinkCapacity* release_uplink_capacity();
  ::xray::transport::internet::kcp::UplinkCapacity* mutable_uplink_capacity();
  void set_allocated_uplink_capacity(::xray::transport::internet::kcp::UplinkCapacity* value);
  void unsafe_arena_set_allocated_uplink_capacity(::xray::transport::internet::kcp::UplinkCapacity* value);
  ::xray::transport::internet::kcp::UplinkCapacity* unsafe_arena_release_uplink_capacity();

  private:
  const ::xray::transport::internet::kcp::UplinkCapacity& _internal_uplink_capacity() const;
  ::xray::transport::internet::kcp::UplinkCapacity* _internal_mutable_uplink_capacity();

  public:
  // .xray.transport.internet.kcp.DownlinkCapacity downlink_capacity = 4;
  bool has_downlink_capacity() const;
  void clear_downlink_capacity() ;
  const ::xray::transport::internet::kcp::DownlinkCapacity& downlink_capacity() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::kcp::DownlinkCapacity* release_downlink_capacity();
  ::xray::transport::internet::kcp::DownlinkCapacity* mutable_downlink_capacity();
  void set_allocated_downlink_capacity(::xray::transport::internet::kcp::DownlinkCapacity* value);
  void unsafe_arena_set_allocated_downlink_capacity(::xray::transport::internet::kcp::DownlinkCapacity* value);
  ::xray::transport::internet::kcp::DownlinkCapacity* unsafe_arena_release_downlink_capacity();

  private:
  const ::xray::transport::internet::kcp::DownlinkCapacity& _internal_downlink_capacity() const;
  ::xray::transport::internet::kcp::DownlinkCapacity* _internal_mutable_downlink_capacity();

  public:
  // .xray.transport.internet.kcp.WriteBuffer write_buffer = 6;
  bool has_write_buffer() const;
  void clear_write_buffer() ;
  const ::xray::transport::internet::kcp::WriteBuffer& write_buffer() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::kcp::WriteBuffer* release_write_buffer();
  ::xray::transport::internet::kcp::WriteBuffer* mutable_write_buffer();
  void set_allocated_write_buffer(::xray::transport::internet::kcp::WriteBuffer* value);
  void unsafe_arena_set_allocated_write_buffer(::xray::transport::internet::kcp::WriteBuffer* value);
  ::xray::transport::internet::kcp::WriteBuffer* unsafe_arena_release_write_buffer();

  private:
  const ::xray::transport::internet::kcp::WriteBuffer& _internal_write_buffer() const;
  ::xray::transport::internet::kcp::WriteBuffer* _internal_mutable_write_buffer();

  public:
  // .xray.transport.internet.kcp.ReadBuffer read_buffer = 7;
  bool has_read_buffer() const;
  void clear_read_buffer() ;
  const ::xray::transport::internet::kcp::ReadBuffer& read_buffer() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::kcp::ReadBuffer* release_read_buffer();
  ::xray::transport::internet::kcp::ReadBuffer* mutable_read_buffer();
  void set_allocated_read_buffer(::xray::transport::internet::kcp::ReadBuffer* value);
  void unsafe_arena_set_allocated_read_buffer(::xray::transport::internet::kcp::ReadBuffer* value);
  ::xray::transport::internet::kcp::ReadBuffer* unsafe_arena_release_read_buffer();

  private:
  const ::xray::transport::internet::kcp::ReadBuffer& _internal_read_buffer() const;
  ::xray::transport::internet::kcp::ReadBuffer* _internal_mutable_read_buffer();

  public:
  // .xray.common.serial.TypedMessage header_config = 8;
  bool has_header_config() const;
  void clear_header_config() ;
  const ::xray::common::serial::TypedMessage& header_config() const;
  PROTOBUF_NODISCARD ::xray::common::serial::TypedMessage* release_header_config();
  ::xray::common::serial::TypedMessage* mutable_header_config();
  void set_allocated_header_config(::xray::common::serial::TypedMessage* value);
  void unsafe_arena_set_allocated_header_config(::xray::common::serial::TypedMessage* value);
  ::xray::common::serial::TypedMessage* unsafe_arena_release_header_config();

  private:
  const ::xray::common::serial::TypedMessage& _internal_header_config() const;
  ::xray::common::serial::TypedMessage* _internal_mutable_header_config();

  public:
  // .xray.transport.internet.kcp.EncryptionSeed seed = 10;
  bool has_seed() const;
  void clear_seed() ;
  const ::xray::transport::internet::kcp::EncryptionSeed& seed() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::kcp::EncryptionSeed* release_seed();
  ::xray::transport::internet::kcp::EncryptionSeed* mutable_seed();
  void set_allocated_seed(::xray::transport::internet::kcp::EncryptionSeed* value);
  void unsafe_arena_set_allocated_seed(::xray::transport::internet::kcp::EncryptionSeed* value);
  ::xray::transport::internet::kcp::EncryptionSeed* unsafe_arena_release_seed();

  private:
  const ::xray::transport::internet::kcp::EncryptionSeed& _internal_seed() const;
  ::xray::transport::internet::kcp::EncryptionSeed* _internal_mutable_seed();

  public:
  // bool congestion = 5;
  void clear_congestion() ;
  bool congestion() const;
  void set_congestion(bool value);

  private:
  bool _internal_congestion() const;
  void _internal_set_congestion(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.transport.internet.kcp.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xray::transport::internet::kcp::MTU* mtu_;
    ::xray::transport::internet::kcp::TTI* tti_;
    ::xray::transport::internet::kcp::UplinkCapacity* uplink_capacity_;
    ::xray::transport::internet::kcp::DownlinkCapacity* downlink_capacity_;
    ::xray::transport::internet::kcp::WriteBuffer* write_buffer_;
    ::xray::transport::internet::kcp::ReadBuffer* read_buffer_;
    ::xray::common::serial::TypedMessage* header_config_;
    ::xray::transport::internet::kcp::EncryptionSeed* seed_;
    bool congestion_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2finternet_2fkcp_2fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MTU

// uint32 value = 1;
inline void MTU::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
}
inline ::uint32_t MTU::value() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.MTU.value)
  return _internal_value();
}
inline void MTU::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.MTU.value)
}
inline ::uint32_t MTU::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void MTU::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// TTI

// uint32 value = 1;
inline void TTI::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
}
inline ::uint32_t TTI::value() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.TTI.value)
  return _internal_value();
}
inline void TTI::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.TTI.value)
}
inline ::uint32_t TTI::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void TTI::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// UplinkCapacity

// uint32 value = 1;
inline void UplinkCapacity::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
}
inline ::uint32_t UplinkCapacity::value() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.UplinkCapacity.value)
  return _internal_value();
}
inline void UplinkCapacity::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.UplinkCapacity.value)
}
inline ::uint32_t UplinkCapacity::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void UplinkCapacity::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// DownlinkCapacity

// uint32 value = 1;
inline void DownlinkCapacity::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
}
inline ::uint32_t DownlinkCapacity::value() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.DownlinkCapacity.value)
  return _internal_value();
}
inline void DownlinkCapacity::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.DownlinkCapacity.value)
}
inline ::uint32_t DownlinkCapacity::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void DownlinkCapacity::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// WriteBuffer

// uint32 size = 1;
inline void WriteBuffer::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = 0u;
}
inline ::uint32_t WriteBuffer::size() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.WriteBuffer.size)
  return _internal_size();
}
inline void WriteBuffer::set_size(::uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.WriteBuffer.size)
}
inline ::uint32_t WriteBuffer::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void WriteBuffer::_internal_set_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// ReadBuffer

// uint32 size = 1;
inline void ReadBuffer::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = 0u;
}
inline ::uint32_t ReadBuffer::size() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.ReadBuffer.size)
  return _internal_size();
}
inline void ReadBuffer::set_size(::uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.ReadBuffer.size)
}
inline ::uint32_t ReadBuffer::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void ReadBuffer::_internal_set_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// ConnectionReuse

// bool enable = 1;
inline void ConnectionReuse::clear_enable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_ = false;
}
inline bool ConnectionReuse::enable() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.ConnectionReuse.enable)
  return _internal_enable();
}
inline void ConnectionReuse::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.ConnectionReuse.enable)
}
inline bool ConnectionReuse::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void ConnectionReuse::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// EncryptionSeed

// string seed = 1;
inline void EncryptionSeed::clear_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seed_.ClearToEmpty();
}
inline const std::string& EncryptionSeed::seed() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.EncryptionSeed.seed)
  return _internal_seed();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptionSeed::set_seed(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seed_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.EncryptionSeed.seed)
}
inline std::string* EncryptionSeed::mutable_seed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_seed();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.EncryptionSeed.seed)
  return _s;
}
inline const std::string& EncryptionSeed::_internal_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seed_.Get();
}
inline void EncryptionSeed::_internal_set_seed(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seed_.Set(value, GetArena());
}
inline std::string* EncryptionSeed::_internal_mutable_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.seed_.Mutable( GetArena());
}
inline std::string* EncryptionSeed::release_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.EncryptionSeed.seed)
  return _impl_.seed_.Release();
}
inline void EncryptionSeed::set_allocated_seed(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seed_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.seed_.IsDefault()) {
          _impl_.seed_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.EncryptionSeed.seed)
}

// -------------------------------------------------------------------

// Config

// .xray.transport.internet.kcp.MTU mtu = 1;
inline bool Config::has_mtu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mtu_ != nullptr);
  return value;
}
inline void Config::clear_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.mtu_ != nullptr) _impl_.mtu_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xray::transport::internet::kcp::MTU& Config::_internal_mtu() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::kcp::MTU* p = _impl_.mtu_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::kcp::MTU&>(::xray::transport::internet::kcp::_MTU_default_instance_);
}
inline const ::xray::transport::internet::kcp::MTU& Config::mtu() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.mtu)
  return _internal_mtu();
}
inline void Config::unsafe_arena_set_allocated_mtu(::xray::transport::internet::kcp::MTU* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mtu_);
  }
  _impl_.mtu_ = reinterpret_cast<::xray::transport::internet::kcp::MTU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.mtu)
}
inline ::xray::transport::internet::kcp::MTU* Config::release_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::transport::internet::kcp::MTU* released = _impl_.mtu_;
  _impl_.mtu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::kcp::MTU* Config::unsafe_arena_release_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.mtu)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::transport::internet::kcp::MTU* temp = _impl_.mtu_;
  _impl_.mtu_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::kcp::MTU* Config::_internal_mutable_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.mtu_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::kcp::MTU>(GetArena());
    _impl_.mtu_ = reinterpret_cast<::xray::transport::internet::kcp::MTU*>(p);
  }
  return _impl_.mtu_;
}
inline ::xray::transport::internet::kcp::MTU* Config::mutable_mtu() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::kcp::MTU* _msg = _internal_mutable_mtu();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.mtu)
  return _msg;
}
inline void Config::set_allocated_mtu(::xray::transport::internet::kcp::MTU* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::kcp::MTU*>(_impl_.mtu_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::kcp::MTU*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mtu_ = reinterpret_cast<::xray::transport::internet::kcp::MTU*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.mtu)
}

// .xray.transport.internet.kcp.TTI tti = 2;
inline bool Config::has_tti() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tti_ != nullptr);
  return value;
}
inline void Config::clear_tti() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tti_ != nullptr) _impl_.tti_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xray::transport::internet::kcp::TTI& Config::_internal_tti() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::kcp::TTI* p = _impl_.tti_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::kcp::TTI&>(::xray::transport::internet::kcp::_TTI_default_instance_);
}
inline const ::xray::transport::internet::kcp::TTI& Config::tti() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.tti)
  return _internal_tti();
}
inline void Config::unsafe_arena_set_allocated_tti(::xray::transport::internet::kcp::TTI* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tti_);
  }
  _impl_.tti_ = reinterpret_cast<::xray::transport::internet::kcp::TTI*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.tti)
}
inline ::xray::transport::internet::kcp::TTI* Config::release_tti() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::transport::internet::kcp::TTI* released = _impl_.tti_;
  _impl_.tti_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::kcp::TTI* Config::unsafe_arena_release_tti() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.tti)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::transport::internet::kcp::TTI* temp = _impl_.tti_;
  _impl_.tti_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::kcp::TTI* Config::_internal_mutable_tti() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tti_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::kcp::TTI>(GetArena());
    _impl_.tti_ = reinterpret_cast<::xray::transport::internet::kcp::TTI*>(p);
  }
  return _impl_.tti_;
}
inline ::xray::transport::internet::kcp::TTI* Config::mutable_tti() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::kcp::TTI* _msg = _internal_mutable_tti();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.tti)
  return _msg;
}
inline void Config::set_allocated_tti(::xray::transport::internet::kcp::TTI* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::kcp::TTI*>(_impl_.tti_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::kcp::TTI*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.tti_ = reinterpret_cast<::xray::transport::internet::kcp::TTI*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.tti)
}

// .xray.transport.internet.kcp.UplinkCapacity uplink_capacity = 3;
inline bool Config::has_uplink_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uplink_capacity_ != nullptr);
  return value;
}
inline void Config::clear_uplink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.uplink_capacity_ != nullptr) _impl_.uplink_capacity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xray::transport::internet::kcp::UplinkCapacity& Config::_internal_uplink_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::kcp::UplinkCapacity* p = _impl_.uplink_capacity_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::kcp::UplinkCapacity&>(::xray::transport::internet::kcp::_UplinkCapacity_default_instance_);
}
inline const ::xray::transport::internet::kcp::UplinkCapacity& Config::uplink_capacity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.uplink_capacity)
  return _internal_uplink_capacity();
}
inline void Config::unsafe_arena_set_allocated_uplink_capacity(::xray::transport::internet::kcp::UplinkCapacity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.uplink_capacity_);
  }
  _impl_.uplink_capacity_ = reinterpret_cast<::xray::transport::internet::kcp::UplinkCapacity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.uplink_capacity)
}
inline ::xray::transport::internet::kcp::UplinkCapacity* Config::release_uplink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::transport::internet::kcp::UplinkCapacity* released = _impl_.uplink_capacity_;
  _impl_.uplink_capacity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::kcp::UplinkCapacity* Config::unsafe_arena_release_uplink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.uplink_capacity)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::transport::internet::kcp::UplinkCapacity* temp = _impl_.uplink_capacity_;
  _impl_.uplink_capacity_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::kcp::UplinkCapacity* Config::_internal_mutable_uplink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.uplink_capacity_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::kcp::UplinkCapacity>(GetArena());
    _impl_.uplink_capacity_ = reinterpret_cast<::xray::transport::internet::kcp::UplinkCapacity*>(p);
  }
  return _impl_.uplink_capacity_;
}
inline ::xray::transport::internet::kcp::UplinkCapacity* Config::mutable_uplink_capacity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::kcp::UplinkCapacity* _msg = _internal_mutable_uplink_capacity();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.uplink_capacity)
  return _msg;
}
inline void Config::set_allocated_uplink_capacity(::xray::transport::internet::kcp::UplinkCapacity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::kcp::UplinkCapacity*>(_impl_.uplink_capacity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::kcp::UplinkCapacity*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.uplink_capacity_ = reinterpret_cast<::xray::transport::internet::kcp::UplinkCapacity*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.uplink_capacity)
}

// .xray.transport.internet.kcp.DownlinkCapacity downlink_capacity = 4;
inline bool Config::has_downlink_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.downlink_capacity_ != nullptr);
  return value;
}
inline void Config::clear_downlink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.downlink_capacity_ != nullptr) _impl_.downlink_capacity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::xray::transport::internet::kcp::DownlinkCapacity& Config::_internal_downlink_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::kcp::DownlinkCapacity* p = _impl_.downlink_capacity_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::kcp::DownlinkCapacity&>(::xray::transport::internet::kcp::_DownlinkCapacity_default_instance_);
}
inline const ::xray::transport::internet::kcp::DownlinkCapacity& Config::downlink_capacity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.downlink_capacity)
  return _internal_downlink_capacity();
}
inline void Config::unsafe_arena_set_allocated_downlink_capacity(::xray::transport::internet::kcp::DownlinkCapacity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.downlink_capacity_);
  }
  _impl_.downlink_capacity_ = reinterpret_cast<::xray::transport::internet::kcp::DownlinkCapacity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.downlink_capacity)
}
inline ::xray::transport::internet::kcp::DownlinkCapacity* Config::release_downlink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::transport::internet::kcp::DownlinkCapacity* released = _impl_.downlink_capacity_;
  _impl_.downlink_capacity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::kcp::DownlinkCapacity* Config::unsafe_arena_release_downlink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.downlink_capacity)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::transport::internet::kcp::DownlinkCapacity* temp = _impl_.downlink_capacity_;
  _impl_.downlink_capacity_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::kcp::DownlinkCapacity* Config::_internal_mutable_downlink_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.downlink_capacity_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::kcp::DownlinkCapacity>(GetArena());
    _impl_.downlink_capacity_ = reinterpret_cast<::xray::transport::internet::kcp::DownlinkCapacity*>(p);
  }
  return _impl_.downlink_capacity_;
}
inline ::xray::transport::internet::kcp::DownlinkCapacity* Config::mutable_downlink_capacity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::kcp::DownlinkCapacity* _msg = _internal_mutable_downlink_capacity();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.downlink_capacity)
  return _msg;
}
inline void Config::set_allocated_downlink_capacity(::xray::transport::internet::kcp::DownlinkCapacity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::kcp::DownlinkCapacity*>(_impl_.downlink_capacity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::kcp::DownlinkCapacity*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.downlink_capacity_ = reinterpret_cast<::xray::transport::internet::kcp::DownlinkCapacity*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.downlink_capacity)
}

// bool congestion = 5;
inline void Config::clear_congestion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.congestion_ = false;
}
inline bool Config::congestion() const {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.congestion)
  return _internal_congestion();
}
inline void Config::set_congestion(bool value) {
  _internal_set_congestion(value);
  // @@protoc_insertion_point(field_set:xray.transport.internet.kcp.Config.congestion)
}
inline bool Config::_internal_congestion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.congestion_;
}
inline void Config::_internal_set_congestion(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.congestion_ = value;
}

// .xray.transport.internet.kcp.WriteBuffer write_buffer = 6;
inline bool Config::has_write_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.write_buffer_ != nullptr);
  return value;
}
inline void Config::clear_write_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.write_buffer_ != nullptr) _impl_.write_buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::xray::transport::internet::kcp::WriteBuffer& Config::_internal_write_buffer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::kcp::WriteBuffer* p = _impl_.write_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::kcp::WriteBuffer&>(::xray::transport::internet::kcp::_WriteBuffer_default_instance_);
}
inline const ::xray::transport::internet::kcp::WriteBuffer& Config::write_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.write_buffer)
  return _internal_write_buffer();
}
inline void Config::unsafe_arena_set_allocated_write_buffer(::xray::transport::internet::kcp::WriteBuffer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.write_buffer_);
  }
  _impl_.write_buffer_ = reinterpret_cast<::xray::transport::internet::kcp::WriteBuffer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.write_buffer)
}
inline ::xray::transport::internet::kcp::WriteBuffer* Config::release_write_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xray::transport::internet::kcp::WriteBuffer* released = _impl_.write_buffer_;
  _impl_.write_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::kcp::WriteBuffer* Config::unsafe_arena_release_write_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.write_buffer)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xray::transport::internet::kcp::WriteBuffer* temp = _impl_.write_buffer_;
  _impl_.write_buffer_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::kcp::WriteBuffer* Config::_internal_mutable_write_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.write_buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::kcp::WriteBuffer>(GetArena());
    _impl_.write_buffer_ = reinterpret_cast<::xray::transport::internet::kcp::WriteBuffer*>(p);
  }
  return _impl_.write_buffer_;
}
inline ::xray::transport::internet::kcp::WriteBuffer* Config::mutable_write_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::kcp::WriteBuffer* _msg = _internal_mutable_write_buffer();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.write_buffer)
  return _msg;
}
inline void Config::set_allocated_write_buffer(::xray::transport::internet::kcp::WriteBuffer* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::kcp::WriteBuffer*>(_impl_.write_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::kcp::WriteBuffer*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.write_buffer_ = reinterpret_cast<::xray::transport::internet::kcp::WriteBuffer*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.write_buffer)
}

// .xray.transport.internet.kcp.ReadBuffer read_buffer = 7;
inline bool Config::has_read_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.read_buffer_ != nullptr);
  return value;
}
inline void Config::clear_read_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.read_buffer_ != nullptr) _impl_.read_buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::xray::transport::internet::kcp::ReadBuffer& Config::_internal_read_buffer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::kcp::ReadBuffer* p = _impl_.read_buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::kcp::ReadBuffer&>(::xray::transport::internet::kcp::_ReadBuffer_default_instance_);
}
inline const ::xray::transport::internet::kcp::ReadBuffer& Config::read_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.read_buffer)
  return _internal_read_buffer();
}
inline void Config::unsafe_arena_set_allocated_read_buffer(::xray::transport::internet::kcp::ReadBuffer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_buffer_);
  }
  _impl_.read_buffer_ = reinterpret_cast<::xray::transport::internet::kcp::ReadBuffer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.read_buffer)
}
inline ::xray::transport::internet::kcp::ReadBuffer* Config::release_read_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::xray::transport::internet::kcp::ReadBuffer* released = _impl_.read_buffer_;
  _impl_.read_buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::kcp::ReadBuffer* Config::unsafe_arena_release_read_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.read_buffer)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::xray::transport::internet::kcp::ReadBuffer* temp = _impl_.read_buffer_;
  _impl_.read_buffer_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::kcp::ReadBuffer* Config::_internal_mutable_read_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.read_buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::kcp::ReadBuffer>(GetArena());
    _impl_.read_buffer_ = reinterpret_cast<::xray::transport::internet::kcp::ReadBuffer*>(p);
  }
  return _impl_.read_buffer_;
}
inline ::xray::transport::internet::kcp::ReadBuffer* Config::mutable_read_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::kcp::ReadBuffer* _msg = _internal_mutable_read_buffer();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.read_buffer)
  return _msg;
}
inline void Config::set_allocated_read_buffer(::xray::transport::internet::kcp::ReadBuffer* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::kcp::ReadBuffer*>(_impl_.read_buffer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::kcp::ReadBuffer*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.read_buffer_ = reinterpret_cast<::xray::transport::internet::kcp::ReadBuffer*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.read_buffer)
}

// .xray.common.serial.TypedMessage header_config = 8;
inline bool Config::has_header_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_config_ != nullptr);
  return value;
}
inline const ::xray::common::serial::TypedMessage& Config::_internal_header_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::serial::TypedMessage* p = _impl_.header_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::serial::TypedMessage&>(::xray::common::serial::_TypedMessage_default_instance_);
}
inline const ::xray::common::serial::TypedMessage& Config::header_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.header_config)
  return _internal_header_config();
}
inline void Config::unsafe_arena_set_allocated_header_config(::xray::common::serial::TypedMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_config_);
  }
  _impl_.header_config_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.header_config)
}
inline ::xray::common::serial::TypedMessage* Config::release_header_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::xray::common::serial::TypedMessage* released = _impl_.header_config_;
  _impl_.header_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::serial::TypedMessage* Config::unsafe_arena_release_header_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.header_config)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::xray::common::serial::TypedMessage* temp = _impl_.header_config_;
  _impl_.header_config_ = nullptr;
  return temp;
}
inline ::xray::common::serial::TypedMessage* Config::_internal_mutable_header_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.header_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::serial::TypedMessage>(GetArena());
    _impl_.header_config_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(p);
  }
  return _impl_.header_config_;
}
inline ::xray::common::serial::TypedMessage* Config::mutable_header_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::serial::TypedMessage* _msg = _internal_mutable_header_config();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.header_config)
  return _msg;
}
inline void Config::set_allocated_header_config(::xray::common::serial::TypedMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.header_config_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.header_config)
}

// .xray.transport.internet.kcp.EncryptionSeed seed = 10;
inline bool Config::has_seed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seed_ != nullptr);
  return value;
}
inline void Config::clear_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seed_ != nullptr) _impl_.seed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::xray::transport::internet::kcp::EncryptionSeed& Config::_internal_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::kcp::EncryptionSeed* p = _impl_.seed_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::kcp::EncryptionSeed&>(::xray::transport::internet::kcp::_EncryptionSeed_default_instance_);
}
inline const ::xray::transport::internet::kcp::EncryptionSeed& Config::seed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.transport.internet.kcp.Config.seed)
  return _internal_seed();
}
inline void Config::unsafe_arena_set_allocated_seed(::xray::transport::internet::kcp::EncryptionSeed* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seed_);
  }
  _impl_.seed_ = reinterpret_cast<::xray::transport::internet::kcp::EncryptionSeed*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.transport.internet.kcp.Config.seed)
}
inline ::xray::transport::internet::kcp::EncryptionSeed* Config::release_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::xray::transport::internet::kcp::EncryptionSeed* released = _impl_.seed_;
  _impl_.seed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::kcp::EncryptionSeed* Config::unsafe_arena_release_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.transport.internet.kcp.Config.seed)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::xray::transport::internet::kcp::EncryptionSeed* temp = _impl_.seed_;
  _impl_.seed_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::kcp::EncryptionSeed* Config::_internal_mutable_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.seed_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::kcp::EncryptionSeed>(GetArena());
    _impl_.seed_ = reinterpret_cast<::xray::transport::internet::kcp::EncryptionSeed*>(p);
  }
  return _impl_.seed_;
}
inline ::xray::transport::internet::kcp::EncryptionSeed* Config::mutable_seed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::kcp::EncryptionSeed* _msg = _internal_mutable_seed();
  // @@protoc_insertion_point(field_mutable:xray.transport.internet.kcp.Config.seed)
  return _msg;
}
inline void Config::set_allocated_seed(::xray::transport::internet::kcp::EncryptionSeed* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::transport::internet::kcp::EncryptionSeed*>(_impl_.seed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::transport::internet::kcp::EncryptionSeed*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.seed_ = reinterpret_cast<::xray::transport::internet::kcp::EncryptionSeed*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.transport.internet.kcp.Config.seed)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace kcp
}  // namespace internet
}  // namespace transport
}  // namespace xray


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_transport_2finternet_2fkcp_2fconfig_2eproto_2epb_2eh
