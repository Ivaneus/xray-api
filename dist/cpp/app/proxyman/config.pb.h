// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/proxyman/config.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fproxyman_2fconfig_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_app_2fproxyman_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common/net/address.pb.h"
#include "common/net/port.pb.h"
#include "transport/internet/config.pb.h"
#include "common/serial/typed_message.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_app_2fproxyman_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fproxyman_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_app_2fproxyman_2fconfig_2eproto;
namespace xray {
namespace app {
namespace proxyman {
class AllocationStrategy;
struct AllocationStrategyDefaultTypeInternal;
extern AllocationStrategyDefaultTypeInternal _AllocationStrategy_default_instance_;
class AllocationStrategy_AllocationStrategyConcurrency;
struct AllocationStrategy_AllocationStrategyConcurrencyDefaultTypeInternal;
extern AllocationStrategy_AllocationStrategyConcurrencyDefaultTypeInternal _AllocationStrategy_AllocationStrategyConcurrency_default_instance_;
class AllocationStrategy_AllocationStrategyRefresh;
struct AllocationStrategy_AllocationStrategyRefreshDefaultTypeInternal;
extern AllocationStrategy_AllocationStrategyRefreshDefaultTypeInternal _AllocationStrategy_AllocationStrategyRefresh_default_instance_;
class InboundConfig;
struct InboundConfigDefaultTypeInternal;
extern InboundConfigDefaultTypeInternal _InboundConfig_default_instance_;
class InboundHandlerConfig;
struct InboundHandlerConfigDefaultTypeInternal;
extern InboundHandlerConfigDefaultTypeInternal _InboundHandlerConfig_default_instance_;
class MultiplexingConfig;
struct MultiplexingConfigDefaultTypeInternal;
extern MultiplexingConfigDefaultTypeInternal _MultiplexingConfig_default_instance_;
class OutboundConfig;
struct OutboundConfigDefaultTypeInternal;
extern OutboundConfigDefaultTypeInternal _OutboundConfig_default_instance_;
class ReceiverConfig;
struct ReceiverConfigDefaultTypeInternal;
extern ReceiverConfigDefaultTypeInternal _ReceiverConfig_default_instance_;
class SenderConfig;
struct SenderConfigDefaultTypeInternal;
extern SenderConfigDefaultTypeInternal _SenderConfig_default_instance_;
class SniffingConfig;
struct SniffingConfigDefaultTypeInternal;
extern SniffingConfigDefaultTypeInternal _SniffingConfig_default_instance_;
}  // namespace proxyman
}  // namespace app
}  // namespace xray
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xray {
namespace app {
namespace proxyman {
enum AllocationStrategy_Type : int {
  AllocationStrategy_Type_Always = 0,
  AllocationStrategy_Type_Random = 1,
  AllocationStrategy_Type_External = 2,
  AllocationStrategy_Type_AllocationStrategy_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AllocationStrategy_Type_AllocationStrategy_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AllocationStrategy_Type_IsValid(int value);
extern const uint32_t AllocationStrategy_Type_internal_data_[];
constexpr AllocationStrategy_Type AllocationStrategy_Type_Type_MIN = static_cast<AllocationStrategy_Type>(0);
constexpr AllocationStrategy_Type AllocationStrategy_Type_Type_MAX = static_cast<AllocationStrategy_Type>(2);
constexpr int AllocationStrategy_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AllocationStrategy_Type_descriptor();
template <typename T>
const std::string& AllocationStrategy_Type_Name(T value) {
  static_assert(std::is_same<T, AllocationStrategy_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return AllocationStrategy_Type_Name(static_cast<AllocationStrategy_Type>(value));
}
template <>
inline const std::string& AllocationStrategy_Type_Name(AllocationStrategy_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AllocationStrategy_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AllocationStrategy_Type_Parse(absl::string_view name, AllocationStrategy_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AllocationStrategy_Type>(
      AllocationStrategy_Type_descriptor(), name, value);
}
enum KnownProtocols : int {
  HTTP = 0,
  TLS = 1,
  KnownProtocols_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  KnownProtocols_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool KnownProtocols_IsValid(int value);
extern const uint32_t KnownProtocols_internal_data_[];
constexpr KnownProtocols KnownProtocols_MIN = static_cast<KnownProtocols>(0);
constexpr KnownProtocols KnownProtocols_MAX = static_cast<KnownProtocols>(1);
constexpr int KnownProtocols_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
KnownProtocols_descriptor();
template <typename T>
const std::string& KnownProtocols_Name(T value) {
  static_assert(std::is_same<T, KnownProtocols>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to KnownProtocols_Name().");
  return KnownProtocols_Name(static_cast<KnownProtocols>(value));
}
template <>
inline const std::string& KnownProtocols_Name(KnownProtocols value) {
  return ::google::protobuf::internal::NameOfDenseEnum<KnownProtocols_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool KnownProtocols_Parse(absl::string_view name, KnownProtocols* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KnownProtocols>(
      KnownProtocols_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SniffingConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.SniffingConfig) */ {
 public:
  inline SniffingConfig() : SniffingConfig(nullptr) {}
  ~SniffingConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SniffingConfig(::google::protobuf::internal::ConstantInitialized);

  inline SniffingConfig(const SniffingConfig& from)
      : SniffingConfig(nullptr, from) {}
  SniffingConfig(SniffingConfig&& from) noexcept
    : SniffingConfig() {
    *this = ::std::move(from);
  }

  inline SniffingConfig& operator=(const SniffingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SniffingConfig& operator=(SniffingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SniffingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SniffingConfig* internal_default_instance() {
    return reinterpret_cast<const SniffingConfig*>(
               &_SniffingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SniffingConfig& a, SniffingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SniffingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SniffingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SniffingConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SniffingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SniffingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SniffingConfig& from) {
    SniffingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SniffingConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.SniffingConfig";
  }
  protected:
  explicit SniffingConfig(::google::protobuf::Arena* arena);
  SniffingConfig(::google::protobuf::Arena* arena, const SniffingConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationOverrideFieldNumber = 2,
    kDomainsExcludedFieldNumber = 3,
    kEnabledFieldNumber = 1,
    kMetadataOnlyFieldNumber = 4,
    kRouteOnlyFieldNumber = 5,
  };
  // repeated string destination_override = 2;
  int destination_override_size() const;
  private:
  int _internal_destination_override_size() const;

  public:
  void clear_destination_override() ;
  const std::string& destination_override(int index) const;
  std::string* mutable_destination_override(int index);
  void set_destination_override(int index, const std::string& value);
  void set_destination_override(int index, std::string&& value);
  void set_destination_override(int index, const char* value);
  void set_destination_override(int index, const char* value, std::size_t size);
  void set_destination_override(int index, absl::string_view value);
  std::string* add_destination_override();
  void add_destination_override(const std::string& value);
  void add_destination_override(std::string&& value);
  void add_destination_override(const char* value);
  void add_destination_override(const char* value, std::size_t size);
  void add_destination_override(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& destination_override() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_destination_override();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_destination_override() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_destination_override();

  public:
  // repeated string domains_excluded = 3;
  int domains_excluded_size() const;
  private:
  int _internal_domains_excluded_size() const;

  public:
  void clear_domains_excluded() ;
  const std::string& domains_excluded(int index) const;
  std::string* mutable_domains_excluded(int index);
  void set_domains_excluded(int index, const std::string& value);
  void set_domains_excluded(int index, std::string&& value);
  void set_domains_excluded(int index, const char* value);
  void set_domains_excluded(int index, const char* value, std::size_t size);
  void set_domains_excluded(int index, absl::string_view value);
  std::string* add_domains_excluded();
  void add_domains_excluded(const std::string& value);
  void add_domains_excluded(std::string&& value);
  void add_domains_excluded(const char* value);
  void add_domains_excluded(const char* value, std::size_t size);
  void add_domains_excluded(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& domains_excluded() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_domains_excluded();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_domains_excluded() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_domains_excluded();

  public:
  // bool enabled = 1;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // bool metadata_only = 4;
  void clear_metadata_only() ;
  bool metadata_only() const;
  void set_metadata_only(bool value);

  private:
  bool _internal_metadata_only() const;
  void _internal_set_metadata_only(bool value);

  public:
  // bool route_only = 5;
  void clear_route_only() ;
  bool route_only() const;
  void set_route_only(bool value);

  private:
  bool _internal_route_only() const;
  void _internal_set_route_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.SniffingConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> destination_override_;
    ::google::protobuf::RepeatedPtrField<std::string> domains_excluded_;
    bool enabled_;
    bool metadata_only_;
    bool route_only_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class OutboundConfig final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xray.app.proxyman.OutboundConfig) */ {
 public:
  inline OutboundConfig() : OutboundConfig(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OutboundConfig(::google::protobuf::internal::ConstantInitialized);

  inline OutboundConfig(const OutboundConfig& from)
      : OutboundConfig(nullptr, from) {}
  OutboundConfig(OutboundConfig&& from) noexcept
    : OutboundConfig() {
    *this = ::std::move(from);
  }

  inline OutboundConfig& operator=(const OutboundConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutboundConfig& operator=(OutboundConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutboundConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutboundConfig* internal_default_instance() {
    return reinterpret_cast<const OutboundConfig*>(
               &_OutboundConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OutboundConfig& a, OutboundConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(OutboundConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutboundConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutboundConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutboundConfig>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OutboundConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OutboundConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.OutboundConfig";
  }
  protected:
  explicit OutboundConfig(::google::protobuf::Arena* arena);
  OutboundConfig(::google::protobuf::Arena* arena, const OutboundConfig& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xray.app.proxyman.OutboundConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class MultiplexingConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.MultiplexingConfig) */ {
 public:
  inline MultiplexingConfig() : MultiplexingConfig(nullptr) {}
  ~MultiplexingConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MultiplexingConfig(::google::protobuf::internal::ConstantInitialized);

  inline MultiplexingConfig(const MultiplexingConfig& from)
      : MultiplexingConfig(nullptr, from) {}
  MultiplexingConfig(MultiplexingConfig&& from) noexcept
    : MultiplexingConfig() {
    *this = ::std::move(from);
  }

  inline MultiplexingConfig& operator=(const MultiplexingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplexingConfig& operator=(MultiplexingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiplexingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiplexingConfig* internal_default_instance() {
    return reinterpret_cast<const MultiplexingConfig*>(
               &_MultiplexingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MultiplexingConfig& a, MultiplexingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplexingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplexingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiplexingConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiplexingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MultiplexingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MultiplexingConfig& from) {
    MultiplexingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MultiplexingConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.MultiplexingConfig";
  }
  protected:
  explicit MultiplexingConfig(::google::protobuf::Arena* arena);
  MultiplexingConfig(::google::protobuf::Arena* arena, const MultiplexingConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXudpProxyUDP443FieldNumber = 4,
    kEnabledFieldNumber = 1,
    kConcurrencyFieldNumber = 2,
    kXudpConcurrencyFieldNumber = 3,
  };
  // string xudpProxyUDP443 = 4;
  void clear_xudpproxyudp443() ;
  const std::string& xudpproxyudp443() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_xudpproxyudp443(Arg_&& arg, Args_... args);
  std::string* mutable_xudpproxyudp443();
  PROTOBUF_NODISCARD std::string* release_xudpproxyudp443();
  void set_allocated_xudpproxyudp443(std::string* value);

  private:
  const std::string& _internal_xudpproxyudp443() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xudpproxyudp443(
      const std::string& value);
  std::string* _internal_mutable_xudpproxyudp443();

  public:
  // bool enabled = 1;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // int32 concurrency = 2;
  void clear_concurrency() ;
  ::int32_t concurrency() const;
  void set_concurrency(::int32_t value);

  private:
  ::int32_t _internal_concurrency() const;
  void _internal_set_concurrency(::int32_t value);

  public:
  // int32 xudpConcurrency = 3;
  void clear_xudpconcurrency() ;
  ::int32_t xudpconcurrency() const;
  void set_xudpconcurrency(::int32_t value);

  private:
  ::int32_t _internal_xudpconcurrency() const;
  void _internal_set_xudpconcurrency(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.MultiplexingConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr xudpproxyudp443_;
    bool enabled_;
    ::int32_t concurrency_;
    ::int32_t xudpconcurrency_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class InboundConfig final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xray.app.proxyman.InboundConfig) */ {
 public:
  inline InboundConfig() : InboundConfig(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InboundConfig(::google::protobuf::internal::ConstantInitialized);

  inline InboundConfig(const InboundConfig& from)
      : InboundConfig(nullptr, from) {}
  InboundConfig(InboundConfig&& from) noexcept
    : InboundConfig() {
    *this = ::std::move(from);
  }

  inline InboundConfig& operator=(const InboundConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InboundConfig& operator=(InboundConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InboundConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const InboundConfig* internal_default_instance() {
    return reinterpret_cast<const InboundConfig*>(
               &_InboundConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InboundConfig& a, InboundConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InboundConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InboundConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InboundConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InboundConfig>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InboundConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InboundConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.InboundConfig";
  }
  protected:
  explicit InboundConfig(::google::protobuf::Arena* arena);
  InboundConfig(::google::protobuf::Arena* arena, const InboundConfig& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xray.app.proxyman.InboundConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class AllocationStrategy_AllocationStrategyRefresh final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh) */ {
 public:
  inline AllocationStrategy_AllocationStrategyRefresh() : AllocationStrategy_AllocationStrategyRefresh(nullptr) {}
  ~AllocationStrategy_AllocationStrategyRefresh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocationStrategy_AllocationStrategyRefresh(::google::protobuf::internal::ConstantInitialized);

  inline AllocationStrategy_AllocationStrategyRefresh(const AllocationStrategy_AllocationStrategyRefresh& from)
      : AllocationStrategy_AllocationStrategyRefresh(nullptr, from) {}
  AllocationStrategy_AllocationStrategyRefresh(AllocationStrategy_AllocationStrategyRefresh&& from) noexcept
    : AllocationStrategy_AllocationStrategyRefresh() {
    *this = ::std::move(from);
  }

  inline AllocationStrategy_AllocationStrategyRefresh& operator=(const AllocationStrategy_AllocationStrategyRefresh& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocationStrategy_AllocationStrategyRefresh& operator=(AllocationStrategy_AllocationStrategyRefresh&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocationStrategy_AllocationStrategyRefresh& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocationStrategy_AllocationStrategyRefresh* internal_default_instance() {
    return reinterpret_cast<const AllocationStrategy_AllocationStrategyRefresh*>(
               &_AllocationStrategy_AllocationStrategyRefresh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AllocationStrategy_AllocationStrategyRefresh& a, AllocationStrategy_AllocationStrategyRefresh& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocationStrategy_AllocationStrategyRefresh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocationStrategy_AllocationStrategyRefresh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocationStrategy_AllocationStrategyRefresh* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocationStrategy_AllocationStrategyRefresh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllocationStrategy_AllocationStrategyRefresh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AllocationStrategy_AllocationStrategyRefresh& from) {
    AllocationStrategy_AllocationStrategyRefresh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllocationStrategy_AllocationStrategyRefresh* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh";
  }
  protected:
  explicit AllocationStrategy_AllocationStrategyRefresh(::google::protobuf::Arena* arena);
  AllocationStrategy_AllocationStrategyRefresh(::google::protobuf::Arena* arena, const AllocationStrategy_AllocationStrategyRefresh& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class AllocationStrategy_AllocationStrategyConcurrency final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency) */ {
 public:
  inline AllocationStrategy_AllocationStrategyConcurrency() : AllocationStrategy_AllocationStrategyConcurrency(nullptr) {}
  ~AllocationStrategy_AllocationStrategyConcurrency() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocationStrategy_AllocationStrategyConcurrency(::google::protobuf::internal::ConstantInitialized);

  inline AllocationStrategy_AllocationStrategyConcurrency(const AllocationStrategy_AllocationStrategyConcurrency& from)
      : AllocationStrategy_AllocationStrategyConcurrency(nullptr, from) {}
  AllocationStrategy_AllocationStrategyConcurrency(AllocationStrategy_AllocationStrategyConcurrency&& from) noexcept
    : AllocationStrategy_AllocationStrategyConcurrency() {
    *this = ::std::move(from);
  }

  inline AllocationStrategy_AllocationStrategyConcurrency& operator=(const AllocationStrategy_AllocationStrategyConcurrency& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocationStrategy_AllocationStrategyConcurrency& operator=(AllocationStrategy_AllocationStrategyConcurrency&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocationStrategy_AllocationStrategyConcurrency& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocationStrategy_AllocationStrategyConcurrency* internal_default_instance() {
    return reinterpret_cast<const AllocationStrategy_AllocationStrategyConcurrency*>(
               &_AllocationStrategy_AllocationStrategyConcurrency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AllocationStrategy_AllocationStrategyConcurrency& a, AllocationStrategy_AllocationStrategyConcurrency& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocationStrategy_AllocationStrategyConcurrency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocationStrategy_AllocationStrategyConcurrency* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocationStrategy_AllocationStrategyConcurrency* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocationStrategy_AllocationStrategyConcurrency>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllocationStrategy_AllocationStrategyConcurrency& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AllocationStrategy_AllocationStrategyConcurrency& from) {
    AllocationStrategy_AllocationStrategyConcurrency::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllocationStrategy_AllocationStrategyConcurrency* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency";
  }
  protected:
  explicit AllocationStrategy_AllocationStrategyConcurrency(::google::protobuf::Arena* arena);
  AllocationStrategy_AllocationStrategyConcurrency(::google::protobuf::Arena* arena, const AllocationStrategy_AllocationStrategyConcurrency& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class InboundHandlerConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.InboundHandlerConfig) */ {
 public:
  inline InboundHandlerConfig() : InboundHandlerConfig(nullptr) {}
  ~InboundHandlerConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InboundHandlerConfig(::google::protobuf::internal::ConstantInitialized);

  inline InboundHandlerConfig(const InboundHandlerConfig& from)
      : InboundHandlerConfig(nullptr, from) {}
  InboundHandlerConfig(InboundHandlerConfig&& from) noexcept
    : InboundHandlerConfig() {
    *this = ::std::move(from);
  }

  inline InboundHandlerConfig& operator=(const InboundHandlerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InboundHandlerConfig& operator=(InboundHandlerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InboundHandlerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const InboundHandlerConfig* internal_default_instance() {
    return reinterpret_cast<const InboundHandlerConfig*>(
               &_InboundHandlerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InboundHandlerConfig& a, InboundHandlerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InboundHandlerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InboundHandlerConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InboundHandlerConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InboundHandlerConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InboundHandlerConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InboundHandlerConfig& from) {
    InboundHandlerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InboundHandlerConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.InboundHandlerConfig";
  }
  protected:
  explicit InboundHandlerConfig(::google::protobuf::Arena* arena);
  InboundHandlerConfig(::google::protobuf::Arena* arena, const InboundHandlerConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kReceiverSettingsFieldNumber = 2,
    kProxySettingsFieldNumber = 3,
  };
  // string tag = 1;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // .xray.common.serial.TypedMessage receiver_settings = 2;
  bool has_receiver_settings() const;
  void clear_receiver_settings() ;
  const ::xray::common::serial::TypedMessage& receiver_settings() const;
  PROTOBUF_NODISCARD ::xray::common::serial::TypedMessage* release_receiver_settings();
  ::xray::common::serial::TypedMessage* mutable_receiver_settings();
  void set_allocated_receiver_settings(::xray::common::serial::TypedMessage* value);
  void unsafe_arena_set_allocated_receiver_settings(::xray::common::serial::TypedMessage* value);
  ::xray::common::serial::TypedMessage* unsafe_arena_release_receiver_settings();

  private:
  const ::xray::common::serial::TypedMessage& _internal_receiver_settings() const;
  ::xray::common::serial::TypedMessage* _internal_mutable_receiver_settings();

  public:
  // .xray.common.serial.TypedMessage proxy_settings = 3;
  bool has_proxy_settings() const;
  void clear_proxy_settings() ;
  const ::xray::common::serial::TypedMessage& proxy_settings() const;
  PROTOBUF_NODISCARD ::xray::common::serial::TypedMessage* release_proxy_settings();
  ::xray::common::serial::TypedMessage* mutable_proxy_settings();
  void set_allocated_proxy_settings(::xray::common::serial::TypedMessage* value);
  void unsafe_arena_set_allocated_proxy_settings(::xray::common::serial::TypedMessage* value);
  ::xray::common::serial::TypedMessage* unsafe_arena_release_proxy_settings();

  private:
  const ::xray::common::serial::TypedMessage& _internal_proxy_settings() const;
  ::xray::common::serial::TypedMessage* _internal_mutable_proxy_settings();

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.InboundHandlerConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr tag_;
    ::xray::common::serial::TypedMessage* receiver_settings_;
    ::xray::common::serial::TypedMessage* proxy_settings_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class AllocationStrategy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.AllocationStrategy) */ {
 public:
  inline AllocationStrategy() : AllocationStrategy(nullptr) {}
  ~AllocationStrategy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocationStrategy(::google::protobuf::internal::ConstantInitialized);

  inline AllocationStrategy(const AllocationStrategy& from)
      : AllocationStrategy(nullptr, from) {}
  AllocationStrategy(AllocationStrategy&& from) noexcept
    : AllocationStrategy() {
    *this = ::std::move(from);
  }

  inline AllocationStrategy& operator=(const AllocationStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocationStrategy& operator=(AllocationStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocationStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocationStrategy* internal_default_instance() {
    return reinterpret_cast<const AllocationStrategy*>(
               &_AllocationStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AllocationStrategy& a, AllocationStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocationStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocationStrategy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocationStrategy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocationStrategy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllocationStrategy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AllocationStrategy& from) {
    AllocationStrategy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllocationStrategy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.AllocationStrategy";
  }
  protected:
  explicit AllocationStrategy(::google::protobuf::Arena* arena);
  AllocationStrategy(::google::protobuf::Arena* arena, const AllocationStrategy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AllocationStrategyConcurrency = AllocationStrategy_AllocationStrategyConcurrency;
  using AllocationStrategyRefresh = AllocationStrategy_AllocationStrategyRefresh;

  using Type = AllocationStrategy_Type;
  static constexpr Type Always = AllocationStrategy_Type_Always;
  static constexpr Type Random = AllocationStrategy_Type_Random;
  static constexpr Type External = AllocationStrategy_Type_External;
  static inline bool Type_IsValid(int value) {
    return AllocationStrategy_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = AllocationStrategy_Type_Type_MIN;
  static constexpr Type Type_MAX = AllocationStrategy_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = AllocationStrategy_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return AllocationStrategy_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return AllocationStrategy_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return AllocationStrategy_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConcurrencyFieldNumber = 2,
    kRefreshFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency concurrency = 2;
  bool has_concurrency() const;
  void clear_concurrency() ;
  const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency& concurrency() const;
  PROTOBUF_NODISCARD ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* release_concurrency();
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* mutable_concurrency();
  void set_allocated_concurrency(::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* value);
  void unsafe_arena_set_allocated_concurrency(::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* value);
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* unsafe_arena_release_concurrency();

  private:
  const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency& _internal_concurrency() const;
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* _internal_mutable_concurrency();

  public:
  // .xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh refresh = 3;
  bool has_refresh() const;
  void clear_refresh() ;
  const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh& refresh() const;
  PROTOBUF_NODISCARD ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* release_refresh();
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* mutable_refresh();
  void set_allocated_refresh(::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* value);
  void unsafe_arena_set_allocated_refresh(::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* value);
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* unsafe_arena_release_refresh();

  private:
  const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh& _internal_refresh() const;
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* _internal_mutable_refresh();

  public:
  // .xray.app.proxyman.AllocationStrategy.Type type = 1;
  void clear_type() ;
  ::xray::app::proxyman::AllocationStrategy_Type type() const;
  void set_type(::xray::app::proxyman::AllocationStrategy_Type value);

  private:
  ::xray::app::proxyman::AllocationStrategy_Type _internal_type() const;
  void _internal_set_type(::xray::app::proxyman::AllocationStrategy_Type value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.AllocationStrategy)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* concurrency_;
    ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* refresh_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class SenderConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.SenderConfig) */ {
 public:
  inline SenderConfig() : SenderConfig(nullptr) {}
  ~SenderConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SenderConfig(::google::protobuf::internal::ConstantInitialized);

  inline SenderConfig(const SenderConfig& from)
      : SenderConfig(nullptr, from) {}
  SenderConfig(SenderConfig&& from) noexcept
    : SenderConfig() {
    *this = ::std::move(from);
  }

  inline SenderConfig& operator=(const SenderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SenderConfig& operator=(SenderConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SenderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SenderConfig* internal_default_instance() {
    return reinterpret_cast<const SenderConfig*>(
               &_SenderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SenderConfig& a, SenderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SenderConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SenderConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SenderConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SenderConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SenderConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SenderConfig& from) {
    SenderConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SenderConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.SenderConfig";
  }
  protected:
  explicit SenderConfig(::google::protobuf::Arena* arena);
  SenderConfig(::google::protobuf::Arena* arena, const SenderConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViaCidrFieldNumber = 5,
    kViaFieldNumber = 1,
    kStreamSettingsFieldNumber = 2,
    kProxySettingsFieldNumber = 3,
    kMultiplexSettingsFieldNumber = 4,
  };
  // string via_cidr = 5;
  void clear_via_cidr() ;
  const std::string& via_cidr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_via_cidr(Arg_&& arg, Args_... args);
  std::string* mutable_via_cidr();
  PROTOBUF_NODISCARD std::string* release_via_cidr();
  void set_allocated_via_cidr(std::string* value);

  private:
  const std::string& _internal_via_cidr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_via_cidr(
      const std::string& value);
  std::string* _internal_mutable_via_cidr();

  public:
  // .xray.common.net.IPOrDomain via = 1;
  bool has_via() const;
  void clear_via() ;
  const ::xray::common::net::IPOrDomain& via() const;
  PROTOBUF_NODISCARD ::xray::common::net::IPOrDomain* release_via();
  ::xray::common::net::IPOrDomain* mutable_via();
  void set_allocated_via(::xray::common::net::IPOrDomain* value);
  void unsafe_arena_set_allocated_via(::xray::common::net::IPOrDomain* value);
  ::xray::common::net::IPOrDomain* unsafe_arena_release_via();

  private:
  const ::xray::common::net::IPOrDomain& _internal_via() const;
  ::xray::common::net::IPOrDomain* _internal_mutable_via();

  public:
  // .xray.transport.internet.StreamConfig stream_settings = 2;
  bool has_stream_settings() const;
  void clear_stream_settings() ;
  const ::xray::transport::internet::StreamConfig& stream_settings() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::StreamConfig* release_stream_settings();
  ::xray::transport::internet::StreamConfig* mutable_stream_settings();
  void set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value);
  void unsafe_arena_set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value);
  ::xray::transport::internet::StreamConfig* unsafe_arena_release_stream_settings();

  private:
  const ::xray::transport::internet::StreamConfig& _internal_stream_settings() const;
  ::xray::transport::internet::StreamConfig* _internal_mutable_stream_settings();

  public:
  // .xray.transport.internet.ProxyConfig proxy_settings = 3;
  bool has_proxy_settings() const;
  void clear_proxy_settings() ;
  const ::xray::transport::internet::ProxyConfig& proxy_settings() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::ProxyConfig* release_proxy_settings();
  ::xray::transport::internet::ProxyConfig* mutable_proxy_settings();
  void set_allocated_proxy_settings(::xray::transport::internet::ProxyConfig* value);
  void unsafe_arena_set_allocated_proxy_settings(::xray::transport::internet::ProxyConfig* value);
  ::xray::transport::internet::ProxyConfig* unsafe_arena_release_proxy_settings();

  private:
  const ::xray::transport::internet::ProxyConfig& _internal_proxy_settings() const;
  ::xray::transport::internet::ProxyConfig* _internal_mutable_proxy_settings();

  public:
  // .xray.app.proxyman.MultiplexingConfig multiplex_settings = 4;
  bool has_multiplex_settings() const;
  void clear_multiplex_settings() ;
  const ::xray::app::proxyman::MultiplexingConfig& multiplex_settings() const;
  PROTOBUF_NODISCARD ::xray::app::proxyman::MultiplexingConfig* release_multiplex_settings();
  ::xray::app::proxyman::MultiplexingConfig* mutable_multiplex_settings();
  void set_allocated_multiplex_settings(::xray::app::proxyman::MultiplexingConfig* value);
  void unsafe_arena_set_allocated_multiplex_settings(::xray::app::proxyman::MultiplexingConfig* value);
  ::xray::app::proxyman::MultiplexingConfig* unsafe_arena_release_multiplex_settings();

  private:
  const ::xray::app::proxyman::MultiplexingConfig& _internal_multiplex_settings() const;
  ::xray::app::proxyman::MultiplexingConfig* _internal_mutable_multiplex_settings();

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.SenderConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr via_cidr_;
    ::xray::common::net::IPOrDomain* via_;
    ::xray::transport::internet::StreamConfig* stream_settings_;
    ::xray::transport::internet::ProxyConfig* proxy_settings_;
    ::xray::app::proxyman::MultiplexingConfig* multiplex_settings_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};// -------------------------------------------------------------------

class ReceiverConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.proxyman.ReceiverConfig) */ {
 public:
  inline ReceiverConfig() : ReceiverConfig(nullptr) {}
  ~ReceiverConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiverConfig(::google::protobuf::internal::ConstantInitialized);

  inline ReceiverConfig(const ReceiverConfig& from)
      : ReceiverConfig(nullptr, from) {}
  ReceiverConfig(ReceiverConfig&& from) noexcept
    : ReceiverConfig() {
    *this = ::std::move(from);
  }

  inline ReceiverConfig& operator=(const ReceiverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiverConfig& operator=(ReceiverConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiverConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiverConfig* internal_default_instance() {
    return reinterpret_cast<const ReceiverConfig*>(
               &_ReceiverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReceiverConfig& a, ReceiverConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiverConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiverConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiverConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiverConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReceiverConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ReceiverConfig& from) {
    ReceiverConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReceiverConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.proxyman.ReceiverConfig";
  }
  protected:
  explicit ReceiverConfig(::google::protobuf::Arena* arena);
  ReceiverConfig(::google::protobuf::Arena* arena, const ReceiverConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainOverrideFieldNumber = 7,
    kPortListFieldNumber = 1,
    kListenFieldNumber = 2,
    kAllocationStrategyFieldNumber = 3,
    kStreamSettingsFieldNumber = 4,
    kSniffingSettingsFieldNumber = 8,
    kReceiveOriginalDestinationFieldNumber = 5,
  };
  // repeated .xray.app.proxyman.KnownProtocols domain_override = 7 [deprecated = true];
  [[deprecated]]  int domain_override_size() const;
  private:
  int _internal_domain_override_size() const;

  public:
  [[deprecated]]  void clear_domain_override() ;
  public:
  [[deprecated]] ::xray::app::proxyman::KnownProtocols domain_override(int index) const;
  [[deprecated]] void set_domain_override(int index, ::xray::app::proxyman::KnownProtocols value);
  [[deprecated]] void add_domain_override(::xray::app::proxyman::KnownProtocols value);
  [[deprecated]] const ::google::protobuf::RepeatedField<int>& domain_override() const;
  [[deprecated]] ::google::protobuf::RepeatedField<int>* mutable_domain_override();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_domain_override() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_domain_override();

  public:
  // .xray.common.net.PortList port_list = 1;
  bool has_port_list() const;
  void clear_port_list() ;
  const ::xray::common::net::PortList& port_list() const;
  PROTOBUF_NODISCARD ::xray::common::net::PortList* release_port_list();
  ::xray::common::net::PortList* mutable_port_list();
  void set_allocated_port_list(::xray::common::net::PortList* value);
  void unsafe_arena_set_allocated_port_list(::xray::common::net::PortList* value);
  ::xray::common::net::PortList* unsafe_arena_release_port_list();

  private:
  const ::xray::common::net::PortList& _internal_port_list() const;
  ::xray::common::net::PortList* _internal_mutable_port_list();

  public:
  // .xray.common.net.IPOrDomain listen = 2;
  bool has_listen() const;
  void clear_listen() ;
  const ::xray::common::net::IPOrDomain& listen() const;
  PROTOBUF_NODISCARD ::xray::common::net::IPOrDomain* release_listen();
  ::xray::common::net::IPOrDomain* mutable_listen();
  void set_allocated_listen(::xray::common::net::IPOrDomain* value);
  void unsafe_arena_set_allocated_listen(::xray::common::net::IPOrDomain* value);
  ::xray::common::net::IPOrDomain* unsafe_arena_release_listen();

  private:
  const ::xray::common::net::IPOrDomain& _internal_listen() const;
  ::xray::common::net::IPOrDomain* _internal_mutable_listen();

  public:
  // .xray.app.proxyman.AllocationStrategy allocation_strategy = 3;
  bool has_allocation_strategy() const;
  void clear_allocation_strategy() ;
  const ::xray::app::proxyman::AllocationStrategy& allocation_strategy() const;
  PROTOBUF_NODISCARD ::xray::app::proxyman::AllocationStrategy* release_allocation_strategy();
  ::xray::app::proxyman::AllocationStrategy* mutable_allocation_strategy();
  void set_allocated_allocation_strategy(::xray::app::proxyman::AllocationStrategy* value);
  void unsafe_arena_set_allocated_allocation_strategy(::xray::app::proxyman::AllocationStrategy* value);
  ::xray::app::proxyman::AllocationStrategy* unsafe_arena_release_allocation_strategy();

  private:
  const ::xray::app::proxyman::AllocationStrategy& _internal_allocation_strategy() const;
  ::xray::app::proxyman::AllocationStrategy* _internal_mutable_allocation_strategy();

  public:
  // .xray.transport.internet.StreamConfig stream_settings = 4;
  bool has_stream_settings() const;
  void clear_stream_settings() ;
  const ::xray::transport::internet::StreamConfig& stream_settings() const;
  PROTOBUF_NODISCARD ::xray::transport::internet::StreamConfig* release_stream_settings();
  ::xray::transport::internet::StreamConfig* mutable_stream_settings();
  void set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value);
  void unsafe_arena_set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value);
  ::xray::transport::internet::StreamConfig* unsafe_arena_release_stream_settings();

  private:
  const ::xray::transport::internet::StreamConfig& _internal_stream_settings() const;
  ::xray::transport::internet::StreamConfig* _internal_mutable_stream_settings();

  public:
  // .xray.app.proxyman.SniffingConfig sniffing_settings = 8;
  bool has_sniffing_settings() const;
  void clear_sniffing_settings() ;
  const ::xray::app::proxyman::SniffingConfig& sniffing_settings() const;
  PROTOBUF_NODISCARD ::xray::app::proxyman::SniffingConfig* release_sniffing_settings();
  ::xray::app::proxyman::SniffingConfig* mutable_sniffing_settings();
  void set_allocated_sniffing_settings(::xray::app::proxyman::SniffingConfig* value);
  void unsafe_arena_set_allocated_sniffing_settings(::xray::app::proxyman::SniffingConfig* value);
  ::xray::app::proxyman::SniffingConfig* unsafe_arena_release_sniffing_settings();

  private:
  const ::xray::app::proxyman::SniffingConfig& _internal_sniffing_settings() const;
  ::xray::app::proxyman::SniffingConfig* _internal_mutable_sniffing_settings();

  public:
  // bool receive_original_destination = 5;
  void clear_receive_original_destination() ;
  bool receive_original_destination() const;
  void set_receive_original_destination(bool value);

  private:
  bool _internal_receive_original_destination() const;
  void _internal_set_receive_original_destination(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.proxyman.ReceiverConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> domain_override_;
    mutable ::google::protobuf::internal::CachedSize _domain_override_cached_byte_size_;
    ::xray::common::net::PortList* port_list_;
    ::xray::common::net::IPOrDomain* listen_;
    ::xray::app::proxyman::AllocationStrategy* allocation_strategy_;
    ::xray::transport::internet::StreamConfig* stream_settings_;
    ::xray::app::proxyman::SniffingConfig* sniffing_settings_;
    bool receive_original_destination_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fproxyman_2fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InboundConfig

// -------------------------------------------------------------------

// AllocationStrategy_AllocationStrategyConcurrency

// uint32 value = 1;
inline void AllocationStrategy_AllocationStrategyConcurrency::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
}
inline ::uint32_t AllocationStrategy_AllocationStrategyConcurrency::value() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency.value)
  return _internal_value();
}
inline void AllocationStrategy_AllocationStrategyConcurrency::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency.value)
}
inline ::uint32_t AllocationStrategy_AllocationStrategyConcurrency::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void AllocationStrategy_AllocationStrategyConcurrency::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// AllocationStrategy_AllocationStrategyRefresh

// uint32 value = 1;
inline void AllocationStrategy_AllocationStrategyRefresh::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
}
inline ::uint32_t AllocationStrategy_AllocationStrategyRefresh::value() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh.value)
  return _internal_value();
}
inline void AllocationStrategy_AllocationStrategyRefresh::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh.value)
}
inline ::uint32_t AllocationStrategy_AllocationStrategyRefresh::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void AllocationStrategy_AllocationStrategyRefresh::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// AllocationStrategy

// .xray.app.proxyman.AllocationStrategy.Type type = 1;
inline void AllocationStrategy::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::xray::app::proxyman::AllocationStrategy_Type AllocationStrategy::type() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.AllocationStrategy.type)
  return _internal_type();
}
inline void AllocationStrategy::set_type(::xray::app::proxyman::AllocationStrategy_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.AllocationStrategy.type)
}
inline ::xray::app::proxyman::AllocationStrategy_Type AllocationStrategy::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::app::proxyman::AllocationStrategy_Type>(_impl_.type_);
}
inline void AllocationStrategy::_internal_set_type(::xray::app::proxyman::AllocationStrategy_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .xray.app.proxyman.AllocationStrategy.AllocationStrategyConcurrency concurrency = 2;
inline bool AllocationStrategy::has_concurrency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.concurrency_ != nullptr);
  return value;
}
inline void AllocationStrategy::clear_concurrency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.concurrency_ != nullptr) _impl_.concurrency_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency& AllocationStrategy::_internal_concurrency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* p = _impl_.concurrency_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency&>(::xray::app::proxyman::_AllocationStrategy_AllocationStrategyConcurrency_default_instance_);
}
inline const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency& AllocationStrategy::concurrency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.AllocationStrategy.concurrency)
  return _internal_concurrency();
}
inline void AllocationStrategy::unsafe_arena_set_allocated_concurrency(::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.concurrency_);
  }
  _impl_.concurrency_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.AllocationStrategy.concurrency)
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* AllocationStrategy::release_concurrency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* released = _impl_.concurrency_;
  _impl_.concurrency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* AllocationStrategy::unsafe_arena_release_concurrency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.AllocationStrategy.concurrency)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* temp = _impl_.concurrency_;
  _impl_.concurrency_ = nullptr;
  return temp;
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* AllocationStrategy::_internal_mutable_concurrency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.concurrency_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency>(GetArena());
    _impl_.concurrency_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency*>(p);
  }
  return _impl_.concurrency_;
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* AllocationStrategy::mutable_concurrency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* _msg = _internal_mutable_concurrency();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.AllocationStrategy.concurrency)
  return _msg;
}
inline void AllocationStrategy::set_allocated_concurrency(::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency*>(_impl_.concurrency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.concurrency_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyConcurrency*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.AllocationStrategy.concurrency)
}

// .xray.app.proxyman.AllocationStrategy.AllocationStrategyRefresh refresh = 3;
inline bool AllocationStrategy::has_refresh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.refresh_ != nullptr);
  return value;
}
inline void AllocationStrategy::clear_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.refresh_ != nullptr) _impl_.refresh_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh& AllocationStrategy::_internal_refresh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* p = _impl_.refresh_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh&>(::xray::app::proxyman::_AllocationStrategy_AllocationStrategyRefresh_default_instance_);
}
inline const ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh& AllocationStrategy::refresh() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.AllocationStrategy.refresh)
  return _internal_refresh();
}
inline void AllocationStrategy::unsafe_arena_set_allocated_refresh(::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.refresh_);
  }
  _impl_.refresh_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.AllocationStrategy.refresh)
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* AllocationStrategy::release_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* released = _impl_.refresh_;
  _impl_.refresh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* AllocationStrategy::unsafe_arena_release_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.AllocationStrategy.refresh)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* temp = _impl_.refresh_;
  _impl_.refresh_ = nullptr;
  return temp;
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* AllocationStrategy::_internal_mutable_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.refresh_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh>(GetArena());
    _impl_.refresh_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh*>(p);
  }
  return _impl_.refresh_;
}
inline ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* AllocationStrategy::mutable_refresh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* _msg = _internal_mutable_refresh();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.AllocationStrategy.refresh)
  return _msg;
}
inline void AllocationStrategy::set_allocated_refresh(::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh*>(_impl_.refresh_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.refresh_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy_AllocationStrategyRefresh*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.AllocationStrategy.refresh)
}

// -------------------------------------------------------------------

// SniffingConfig

// bool enabled = 1;
inline void SniffingConfig::clear_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = false;
}
inline bool SniffingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SniffingConfig.enabled)
  return _internal_enabled();
}
inline void SniffingConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SniffingConfig.enabled)
}
inline bool SniffingConfig::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void SniffingConfig::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

// repeated string destination_override = 2;
inline int SniffingConfig::_internal_destination_override_size() const {
  return _internal_destination_override().size();
}
inline int SniffingConfig::destination_override_size() const {
  return _internal_destination_override_size();
}
inline void SniffingConfig::clear_destination_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_override_.Clear();
}
inline std::string* SniffingConfig::add_destination_override()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_destination_override()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.app.proxyman.SniffingConfig.destination_override)
  return _s;
}
inline const std::string& SniffingConfig::destination_override(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SniffingConfig.destination_override)
  return _internal_destination_override().Get(index);
}
inline std::string* SniffingConfig::mutable_destination_override(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.SniffingConfig.destination_override)
  return _internal_mutable_destination_override()->Mutable(index);
}
inline void SniffingConfig::set_destination_override(int index, const std::string& value) {
  _internal_mutable_destination_override()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::set_destination_override(int index, std::string&& value) {
  _internal_mutable_destination_override()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::set_destination_override(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_destination_override()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::set_destination_override(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_destination_override()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::set_destination_override(int index, absl::string_view value) {
  _internal_mutable_destination_override()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::add_destination_override(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destination_override()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::add_destination_override(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destination_override()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::add_destination_override(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destination_override()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::add_destination_override(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destination_override()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.app.proxyman.SniffingConfig.destination_override)
}
inline void SniffingConfig::add_destination_override(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_destination_override()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.app.proxyman.SniffingConfig.destination_override)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SniffingConfig::destination_override() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.proxyman.SniffingConfig.destination_override)
  return _internal_destination_override();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SniffingConfig::mutable_destination_override() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.proxyman.SniffingConfig.destination_override)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_destination_override();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SniffingConfig::_internal_destination_override() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destination_override_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SniffingConfig::_internal_mutable_destination_override() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.destination_override_;
}

// repeated string domains_excluded = 3;
inline int SniffingConfig::_internal_domains_excluded_size() const {
  return _internal_domains_excluded().size();
}
inline int SniffingConfig::domains_excluded_size() const {
  return _internal_domains_excluded_size();
}
inline void SniffingConfig::clear_domains_excluded() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domains_excluded_.Clear();
}
inline std::string* SniffingConfig::add_domains_excluded()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_domains_excluded()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.app.proxyman.SniffingConfig.domains_excluded)
  return _s;
}
inline const std::string& SniffingConfig::domains_excluded(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SniffingConfig.domains_excluded)
  return _internal_domains_excluded().Get(index);
}
inline std::string* SniffingConfig::mutable_domains_excluded(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.SniffingConfig.domains_excluded)
  return _internal_mutable_domains_excluded()->Mutable(index);
}
inline void SniffingConfig::set_domains_excluded(int index, const std::string& value) {
  _internal_mutable_domains_excluded()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::set_domains_excluded(int index, std::string&& value) {
  _internal_mutable_domains_excluded()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::set_domains_excluded(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_domains_excluded()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::set_domains_excluded(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_domains_excluded()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::set_domains_excluded(int index, absl::string_view value) {
  _internal_mutable_domains_excluded()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::add_domains_excluded(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domains_excluded()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::add_domains_excluded(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domains_excluded()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::add_domains_excluded(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domains_excluded()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::add_domains_excluded(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domains_excluded()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline void SniffingConfig::add_domains_excluded(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domains_excluded()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.app.proxyman.SniffingConfig.domains_excluded)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SniffingConfig::domains_excluded() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.proxyman.SniffingConfig.domains_excluded)
  return _internal_domains_excluded();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SniffingConfig::mutable_domains_excluded() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.proxyman.SniffingConfig.domains_excluded)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_domains_excluded();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SniffingConfig::_internal_domains_excluded() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domains_excluded_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SniffingConfig::_internal_mutable_domains_excluded() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.domains_excluded_;
}

// bool metadata_only = 4;
inline void SniffingConfig::clear_metadata_only() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_only_ = false;
}
inline bool SniffingConfig::metadata_only() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SniffingConfig.metadata_only)
  return _internal_metadata_only();
}
inline void SniffingConfig::set_metadata_only(bool value) {
  _internal_set_metadata_only(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SniffingConfig.metadata_only)
}
inline bool SniffingConfig::_internal_metadata_only() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_only_;
}
inline void SniffingConfig::_internal_set_metadata_only(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metadata_only_ = value;
}

// bool route_only = 5;
inline void SniffingConfig::clear_route_only() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_only_ = false;
}
inline bool SniffingConfig::route_only() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SniffingConfig.route_only)
  return _internal_route_only();
}
inline void SniffingConfig::set_route_only(bool value) {
  _internal_set_route_only(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SniffingConfig.route_only)
}
inline bool SniffingConfig::_internal_route_only() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_only_;
}
inline void SniffingConfig::_internal_set_route_only(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.route_only_ = value;
}

// -------------------------------------------------------------------

// ReceiverConfig

// .xray.common.net.PortList port_list = 1;
inline bool ReceiverConfig::has_port_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.port_list_ != nullptr);
  return value;
}
inline const ::xray::common::net::PortList& ReceiverConfig::_internal_port_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::PortList* p = _impl_.port_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::PortList&>(::xray::common::net::_PortList_default_instance_);
}
inline const ::xray::common::net::PortList& ReceiverConfig::port_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.ReceiverConfig.port_list)
  return _internal_port_list();
}
inline void ReceiverConfig::unsafe_arena_set_allocated_port_list(::xray::common::net::PortList* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.port_list_);
  }
  _impl_.port_list_ = reinterpret_cast<::xray::common::net::PortList*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.ReceiverConfig.port_list)
}
inline ::xray::common::net::PortList* ReceiverConfig::release_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::PortList* released = _impl_.port_list_;
  _impl_.port_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::PortList* ReceiverConfig::unsafe_arena_release_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.ReceiverConfig.port_list)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::PortList* temp = _impl_.port_list_;
  _impl_.port_list_ = nullptr;
  return temp;
}
inline ::xray::common::net::PortList* ReceiverConfig::_internal_mutable_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.port_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::PortList>(GetArena());
    _impl_.port_list_ = reinterpret_cast<::xray::common::net::PortList*>(p);
  }
  return _impl_.port_list_;
}
inline ::xray::common::net::PortList* ReceiverConfig::mutable_port_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::PortList* _msg = _internal_mutable_port_list();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.ReceiverConfig.port_list)
  return _msg;
}
inline void ReceiverConfig::set_allocated_port_list(::xray::common::net::PortList* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.port_list_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.port_list_ = reinterpret_cast<::xray::common::net::PortList*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.ReceiverConfig.port_list)
}

// .xray.common.net.IPOrDomain listen = 2;
inline bool ReceiverConfig::has_listen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.listen_ != nullptr);
  return value;
}
inline const ::xray::common::net::IPOrDomain& ReceiverConfig::_internal_listen() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::IPOrDomain* p = _impl_.listen_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::IPOrDomain&>(::xray::common::net::_IPOrDomain_default_instance_);
}
inline const ::xray::common::net::IPOrDomain& ReceiverConfig::listen() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.ReceiverConfig.listen)
  return _internal_listen();
}
inline void ReceiverConfig::unsafe_arena_set_allocated_listen(::xray::common::net::IPOrDomain* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.listen_);
  }
  _impl_.listen_ = reinterpret_cast<::xray::common::net::IPOrDomain*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.ReceiverConfig.listen)
}
inline ::xray::common::net::IPOrDomain* ReceiverConfig::release_listen() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::common::net::IPOrDomain* released = _impl_.listen_;
  _impl_.listen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::IPOrDomain* ReceiverConfig::unsafe_arena_release_listen() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.ReceiverConfig.listen)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::common::net::IPOrDomain* temp = _impl_.listen_;
  _impl_.listen_ = nullptr;
  return temp;
}
inline ::xray::common::net::IPOrDomain* ReceiverConfig::_internal_mutable_listen() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.listen_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::IPOrDomain>(GetArena());
    _impl_.listen_ = reinterpret_cast<::xray::common::net::IPOrDomain*>(p);
  }
  return _impl_.listen_;
}
inline ::xray::common::net::IPOrDomain* ReceiverConfig::mutable_listen() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::IPOrDomain* _msg = _internal_mutable_listen();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.ReceiverConfig.listen)
  return _msg;
}
inline void ReceiverConfig::set_allocated_listen(::xray::common::net::IPOrDomain* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.listen_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.listen_ = reinterpret_cast<::xray::common::net::IPOrDomain*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.ReceiverConfig.listen)
}

// .xray.app.proxyman.AllocationStrategy allocation_strategy = 3;
inline bool ReceiverConfig::has_allocation_strategy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allocation_strategy_ != nullptr);
  return value;
}
inline void ReceiverConfig::clear_allocation_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.allocation_strategy_ != nullptr) _impl_.allocation_strategy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::xray::app::proxyman::AllocationStrategy& ReceiverConfig::_internal_allocation_strategy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::app::proxyman::AllocationStrategy* p = _impl_.allocation_strategy_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::app::proxyman::AllocationStrategy&>(::xray::app::proxyman::_AllocationStrategy_default_instance_);
}
inline const ::xray::app::proxyman::AllocationStrategy& ReceiverConfig::allocation_strategy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.ReceiverConfig.allocation_strategy)
  return _internal_allocation_strategy();
}
inline void ReceiverConfig::unsafe_arena_set_allocated_allocation_strategy(::xray::app::proxyman::AllocationStrategy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.allocation_strategy_);
  }
  _impl_.allocation_strategy_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.ReceiverConfig.allocation_strategy)
}
inline ::xray::app::proxyman::AllocationStrategy* ReceiverConfig::release_allocation_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::app::proxyman::AllocationStrategy* released = _impl_.allocation_strategy_;
  _impl_.allocation_strategy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::app::proxyman::AllocationStrategy* ReceiverConfig::unsafe_arena_release_allocation_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.ReceiverConfig.allocation_strategy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::app::proxyman::AllocationStrategy* temp = _impl_.allocation_strategy_;
  _impl_.allocation_strategy_ = nullptr;
  return temp;
}
inline ::xray::app::proxyman::AllocationStrategy* ReceiverConfig::_internal_mutable_allocation_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.allocation_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::app::proxyman::AllocationStrategy>(GetArena());
    _impl_.allocation_strategy_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy*>(p);
  }
  return _impl_.allocation_strategy_;
}
inline ::xray::app::proxyman::AllocationStrategy* ReceiverConfig::mutable_allocation_strategy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::app::proxyman::AllocationStrategy* _msg = _internal_mutable_allocation_strategy();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.ReceiverConfig.allocation_strategy)
  return _msg;
}
inline void ReceiverConfig::set_allocated_allocation_strategy(::xray::app::proxyman::AllocationStrategy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::app::proxyman::AllocationStrategy*>(_impl_.allocation_strategy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::app::proxyman::AllocationStrategy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.allocation_strategy_ = reinterpret_cast<::xray::app::proxyman::AllocationStrategy*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.ReceiverConfig.allocation_strategy)
}

// .xray.transport.internet.StreamConfig stream_settings = 4;
inline bool ReceiverConfig::has_stream_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_settings_ != nullptr);
  return value;
}
inline const ::xray::transport::internet::StreamConfig& ReceiverConfig::_internal_stream_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::StreamConfig* p = _impl_.stream_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::StreamConfig&>(::xray::transport::internet::_StreamConfig_default_instance_);
}
inline const ::xray::transport::internet::StreamConfig& ReceiverConfig::stream_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.ReceiverConfig.stream_settings)
  return _internal_stream_settings();
}
inline void ReceiverConfig::unsafe_arena_set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stream_settings_);
  }
  _impl_.stream_settings_ = reinterpret_cast<::xray::transport::internet::StreamConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.ReceiverConfig.stream_settings)
}
inline ::xray::transport::internet::StreamConfig* ReceiverConfig::release_stream_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::transport::internet::StreamConfig* released = _impl_.stream_settings_;
  _impl_.stream_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::StreamConfig* ReceiverConfig::unsafe_arena_release_stream_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.ReceiverConfig.stream_settings)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::transport::internet::StreamConfig* temp = _impl_.stream_settings_;
  _impl_.stream_settings_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::StreamConfig* ReceiverConfig::_internal_mutable_stream_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.stream_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::StreamConfig>(GetArena());
    _impl_.stream_settings_ = reinterpret_cast<::xray::transport::internet::StreamConfig*>(p);
  }
  return _impl_.stream_settings_;
}
inline ::xray::transport::internet::StreamConfig* ReceiverConfig::mutable_stream_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::StreamConfig* _msg = _internal_mutable_stream_settings();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.ReceiverConfig.stream_settings)
  return _msg;
}
inline void ReceiverConfig::set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stream_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.stream_settings_ = reinterpret_cast<::xray::transport::internet::StreamConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.ReceiverConfig.stream_settings)
}

// bool receive_original_destination = 5;
inline void ReceiverConfig::clear_receive_original_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receive_original_destination_ = false;
}
inline bool ReceiverConfig::receive_original_destination() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.ReceiverConfig.receive_original_destination)
  return _internal_receive_original_destination();
}
inline void ReceiverConfig::set_receive_original_destination(bool value) {
  _internal_set_receive_original_destination(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.ReceiverConfig.receive_original_destination)
}
inline bool ReceiverConfig::_internal_receive_original_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.receive_original_destination_;
}
inline void ReceiverConfig::_internal_set_receive_original_destination(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.receive_original_destination_ = value;
}

// repeated .xray.app.proxyman.KnownProtocols domain_override = 7 [deprecated = true];
inline int ReceiverConfig::_internal_domain_override_size() const {
  return _internal_domain_override().size();
}
inline int ReceiverConfig::domain_override_size() const {
  return _internal_domain_override_size();
}
inline void ReceiverConfig::clear_domain_override() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_override_.Clear();
}
inline ::xray::app::proxyman::KnownProtocols ReceiverConfig::domain_override(int index) const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.ReceiverConfig.domain_override)
  return static_cast<::xray::app::proxyman::KnownProtocols>(_internal_domain_override().Get(index));
}
inline void ReceiverConfig::set_domain_override(int index, ::xray::app::proxyman::KnownProtocols value) {
  _internal_mutable_domain_override()->Set(index, value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.ReceiverConfig.domain_override)
}
inline void ReceiverConfig::add_domain_override(::xray::app::proxyman::KnownProtocols value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain_override()->Add(value);
  // @@protoc_insertion_point(field_add:xray.app.proxyman.ReceiverConfig.domain_override)
}
inline const ::google::protobuf::RepeatedField<int>& ReceiverConfig::domain_override() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.proxyman.ReceiverConfig.domain_override)
  return _internal_domain_override();
}
inline ::google::protobuf::RepeatedField<int>* ReceiverConfig::mutable_domain_override()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.proxyman.ReceiverConfig.domain_override)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_domain_override();
}
inline const ::google::protobuf::RepeatedField<int>& ReceiverConfig::_internal_domain_override() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_override_;
}
inline ::google::protobuf::RepeatedField<int>* ReceiverConfig::_internal_mutable_domain_override() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.domain_override_;
}

// .xray.app.proxyman.SniffingConfig sniffing_settings = 8;
inline bool ReceiverConfig::has_sniffing_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sniffing_settings_ != nullptr);
  return value;
}
inline void ReceiverConfig::clear_sniffing_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sniffing_settings_ != nullptr) _impl_.sniffing_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::xray::app::proxyman::SniffingConfig& ReceiverConfig::_internal_sniffing_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::app::proxyman::SniffingConfig* p = _impl_.sniffing_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::app::proxyman::SniffingConfig&>(::xray::app::proxyman::_SniffingConfig_default_instance_);
}
inline const ::xray::app::proxyman::SniffingConfig& ReceiverConfig::sniffing_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.ReceiverConfig.sniffing_settings)
  return _internal_sniffing_settings();
}
inline void ReceiverConfig::unsafe_arena_set_allocated_sniffing_settings(::xray::app::proxyman::SniffingConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sniffing_settings_);
  }
  _impl_.sniffing_settings_ = reinterpret_cast<::xray::app::proxyman::SniffingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.ReceiverConfig.sniffing_settings)
}
inline ::xray::app::proxyman::SniffingConfig* ReceiverConfig::release_sniffing_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xray::app::proxyman::SniffingConfig* released = _impl_.sniffing_settings_;
  _impl_.sniffing_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::app::proxyman::SniffingConfig* ReceiverConfig::unsafe_arena_release_sniffing_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.ReceiverConfig.sniffing_settings)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::xray::app::proxyman::SniffingConfig* temp = _impl_.sniffing_settings_;
  _impl_.sniffing_settings_ = nullptr;
  return temp;
}
inline ::xray::app::proxyman::SniffingConfig* ReceiverConfig::_internal_mutable_sniffing_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.sniffing_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::app::proxyman::SniffingConfig>(GetArena());
    _impl_.sniffing_settings_ = reinterpret_cast<::xray::app::proxyman::SniffingConfig*>(p);
  }
  return _impl_.sniffing_settings_;
}
inline ::xray::app::proxyman::SniffingConfig* ReceiverConfig::mutable_sniffing_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::app::proxyman::SniffingConfig* _msg = _internal_mutable_sniffing_settings();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.ReceiverConfig.sniffing_settings)
  return _msg;
}
inline void ReceiverConfig::set_allocated_sniffing_settings(::xray::app::proxyman::SniffingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::app::proxyman::SniffingConfig*>(_impl_.sniffing_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::app::proxyman::SniffingConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.sniffing_settings_ = reinterpret_cast<::xray::app::proxyman::SniffingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.ReceiverConfig.sniffing_settings)
}

// -------------------------------------------------------------------

// InboundHandlerConfig

// string tag = 1;
inline void InboundHandlerConfig::clear_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& InboundHandlerConfig::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.InboundHandlerConfig.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InboundHandlerConfig::set_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.proxyman.InboundHandlerConfig.tag)
}
inline std::string* InboundHandlerConfig::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.InboundHandlerConfig.tag)
  return _s;
}
inline const std::string& InboundHandlerConfig::_internal_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tag_.Get();
}
inline void InboundHandlerConfig::_internal_set_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(value, GetArena());
}
inline std::string* InboundHandlerConfig::_internal_mutable_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tag_.Mutable( GetArena());
}
inline std::string* InboundHandlerConfig::release_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.InboundHandlerConfig.tag)
  return _impl_.tag_.Release();
}
inline void InboundHandlerConfig::set_allocated_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tag_.IsDefault()) {
          _impl_.tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.InboundHandlerConfig.tag)
}

// .xray.common.serial.TypedMessage receiver_settings = 2;
inline bool InboundHandlerConfig::has_receiver_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receiver_settings_ != nullptr);
  return value;
}
inline const ::xray::common::serial::TypedMessage& InboundHandlerConfig::_internal_receiver_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::serial::TypedMessage* p = _impl_.receiver_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::serial::TypedMessage&>(::xray::common::serial::_TypedMessage_default_instance_);
}
inline const ::xray::common::serial::TypedMessage& InboundHandlerConfig::receiver_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.InboundHandlerConfig.receiver_settings)
  return _internal_receiver_settings();
}
inline void InboundHandlerConfig::unsafe_arena_set_allocated_receiver_settings(::xray::common::serial::TypedMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receiver_settings_);
  }
  _impl_.receiver_settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.InboundHandlerConfig.receiver_settings)
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::release_receiver_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::serial::TypedMessage* released = _impl_.receiver_settings_;
  _impl_.receiver_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::unsafe_arena_release_receiver_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.InboundHandlerConfig.receiver_settings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::serial::TypedMessage* temp = _impl_.receiver_settings_;
  _impl_.receiver_settings_ = nullptr;
  return temp;
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::_internal_mutable_receiver_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.receiver_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::serial::TypedMessage>(GetArena());
    _impl_.receiver_settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(p);
  }
  return _impl_.receiver_settings_;
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::mutable_receiver_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::serial::TypedMessage* _msg = _internal_mutable_receiver_settings();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.InboundHandlerConfig.receiver_settings)
  return _msg;
}
inline void InboundHandlerConfig::set_allocated_receiver_settings(::xray::common::serial::TypedMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receiver_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.receiver_settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.InboundHandlerConfig.receiver_settings)
}

// .xray.common.serial.TypedMessage proxy_settings = 3;
inline bool InboundHandlerConfig::has_proxy_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proxy_settings_ != nullptr);
  return value;
}
inline const ::xray::common::serial::TypedMessage& InboundHandlerConfig::_internal_proxy_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::serial::TypedMessage* p = _impl_.proxy_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::serial::TypedMessage&>(::xray::common::serial::_TypedMessage_default_instance_);
}
inline const ::xray::common::serial::TypedMessage& InboundHandlerConfig::proxy_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.InboundHandlerConfig.proxy_settings)
  return _internal_proxy_settings();
}
inline void InboundHandlerConfig::unsafe_arena_set_allocated_proxy_settings(::xray::common::serial::TypedMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_settings_);
  }
  _impl_.proxy_settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.InboundHandlerConfig.proxy_settings)
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::release_proxy_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::common::serial::TypedMessage* released = _impl_.proxy_settings_;
  _impl_.proxy_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::unsafe_arena_release_proxy_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.InboundHandlerConfig.proxy_settings)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::common::serial::TypedMessage* temp = _impl_.proxy_settings_;
  _impl_.proxy_settings_ = nullptr;
  return temp;
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::_internal_mutable_proxy_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.proxy_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::serial::TypedMessage>(GetArena());
    _impl_.proxy_settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(p);
  }
  return _impl_.proxy_settings_;
}
inline ::xray::common::serial::TypedMessage* InboundHandlerConfig::mutable_proxy_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::serial::TypedMessage* _msg = _internal_mutable_proxy_settings();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.InboundHandlerConfig.proxy_settings)
  return _msg;
}
inline void InboundHandlerConfig::set_allocated_proxy_settings(::xray::common::serial::TypedMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.proxy_settings_ = reinterpret_cast<::xray::common::serial::TypedMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.InboundHandlerConfig.proxy_settings)
}

// -------------------------------------------------------------------

// OutboundConfig

// -------------------------------------------------------------------

// SenderConfig

// .xray.common.net.IPOrDomain via = 1;
inline bool SenderConfig::has_via() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.via_ != nullptr);
  return value;
}
inline const ::xray::common::net::IPOrDomain& SenderConfig::_internal_via() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::IPOrDomain* p = _impl_.via_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::IPOrDomain&>(::xray::common::net::_IPOrDomain_default_instance_);
}
inline const ::xray::common::net::IPOrDomain& SenderConfig::via() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SenderConfig.via)
  return _internal_via();
}
inline void SenderConfig::unsafe_arena_set_allocated_via(::xray::common::net::IPOrDomain* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.via_);
  }
  _impl_.via_ = reinterpret_cast<::xray::common::net::IPOrDomain*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.SenderConfig.via)
}
inline ::xray::common::net::IPOrDomain* SenderConfig::release_via() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::IPOrDomain* released = _impl_.via_;
  _impl_.via_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::IPOrDomain* SenderConfig::unsafe_arena_release_via() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.SenderConfig.via)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::IPOrDomain* temp = _impl_.via_;
  _impl_.via_ = nullptr;
  return temp;
}
inline ::xray::common::net::IPOrDomain* SenderConfig::_internal_mutable_via() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.via_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::IPOrDomain>(GetArena());
    _impl_.via_ = reinterpret_cast<::xray::common::net::IPOrDomain*>(p);
  }
  return _impl_.via_;
}
inline ::xray::common::net::IPOrDomain* SenderConfig::mutable_via() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::IPOrDomain* _msg = _internal_mutable_via();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.SenderConfig.via)
  return _msg;
}
inline void SenderConfig::set_allocated_via(::xray::common::net::IPOrDomain* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.via_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.via_ = reinterpret_cast<::xray::common::net::IPOrDomain*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.SenderConfig.via)
}

// .xray.transport.internet.StreamConfig stream_settings = 2;
inline bool SenderConfig::has_stream_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_settings_ != nullptr);
  return value;
}
inline const ::xray::transport::internet::StreamConfig& SenderConfig::_internal_stream_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::StreamConfig* p = _impl_.stream_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::StreamConfig&>(::xray::transport::internet::_StreamConfig_default_instance_);
}
inline const ::xray::transport::internet::StreamConfig& SenderConfig::stream_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SenderConfig.stream_settings)
  return _internal_stream_settings();
}
inline void SenderConfig::unsafe_arena_set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stream_settings_);
  }
  _impl_.stream_settings_ = reinterpret_cast<::xray::transport::internet::StreamConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.SenderConfig.stream_settings)
}
inline ::xray::transport::internet::StreamConfig* SenderConfig::release_stream_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::transport::internet::StreamConfig* released = _impl_.stream_settings_;
  _impl_.stream_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::StreamConfig* SenderConfig::unsafe_arena_release_stream_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.SenderConfig.stream_settings)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::transport::internet::StreamConfig* temp = _impl_.stream_settings_;
  _impl_.stream_settings_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::StreamConfig* SenderConfig::_internal_mutable_stream_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::StreamConfig>(GetArena());
    _impl_.stream_settings_ = reinterpret_cast<::xray::transport::internet::StreamConfig*>(p);
  }
  return _impl_.stream_settings_;
}
inline ::xray::transport::internet::StreamConfig* SenderConfig::mutable_stream_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::StreamConfig* _msg = _internal_mutable_stream_settings();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.SenderConfig.stream_settings)
  return _msg;
}
inline void SenderConfig::set_allocated_stream_settings(::xray::transport::internet::StreamConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stream_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.stream_settings_ = reinterpret_cast<::xray::transport::internet::StreamConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.SenderConfig.stream_settings)
}

// .xray.transport.internet.ProxyConfig proxy_settings = 3;
inline bool SenderConfig::has_proxy_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proxy_settings_ != nullptr);
  return value;
}
inline const ::xray::transport::internet::ProxyConfig& SenderConfig::_internal_proxy_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::transport::internet::ProxyConfig* p = _impl_.proxy_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::transport::internet::ProxyConfig&>(::xray::transport::internet::_ProxyConfig_default_instance_);
}
inline const ::xray::transport::internet::ProxyConfig& SenderConfig::proxy_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SenderConfig.proxy_settings)
  return _internal_proxy_settings();
}
inline void SenderConfig::unsafe_arena_set_allocated_proxy_settings(::xray::transport::internet::ProxyConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_settings_);
  }
  _impl_.proxy_settings_ = reinterpret_cast<::xray::transport::internet::ProxyConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.SenderConfig.proxy_settings)
}
inline ::xray::transport::internet::ProxyConfig* SenderConfig::release_proxy_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::transport::internet::ProxyConfig* released = _impl_.proxy_settings_;
  _impl_.proxy_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::transport::internet::ProxyConfig* SenderConfig::unsafe_arena_release_proxy_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.SenderConfig.proxy_settings)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::transport::internet::ProxyConfig* temp = _impl_.proxy_settings_;
  _impl_.proxy_settings_ = nullptr;
  return temp;
}
inline ::xray::transport::internet::ProxyConfig* SenderConfig::_internal_mutable_proxy_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.proxy_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::transport::internet::ProxyConfig>(GetArena());
    _impl_.proxy_settings_ = reinterpret_cast<::xray::transport::internet::ProxyConfig*>(p);
  }
  return _impl_.proxy_settings_;
}
inline ::xray::transport::internet::ProxyConfig* SenderConfig::mutable_proxy_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::transport::internet::ProxyConfig* _msg = _internal_mutable_proxy_settings();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.SenderConfig.proxy_settings)
  return _msg;
}
inline void SenderConfig::set_allocated_proxy_settings(::xray::transport::internet::ProxyConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.proxy_settings_ = reinterpret_cast<::xray::transport::internet::ProxyConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.SenderConfig.proxy_settings)
}

// .xray.app.proxyman.MultiplexingConfig multiplex_settings = 4;
inline bool SenderConfig::has_multiplex_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multiplex_settings_ != nullptr);
  return value;
}
inline void SenderConfig::clear_multiplex_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.multiplex_settings_ != nullptr) _impl_.multiplex_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::xray::app::proxyman::MultiplexingConfig& SenderConfig::_internal_multiplex_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::app::proxyman::MultiplexingConfig* p = _impl_.multiplex_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::app::proxyman::MultiplexingConfig&>(::xray::app::proxyman::_MultiplexingConfig_default_instance_);
}
inline const ::xray::app::proxyman::MultiplexingConfig& SenderConfig::multiplex_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SenderConfig.multiplex_settings)
  return _internal_multiplex_settings();
}
inline void SenderConfig::unsafe_arena_set_allocated_multiplex_settings(::xray::app::proxyman::MultiplexingConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.multiplex_settings_);
  }
  _impl_.multiplex_settings_ = reinterpret_cast<::xray::app::proxyman::MultiplexingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.proxyman.SenderConfig.multiplex_settings)
}
inline ::xray::app::proxyman::MultiplexingConfig* SenderConfig::release_multiplex_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::app::proxyman::MultiplexingConfig* released = _impl_.multiplex_settings_;
  _impl_.multiplex_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::app::proxyman::MultiplexingConfig* SenderConfig::unsafe_arena_release_multiplex_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.SenderConfig.multiplex_settings)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::app::proxyman::MultiplexingConfig* temp = _impl_.multiplex_settings_;
  _impl_.multiplex_settings_ = nullptr;
  return temp;
}
inline ::xray::app::proxyman::MultiplexingConfig* SenderConfig::_internal_mutable_multiplex_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.multiplex_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::app::proxyman::MultiplexingConfig>(GetArena());
    _impl_.multiplex_settings_ = reinterpret_cast<::xray::app::proxyman::MultiplexingConfig*>(p);
  }
  return _impl_.multiplex_settings_;
}
inline ::xray::app::proxyman::MultiplexingConfig* SenderConfig::mutable_multiplex_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::app::proxyman::MultiplexingConfig* _msg = _internal_mutable_multiplex_settings();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.SenderConfig.multiplex_settings)
  return _msg;
}
inline void SenderConfig::set_allocated_multiplex_settings(::xray::app::proxyman::MultiplexingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::xray::app::proxyman::MultiplexingConfig*>(_impl_.multiplex_settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::xray::app::proxyman::MultiplexingConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.multiplex_settings_ = reinterpret_cast<::xray::app::proxyman::MultiplexingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.SenderConfig.multiplex_settings)
}

// string via_cidr = 5;
inline void SenderConfig::clear_via_cidr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.via_cidr_.ClearToEmpty();
}
inline const std::string& SenderConfig::via_cidr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.SenderConfig.via_cidr)
  return _internal_via_cidr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SenderConfig::set_via_cidr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.via_cidr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.proxyman.SenderConfig.via_cidr)
}
inline std::string* SenderConfig::mutable_via_cidr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_via_cidr();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.SenderConfig.via_cidr)
  return _s;
}
inline const std::string& SenderConfig::_internal_via_cidr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.via_cidr_.Get();
}
inline void SenderConfig::_internal_set_via_cidr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.via_cidr_.Set(value, GetArena());
}
inline std::string* SenderConfig::_internal_mutable_via_cidr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.via_cidr_.Mutable( GetArena());
}
inline std::string* SenderConfig::release_via_cidr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.SenderConfig.via_cidr)
  return _impl_.via_cidr_.Release();
}
inline void SenderConfig::set_allocated_via_cidr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.via_cidr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.via_cidr_.IsDefault()) {
          _impl_.via_cidr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.SenderConfig.via_cidr)
}

// -------------------------------------------------------------------

// MultiplexingConfig

// bool enabled = 1;
inline void MultiplexingConfig::clear_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = false;
}
inline bool MultiplexingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.MultiplexingConfig.enabled)
  return _internal_enabled();
}
inline void MultiplexingConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.MultiplexingConfig.enabled)
}
inline bool MultiplexingConfig::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void MultiplexingConfig::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enabled_ = value;
}

// int32 concurrency = 2;
inline void MultiplexingConfig::clear_concurrency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.concurrency_ = 0;
}
inline ::int32_t MultiplexingConfig::concurrency() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.MultiplexingConfig.concurrency)
  return _internal_concurrency();
}
inline void MultiplexingConfig::set_concurrency(::int32_t value) {
  _internal_set_concurrency(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.MultiplexingConfig.concurrency)
}
inline ::int32_t MultiplexingConfig::_internal_concurrency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.concurrency_;
}
inline void MultiplexingConfig::_internal_set_concurrency(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.concurrency_ = value;
}

// int32 xudpConcurrency = 3;
inline void MultiplexingConfig::clear_xudpconcurrency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.xudpconcurrency_ = 0;
}
inline ::int32_t MultiplexingConfig::xudpconcurrency() const {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.MultiplexingConfig.xudpConcurrency)
  return _internal_xudpconcurrency();
}
inline void MultiplexingConfig::set_xudpconcurrency(::int32_t value) {
  _internal_set_xudpconcurrency(value);
  // @@protoc_insertion_point(field_set:xray.app.proxyman.MultiplexingConfig.xudpConcurrency)
}
inline ::int32_t MultiplexingConfig::_internal_xudpconcurrency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.xudpconcurrency_;
}
inline void MultiplexingConfig::_internal_set_xudpconcurrency(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.xudpconcurrency_ = value;
}

// string xudpProxyUDP443 = 4;
inline void MultiplexingConfig::clear_xudpproxyudp443() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.xudpproxyudp443_.ClearToEmpty();
}
inline const std::string& MultiplexingConfig::xudpproxyudp443() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.proxyman.MultiplexingConfig.xudpProxyUDP443)
  return _internal_xudpproxyudp443();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MultiplexingConfig::set_xudpproxyudp443(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.xudpproxyudp443_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.proxyman.MultiplexingConfig.xudpProxyUDP443)
}
inline std::string* MultiplexingConfig::mutable_xudpproxyudp443() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_xudpproxyudp443();
  // @@protoc_insertion_point(field_mutable:xray.app.proxyman.MultiplexingConfig.xudpProxyUDP443)
  return _s;
}
inline const std::string& MultiplexingConfig::_internal_xudpproxyudp443() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.xudpproxyudp443_.Get();
}
inline void MultiplexingConfig::_internal_set_xudpproxyudp443(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.xudpproxyudp443_.Set(value, GetArena());
}
inline std::string* MultiplexingConfig::_internal_mutable_xudpproxyudp443() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.xudpproxyudp443_.Mutable( GetArena());
}
inline std::string* MultiplexingConfig::release_xudpproxyudp443() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.proxyman.MultiplexingConfig.xudpProxyUDP443)
  return _impl_.xudpproxyudp443_.Release();
}
inline void MultiplexingConfig::set_allocated_xudpproxyudp443(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.xudpproxyudp443_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.xudpproxyudp443_.IsDefault()) {
          _impl_.xudpproxyudp443_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.proxyman.MultiplexingConfig.xudpProxyUDP443)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proxyman
}  // namespace app
}  // namespace xray


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::xray::app::proxyman::AllocationStrategy_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::app::proxyman::AllocationStrategy_Type>() {
  return ::xray::app::proxyman::AllocationStrategy_Type_descriptor();
}
template <>
struct is_proto_enum<::xray::app::proxyman::KnownProtocols> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::app::proxyman::KnownProtocols>() {
  return ::xray::app::proxyman::KnownProtocols_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_app_2fproxyman_2fconfig_2eproto_2epb_2eh
