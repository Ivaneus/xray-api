// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/dns/config.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2fdns_2fconfig_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_app_2fdns_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common/net/address.pb.h"
#include "common/net/destination.pb.h"
#include "app/router/config.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_app_2fdns_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2fdns_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_app_2fdns_2fconfig_2eproto;
namespace xray {
namespace app {
namespace dns {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Config_HostMapping;
struct Config_HostMappingDefaultTypeInternal;
extern Config_HostMappingDefaultTypeInternal _Config_HostMapping_default_instance_;
class Config_HostsEntry_DoNotUse;
struct Config_HostsEntry_DoNotUseDefaultTypeInternal;
extern Config_HostsEntry_DoNotUseDefaultTypeInternal _Config_HostsEntry_DoNotUse_default_instance_;
class NameServer;
struct NameServerDefaultTypeInternal;
extern NameServerDefaultTypeInternal _NameServer_default_instance_;
class NameServer_OriginalRule;
struct NameServer_OriginalRuleDefaultTypeInternal;
extern NameServer_OriginalRuleDefaultTypeInternal _NameServer_OriginalRule_default_instance_;
class NameServer_PriorityDomain;
struct NameServer_PriorityDomainDefaultTypeInternal;
extern NameServer_PriorityDomainDefaultTypeInternal _NameServer_PriorityDomain_default_instance_;
}  // namespace dns
}  // namespace app
}  // namespace xray
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xray {
namespace app {
namespace dns {
enum DomainMatchingType : int {
  Full = 0,
  Subdomain = 1,
  Keyword = 2,
  Regex = 3,
  DomainMatchingType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DomainMatchingType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DomainMatchingType_IsValid(int value);
extern const uint32_t DomainMatchingType_internal_data_[];
constexpr DomainMatchingType DomainMatchingType_MIN = static_cast<DomainMatchingType>(0);
constexpr DomainMatchingType DomainMatchingType_MAX = static_cast<DomainMatchingType>(3);
constexpr int DomainMatchingType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DomainMatchingType_descriptor();
template <typename T>
const std::string& DomainMatchingType_Name(T value) {
  static_assert(std::is_same<T, DomainMatchingType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DomainMatchingType_Name().");
  return DomainMatchingType_Name(static_cast<DomainMatchingType>(value));
}
template <>
inline const std::string& DomainMatchingType_Name(DomainMatchingType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DomainMatchingType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DomainMatchingType_Parse(absl::string_view name, DomainMatchingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DomainMatchingType>(
      DomainMatchingType_descriptor(), name, value);
}
enum QueryStrategy : int {
  USE_IP = 0,
  USE_IP4 = 1,
  USE_IP6 = 2,
  QueryStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  QueryStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool QueryStrategy_IsValid(int value);
extern const uint32_t QueryStrategy_internal_data_[];
constexpr QueryStrategy QueryStrategy_MIN = static_cast<QueryStrategy>(0);
constexpr QueryStrategy QueryStrategy_MAX = static_cast<QueryStrategy>(2);
constexpr int QueryStrategy_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
QueryStrategy_descriptor();
template <typename T>
const std::string& QueryStrategy_Name(T value) {
  static_assert(std::is_same<T, QueryStrategy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to QueryStrategy_Name().");
  return QueryStrategy_Name(static_cast<QueryStrategy>(value));
}
template <>
inline const std::string& QueryStrategy_Name(QueryStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<QueryStrategy_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool QueryStrategy_Parse(absl::string_view name, QueryStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryStrategy>(
      QueryStrategy_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class NameServer_PriorityDomain final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.dns.NameServer.PriorityDomain) */ {
 public:
  inline NameServer_PriorityDomain() : NameServer_PriorityDomain(nullptr) {}
  ~NameServer_PriorityDomain() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NameServer_PriorityDomain(::google::protobuf::internal::ConstantInitialized);

  inline NameServer_PriorityDomain(const NameServer_PriorityDomain& from)
      : NameServer_PriorityDomain(nullptr, from) {}
  NameServer_PriorityDomain(NameServer_PriorityDomain&& from) noexcept
    : NameServer_PriorityDomain() {
    *this = ::std::move(from);
  }

  inline NameServer_PriorityDomain& operator=(const NameServer_PriorityDomain& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameServer_PriorityDomain& operator=(NameServer_PriorityDomain&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NameServer_PriorityDomain& default_instance() {
    return *internal_default_instance();
  }
  static inline const NameServer_PriorityDomain* internal_default_instance() {
    return reinterpret_cast<const NameServer_PriorityDomain*>(
               &_NameServer_PriorityDomain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NameServer_PriorityDomain& a, NameServer_PriorityDomain& b) {
    a.Swap(&b);
  }
  inline void Swap(NameServer_PriorityDomain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameServer_PriorityDomain* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NameServer_PriorityDomain* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NameServer_PriorityDomain>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NameServer_PriorityDomain& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NameServer_PriorityDomain& from) {
    NameServer_PriorityDomain::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NameServer_PriorityDomain* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.dns.NameServer.PriorityDomain";
  }
  protected:
  explicit NameServer_PriorityDomain(::google::protobuf::Arena* arena);
  NameServer_PriorityDomain(::google::protobuf::Arena* arena, const NameServer_PriorityDomain& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string domain = 2;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // .xray.app.dns.DomainMatchingType type = 1;
  void clear_type() ;
  ::xray::app::dns::DomainMatchingType type() const;
  void set_type(::xray::app::dns::DomainMatchingType value);

  private:
  ::xray::app::dns::DomainMatchingType _internal_type() const;
  void _internal_set_type(::xray::app::dns::DomainMatchingType value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.dns.NameServer.PriorityDomain)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr domain_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdns_2fconfig_2eproto;
};// -------------------------------------------------------------------

class NameServer_OriginalRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.dns.NameServer.OriginalRule) */ {
 public:
  inline NameServer_OriginalRule() : NameServer_OriginalRule(nullptr) {}
  ~NameServer_OriginalRule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NameServer_OriginalRule(::google::protobuf::internal::ConstantInitialized);

  inline NameServer_OriginalRule(const NameServer_OriginalRule& from)
      : NameServer_OriginalRule(nullptr, from) {}
  NameServer_OriginalRule(NameServer_OriginalRule&& from) noexcept
    : NameServer_OriginalRule() {
    *this = ::std::move(from);
  }

  inline NameServer_OriginalRule& operator=(const NameServer_OriginalRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameServer_OriginalRule& operator=(NameServer_OriginalRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NameServer_OriginalRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const NameServer_OriginalRule* internal_default_instance() {
    return reinterpret_cast<const NameServer_OriginalRule*>(
               &_NameServer_OriginalRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NameServer_OriginalRule& a, NameServer_OriginalRule& b) {
    a.Swap(&b);
  }
  inline void Swap(NameServer_OriginalRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameServer_OriginalRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NameServer_OriginalRule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NameServer_OriginalRule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NameServer_OriginalRule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NameServer_OriginalRule& from) {
    NameServer_OriginalRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NameServer_OriginalRule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.dns.NameServer.OriginalRule";
  }
  protected:
  explicit NameServer_OriginalRule(::google::protobuf::Arena* arena);
  NameServer_OriginalRule(::google::protobuf::Arena* arena, const NameServer_OriginalRule& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // string rule = 1;
  void clear_rule() ;
  const std::string& rule() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule(Arg_&& arg, Args_... args);
  std::string* mutable_rule();
  PROTOBUF_NODISCARD std::string* release_rule();
  void set_allocated_rule(std::string* value);

  private:
  const std::string& _internal_rule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule(
      const std::string& value);
  std::string* _internal_mutable_rule();

  public:
  // uint32 size = 2;
  void clear_size() ;
  ::uint32_t size() const;
  void set_size(::uint32_t value);

  private:
  ::uint32_t _internal_size() const;
  void _internal_set_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.dns.NameServer.OriginalRule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr rule_;
    ::uint32_t size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdns_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Config_HostMapping final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.dns.Config.HostMapping) */ {
 public:
  inline Config_HostMapping() : Config_HostMapping(nullptr) {}
  ~Config_HostMapping() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Config_HostMapping(::google::protobuf::internal::ConstantInitialized);

  inline Config_HostMapping(const Config_HostMapping& from)
      : Config_HostMapping(nullptr, from) {}
  Config_HostMapping(Config_HostMapping&& from) noexcept
    : Config_HostMapping() {
    *this = ::std::move(from);
  }

  inline Config_HostMapping& operator=(const Config_HostMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_HostMapping& operator=(Config_HostMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_HostMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config_HostMapping* internal_default_instance() {
    return reinterpret_cast<const Config_HostMapping*>(
               &_Config_HostMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Config_HostMapping& a, Config_HostMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(Config_HostMapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_HostMapping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_HostMapping* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config_HostMapping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_HostMapping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Config_HostMapping& from) {
    Config_HostMapping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Config_HostMapping* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.dns.Config.HostMapping";
  }
  protected:
  explicit Config_HostMapping(::google::protobuf::Arena* arena);
  Config_HostMapping(::google::protobuf::Arena* arena, const Config_HostMapping& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 3,
    kDomainFieldNumber = 2,
    kProxiedDomainFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated bytes ip = 3;
  int ip_size() const;
  private:
  int _internal_ip_size() const;

  public:
  void clear_ip() ;
  const std::string& ip(int index) const;
  std::string* mutable_ip(int index);
  void set_ip(int index, const std::string& value);
  void set_ip(int index, std::string&& value);
  void set_ip(int index, const char* value);
  void set_ip(int index, const void* value, std::size_t size);
  void set_ip(int index, absl::string_view value);
  std::string* add_ip();
  void add_ip(const std::string& value);
  void add_ip(std::string&& value);
  void add_ip(const char* value);
  void add_ip(const void* value, std::size_t size);
  void add_ip(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& ip() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_ip();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_ip() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_ip();

  public:
  // string domain = 2;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // string proxied_domain = 4;
  void clear_proxied_domain() ;
  const std::string& proxied_domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proxied_domain(Arg_&& arg, Args_... args);
  std::string* mutable_proxied_domain();
  PROTOBUF_NODISCARD std::string* release_proxied_domain();
  void set_allocated_proxied_domain(std::string* value);

  private:
  const std::string& _internal_proxied_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxied_domain(
      const std::string& value);
  std::string* _internal_mutable_proxied_domain();

  public:
  // .xray.app.dns.DomainMatchingType type = 1;
  void clear_type() ;
  ::xray::app::dns::DomainMatchingType type() const;
  void set_type(::xray::app::dns::DomainMatchingType value);

  private:
  ::xray::app::dns::DomainMatchingType _internal_type() const;
  void _internal_set_type(::xray::app::dns::DomainMatchingType value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.dns.Config.HostMapping)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> ip_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::google::protobuf::internal::ArenaStringPtr proxied_domain_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdns_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Config_HostsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Config_HostsEntry_DoNotUse, std::string, ::xray::common::net::IPOrDomain,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Config_HostsEntry_DoNotUse, std::string, ::xray::common::net::IPOrDomain,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Config_HostsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_HostsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Config_HostsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Config_HostsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Config_HostsEntry_DoNotUse*>(
        &_Config_HostsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "xray.app.dns.Config.HostsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2fdns_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class NameServer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.dns.NameServer) */ {
 public:
  inline NameServer() : NameServer(nullptr) {}
  ~NameServer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NameServer(::google::protobuf::internal::ConstantInitialized);

  inline NameServer(const NameServer& from)
      : NameServer(nullptr, from) {}
  NameServer(NameServer&& from) noexcept
    : NameServer() {
    *this = ::std::move(from);
  }

  inline NameServer& operator=(const NameServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameServer& operator=(NameServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NameServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const NameServer* internal_default_instance() {
    return reinterpret_cast<const NameServer*>(
               &_NameServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NameServer& a, NameServer& b) {
    a.Swap(&b);
  }
  inline void Swap(NameServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameServer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NameServer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NameServer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NameServer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NameServer& from) {
    NameServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NameServer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.dns.NameServer";
  }
  protected:
  explicit NameServer(::google::protobuf::Arena* arena);
  NameServer(::google::protobuf::Arena* arena, const NameServer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using PriorityDomain = NameServer_PriorityDomain;
  using OriginalRule = NameServer_OriginalRule;

  // accessors -------------------------------------------------------

  enum : int {
    kPrioritizedDomainFieldNumber = 2,
    kGeoipFieldNumber = 3,
    kOriginalRulesFieldNumber = 4,
    kClientIpFieldNumber = 5,
    kAddressFieldNumber = 1,
    kSkipFallbackFieldNumber = 6,
    kQueryStrategyFieldNumber = 7,
  };
  // repeated .xray.app.dns.NameServer.PriorityDomain prioritized_domain = 2;
  int prioritized_domain_size() const;
  private:
  int _internal_prioritized_domain_size() const;

  public:
  void clear_prioritized_domain() ;
  ::xray::app::dns::NameServer_PriorityDomain* mutable_prioritized_domain(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer_PriorityDomain >*
      mutable_prioritized_domain();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_PriorityDomain>& _internal_prioritized_domain() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_PriorityDomain>* _internal_mutable_prioritized_domain();
  public:
  const ::xray::app::dns::NameServer_PriorityDomain& prioritized_domain(int index) const;
  ::xray::app::dns::NameServer_PriorityDomain* add_prioritized_domain();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer_PriorityDomain >&
      prioritized_domain() const;
  // repeated .xray.app.router.GeoIP geoip = 3;
  int geoip_size() const;
  private:
  int _internal_geoip_size() const;

  public:
  void clear_geoip() ;
  ::xray::app::router::GeoIP* mutable_geoip(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >*
      mutable_geoip();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& _internal_geoip() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* _internal_mutable_geoip();
  public:
  const ::xray::app::router::GeoIP& geoip(int index) const;
  ::xray::app::router::GeoIP* add_geoip();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >&
      geoip() const;
  // repeated .xray.app.dns.NameServer.OriginalRule original_rules = 4;
  int original_rules_size() const;
  private:
  int _internal_original_rules_size() const;

  public:
  void clear_original_rules() ;
  ::xray::app::dns::NameServer_OriginalRule* mutable_original_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer_OriginalRule >*
      mutable_original_rules();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_OriginalRule>& _internal_original_rules() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_OriginalRule>* _internal_mutable_original_rules();
  public:
  const ::xray::app::dns::NameServer_OriginalRule& original_rules(int index) const;
  ::xray::app::dns::NameServer_OriginalRule* add_original_rules();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer_OriginalRule >&
      original_rules() const;
  // bytes client_ip = 5;
  void clear_client_ip() ;
  const std::string& client_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_ip(Arg_&& arg, Args_... args);
  std::string* mutable_client_ip();
  PROTOBUF_NODISCARD std::string* release_client_ip();
  void set_allocated_client_ip(std::string* value);

  private:
  const std::string& _internal_client_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_ip(
      const std::string& value);
  std::string* _internal_mutable_client_ip();

  public:
  // .xray.common.net.Endpoint address = 1;
  bool has_address() const;
  void clear_address() ;
  const ::xray::common::net::Endpoint& address() const;
  PROTOBUF_NODISCARD ::xray::common::net::Endpoint* release_address();
  ::xray::common::net::Endpoint* mutable_address();
  void set_allocated_address(::xray::common::net::Endpoint* value);
  void unsafe_arena_set_allocated_address(::xray::common::net::Endpoint* value);
  ::xray::common::net::Endpoint* unsafe_arena_release_address();

  private:
  const ::xray::common::net::Endpoint& _internal_address() const;
  ::xray::common::net::Endpoint* _internal_mutable_address();

  public:
  // bool skipFallback = 6;
  void clear_skipfallback() ;
  bool skipfallback() const;
  void set_skipfallback(bool value);

  private:
  bool _internal_skipfallback() const;
  void _internal_set_skipfallback(bool value);

  public:
  // .xray.app.dns.QueryStrategy query_strategy = 7;
  void clear_query_strategy() ;
  ::xray::app::dns::QueryStrategy query_strategy() const;
  void set_query_strategy(::xray::app::dns::QueryStrategy value);

  private:
  ::xray::app::dns::QueryStrategy _internal_query_strategy() const;
  void _internal_set_query_strategy(::xray::app::dns::QueryStrategy value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.dns.NameServer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer_PriorityDomain > prioritized_domain_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP > geoip_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer_OriginalRule > original_rules_;
    ::google::protobuf::internal::ArenaStringPtr client_ip_;
    ::xray::common::net::Endpoint* address_;
    bool skipfallback_;
    int query_strategy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdns_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.dns.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Config(::google::protobuf::internal::ConstantInitialized);

  inline Config(const Config& from)
      : Config(nullptr, from) {}
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.dns.Config";
  }
  protected:
  explicit Config(::google::protobuf::Arena* arena);
  Config(::google::protobuf::Arena* arena, const Config& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using HostMapping = Config_HostMapping;

  // accessors -------------------------------------------------------

  enum : int {
    kNameServersFieldNumber = 1,
    kHostsFieldNumber = 2,
    kStaticHostsFieldNumber = 4,
    kNameServerFieldNumber = 5,
    kClientIpFieldNumber = 3,
    kTagFieldNumber = 6,
    kQueryStrategyFieldNumber = 9,
    kDisableCacheFieldNumber = 8,
    kDisableFallbackFieldNumber = 10,
    kDisableFallbackIfMatchFieldNumber = 11,
  };
  // repeated .xray.common.net.Endpoint NameServers = 1 [deprecated = true];
  [[deprecated]]  int nameservers_size() const;
  private:
  int _internal_nameservers_size() const;

  public:
  [[deprecated]]  void clear_nameservers() ;
  [[deprecated]] ::xray::common::net::Endpoint* mutable_nameservers(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::xray::common::net::Endpoint >*
      mutable_nameservers();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::common::net::Endpoint>& _internal_nameservers() const;
  ::google::protobuf::RepeatedPtrField<::xray::common::net::Endpoint>* _internal_mutable_nameservers();
  public:
  [[deprecated]] const ::xray::common::net::Endpoint& nameservers(int index) const;
  [[deprecated]] ::xray::common::net::Endpoint* add_nameservers();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::xray::common::net::Endpoint >&
      nameservers() const;
  // map<string, .xray.common.net.IPOrDomain> Hosts = 2 [deprecated = true];
  [[deprecated]]  int hosts_size() const;
  private:
  int _internal_hosts_size() const;

  public:
  [[deprecated]]  void clear_hosts() ;
  [[deprecated]] const ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>& hosts() const;
  [[deprecated]] ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>* mutable_hosts();

  private:
  const ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>& _internal_hosts() const;
  ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>* _internal_mutable_hosts();

  public:
  // repeated .xray.app.dns.Config.HostMapping static_hosts = 4;
  int static_hosts_size() const;
  private:
  int _internal_static_hosts_size() const;

  public:
  void clear_static_hosts() ;
  ::xray::app::dns::Config_HostMapping* mutable_static_hosts(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::dns::Config_HostMapping >*
      mutable_static_hosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::dns::Config_HostMapping>& _internal_static_hosts() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::dns::Config_HostMapping>* _internal_mutable_static_hosts();
  public:
  const ::xray::app::dns::Config_HostMapping& static_hosts(int index) const;
  ::xray::app::dns::Config_HostMapping* add_static_hosts();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::dns::Config_HostMapping >&
      static_hosts() const;
  // repeated .xray.app.dns.NameServer name_server = 5;
  int name_server_size() const;
  private:
  int _internal_name_server_size() const;

  public:
  void clear_name_server() ;
  ::xray::app::dns::NameServer* mutable_name_server(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer >*
      mutable_name_server();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer>& _internal_name_server() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer>* _internal_mutable_name_server();
  public:
  const ::xray::app::dns::NameServer& name_server(int index) const;
  ::xray::app::dns::NameServer* add_name_server();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer >&
      name_server() const;
  // bytes client_ip = 3;
  void clear_client_ip() ;
  const std::string& client_ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_ip(Arg_&& arg, Args_... args);
  std::string* mutable_client_ip();
  PROTOBUF_NODISCARD std::string* release_client_ip();
  void set_allocated_client_ip(std::string* value);

  private:
  const std::string& _internal_client_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_ip(
      const std::string& value);
  std::string* _internal_mutable_client_ip();

  public:
  // string tag = 6;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // .xray.app.dns.QueryStrategy query_strategy = 9;
  void clear_query_strategy() ;
  ::xray::app::dns::QueryStrategy query_strategy() const;
  void set_query_strategy(::xray::app::dns::QueryStrategy value);

  private:
  ::xray::app::dns::QueryStrategy _internal_query_strategy() const;
  void _internal_set_query_strategy(::xray::app::dns::QueryStrategy value);

  public:
  // bool disableCache = 8;
  void clear_disablecache() ;
  bool disablecache() const;
  void set_disablecache(bool value);

  private:
  bool _internal_disablecache() const;
  void _internal_set_disablecache(bool value);

  public:
  // bool disableFallback = 10;
  void clear_disablefallback() ;
  bool disablefallback() const;
  void set_disablefallback(bool value);

  private:
  bool _internal_disablefallback() const;
  void _internal_set_disablefallback(bool value);

  public:
  // bool disableFallbackIfMatch = 11;
  void clear_disablefallbackifmatch() ;
  bool disablefallbackifmatch() const;
  void set_disablefallbackifmatch(bool value);

  private:
  bool _internal_disablefallbackifmatch() const;
  void _internal_set_disablefallbackifmatch(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.dns.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 5,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::common::net::Endpoint > nameservers_;
    ::google::protobuf::internal::MapField<Config_HostsEntry_DoNotUse, std::string, ::xray::common::net::IPOrDomain,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        hosts_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::dns::Config_HostMapping > static_hosts_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::dns::NameServer > name_server_;
    ::google::protobuf::internal::ArenaStringPtr client_ip_;
    ::google::protobuf::internal::ArenaStringPtr tag_;
    int query_strategy_;
    bool disablecache_;
    bool disablefallback_;
    bool disablefallbackifmatch_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2fdns_2fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NameServer_PriorityDomain

// .xray.app.dns.DomainMatchingType type = 1;
inline void NameServer_PriorityDomain::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::xray::app::dns::DomainMatchingType NameServer_PriorityDomain::type() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.PriorityDomain.type)
  return _internal_type();
}
inline void NameServer_PriorityDomain::set_type(::xray::app::dns::DomainMatchingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.NameServer.PriorityDomain.type)
}
inline ::xray::app::dns::DomainMatchingType NameServer_PriorityDomain::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::app::dns::DomainMatchingType>(_impl_.type_);
}
inline void NameServer_PriorityDomain::_internal_set_type(::xray::app::dns::DomainMatchingType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string domain = 2;
inline void NameServer_PriorityDomain::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& NameServer_PriorityDomain::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.PriorityDomain.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NameServer_PriorityDomain::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.dns.NameServer.PriorityDomain.domain)
}
inline std::string* NameServer_PriorityDomain::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.NameServer.PriorityDomain.domain)
  return _s;
}
inline const std::string& NameServer_PriorityDomain::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void NameServer_PriorityDomain::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* NameServer_PriorityDomain::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* NameServer_PriorityDomain::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.NameServer.PriorityDomain.domain)
  return _impl_.domain_.Release();
}
inline void NameServer_PriorityDomain::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.NameServer.PriorityDomain.domain)
}

// -------------------------------------------------------------------

// NameServer_OriginalRule

// string rule = 1;
inline void NameServer_OriginalRule::clear_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_.ClearToEmpty();
}
inline const std::string& NameServer_OriginalRule::rule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.OriginalRule.rule)
  return _internal_rule();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NameServer_OriginalRule::set_rule(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.dns.NameServer.OriginalRule.rule)
}
inline std::string* NameServer_OriginalRule::mutable_rule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.NameServer.OriginalRule.rule)
  return _s;
}
inline const std::string& NameServer_OriginalRule::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_.Get();
}
inline void NameServer_OriginalRule::_internal_set_rule(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_.Set(value, GetArena());
}
inline std::string* NameServer_OriginalRule::_internal_mutable_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rule_.Mutable( GetArena());
}
inline std::string* NameServer_OriginalRule::release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.NameServer.OriginalRule.rule)
  return _impl_.rule_.Release();
}
inline void NameServer_OriginalRule::set_allocated_rule(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_.IsDefault()) {
          _impl_.rule_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.NameServer.OriginalRule.rule)
}

// uint32 size = 2;
inline void NameServer_OriginalRule::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = 0u;
}
inline ::uint32_t NameServer_OriginalRule::size() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.OriginalRule.size)
  return _internal_size();
}
inline void NameServer_OriginalRule::set_size(::uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.NameServer.OriginalRule.size)
}
inline ::uint32_t NameServer_OriginalRule::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void NameServer_OriginalRule::_internal_set_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// NameServer

// .xray.common.net.Endpoint address = 1;
inline bool NameServer::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.address_ != nullptr);
  return value;
}
inline const ::xray::common::net::Endpoint& NameServer::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::Endpoint* p = _impl_.address_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::Endpoint&>(::xray::common::net::_Endpoint_default_instance_);
}
inline const ::xray::common::net::Endpoint& NameServer::address() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.address)
  return _internal_address();
}
inline void NameServer::unsafe_arena_set_allocated_address(::xray::common::net::Endpoint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }
  _impl_.address_ = reinterpret_cast<::xray::common::net::Endpoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.dns.NameServer.address)
}
inline ::xray::common::net::Endpoint* NameServer::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::Endpoint* released = _impl_.address_;
  _impl_.address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::Endpoint* NameServer::unsafe_arena_release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.NameServer.address)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::Endpoint* temp = _impl_.address_;
  _impl_.address_ = nullptr;
  return temp;
}
inline ::xray::common::net::Endpoint* NameServer::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.address_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::Endpoint>(GetArena());
    _impl_.address_ = reinterpret_cast<::xray::common::net::Endpoint*>(p);
  }
  return _impl_.address_;
}
inline ::xray::common::net::Endpoint* NameServer::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::Endpoint* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.NameServer.address)
  return _msg;
}
inline void NameServer::set_allocated_address(::xray::common::net::Endpoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.address_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.address_ = reinterpret_cast<::xray::common::net::Endpoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.NameServer.address)
}

// bytes client_ip = 5;
inline void NameServer::clear_client_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_ip_.ClearToEmpty();
}
inline const std::string& NameServer::client_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.client_ip)
  return _internal_client_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NameServer::set_client_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_ip_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.dns.NameServer.client_ip)
}
inline std::string* NameServer::mutable_client_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_ip();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.NameServer.client_ip)
  return _s;
}
inline const std::string& NameServer::_internal_client_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_ip_.Get();
}
inline void NameServer::_internal_set_client_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_ip_.Set(value, GetArena());
}
inline std::string* NameServer::_internal_mutable_client_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_ip_.Mutable( GetArena());
}
inline std::string* NameServer::release_client_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.NameServer.client_ip)
  return _impl_.client_ip_.Release();
}
inline void NameServer::set_allocated_client_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_ip_.IsDefault()) {
          _impl_.client_ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.NameServer.client_ip)
}

// bool skipFallback = 6;
inline void NameServer::clear_skipfallback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skipfallback_ = false;
}
inline bool NameServer::skipfallback() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.skipFallback)
  return _internal_skipfallback();
}
inline void NameServer::set_skipfallback(bool value) {
  _internal_set_skipfallback(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.NameServer.skipFallback)
}
inline bool NameServer::_internal_skipfallback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skipfallback_;
}
inline void NameServer::_internal_set_skipfallback(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skipfallback_ = value;
}

// repeated .xray.app.dns.NameServer.PriorityDomain prioritized_domain = 2;
inline int NameServer::_internal_prioritized_domain_size() const {
  return _internal_prioritized_domain().size();
}
inline int NameServer::prioritized_domain_size() const {
  return _internal_prioritized_domain_size();
}
inline void NameServer::clear_prioritized_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prioritized_domain_.Clear();
}
inline ::xray::app::dns::NameServer_PriorityDomain* NameServer::mutable_prioritized_domain(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.dns.NameServer.prioritized_domain)
  return _internal_mutable_prioritized_domain()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_PriorityDomain>* NameServer::mutable_prioritized_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.dns.NameServer.prioritized_domain)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_prioritized_domain();
}
inline const ::xray::app::dns::NameServer_PriorityDomain& NameServer::prioritized_domain(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.prioritized_domain)
  return _internal_prioritized_domain().Get(index);
}
inline ::xray::app::dns::NameServer_PriorityDomain* NameServer::add_prioritized_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::dns::NameServer_PriorityDomain* _add = _internal_mutable_prioritized_domain()->Add();
  // @@protoc_insertion_point(field_add:xray.app.dns.NameServer.prioritized_domain)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_PriorityDomain>& NameServer::prioritized_domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.dns.NameServer.prioritized_domain)
  return _internal_prioritized_domain();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_PriorityDomain>&
NameServer::_internal_prioritized_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prioritized_domain_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_PriorityDomain>*
NameServer::_internal_mutable_prioritized_domain() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.prioritized_domain_;
}

// repeated .xray.app.router.GeoIP geoip = 3;
inline int NameServer::_internal_geoip_size() const {
  return _internal_geoip().size();
}
inline int NameServer::geoip_size() const {
  return _internal_geoip_size();
}
inline ::xray::app::router::GeoIP* NameServer::mutable_geoip(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.dns.NameServer.geoip)
  return _internal_mutable_geoip()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* NameServer::mutable_geoip()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.dns.NameServer.geoip)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geoip();
}
inline const ::xray::app::router::GeoIP& NameServer::geoip(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.geoip)
  return _internal_geoip().Get(index);
}
inline ::xray::app::router::GeoIP* NameServer::add_geoip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::GeoIP* _add = _internal_mutable_geoip()->Add();
  // @@protoc_insertion_point(field_add:xray.app.dns.NameServer.geoip)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& NameServer::geoip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.dns.NameServer.geoip)
  return _internal_geoip();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>&
NameServer::_internal_geoip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geoip_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>*
NameServer::_internal_mutable_geoip() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geoip_;
}

// repeated .xray.app.dns.NameServer.OriginalRule original_rules = 4;
inline int NameServer::_internal_original_rules_size() const {
  return _internal_original_rules().size();
}
inline int NameServer::original_rules_size() const {
  return _internal_original_rules_size();
}
inline void NameServer::clear_original_rules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_rules_.Clear();
}
inline ::xray::app::dns::NameServer_OriginalRule* NameServer::mutable_original_rules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.dns.NameServer.original_rules)
  return _internal_mutable_original_rules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_OriginalRule>* NameServer::mutable_original_rules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.dns.NameServer.original_rules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_original_rules();
}
inline const ::xray::app::dns::NameServer_OriginalRule& NameServer::original_rules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.original_rules)
  return _internal_original_rules().Get(index);
}
inline ::xray::app::dns::NameServer_OriginalRule* NameServer::add_original_rules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::dns::NameServer_OriginalRule* _add = _internal_mutable_original_rules()->Add();
  // @@protoc_insertion_point(field_add:xray.app.dns.NameServer.original_rules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_OriginalRule>& NameServer::original_rules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.dns.NameServer.original_rules)
  return _internal_original_rules();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_OriginalRule>&
NameServer::_internal_original_rules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_rules_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer_OriginalRule>*
NameServer::_internal_mutable_original_rules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.original_rules_;
}

// .xray.app.dns.QueryStrategy query_strategy = 7;
inline void NameServer::clear_query_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_strategy_ = 0;
}
inline ::xray::app::dns::QueryStrategy NameServer::query_strategy() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.NameServer.query_strategy)
  return _internal_query_strategy();
}
inline void NameServer::set_query_strategy(::xray::app::dns::QueryStrategy value) {
  _internal_set_query_strategy(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.NameServer.query_strategy)
}
inline ::xray::app::dns::QueryStrategy NameServer::_internal_query_strategy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::app::dns::QueryStrategy>(_impl_.query_strategy_);
}
inline void NameServer::_internal_set_query_strategy(::xray::app::dns::QueryStrategy value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_strategy_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Config_HostMapping

// .xray.app.dns.DomainMatchingType type = 1;
inline void Config_HostMapping::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::xray::app::dns::DomainMatchingType Config_HostMapping::type() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.HostMapping.type)
  return _internal_type();
}
inline void Config_HostMapping::set_type(::xray::app::dns::DomainMatchingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.HostMapping.type)
}
inline ::xray::app::dns::DomainMatchingType Config_HostMapping::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::app::dns::DomainMatchingType>(_impl_.type_);
}
inline void Config_HostMapping::_internal_set_type(::xray::app::dns::DomainMatchingType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string domain = 2;
inline void Config_HostMapping::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& Config_HostMapping::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.HostMapping.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config_HostMapping::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.HostMapping.domain)
}
inline std::string* Config_HostMapping::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.HostMapping.domain)
  return _s;
}
inline const std::string& Config_HostMapping::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void Config_HostMapping::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* Config_HostMapping::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* Config_HostMapping::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.Config.HostMapping.domain)
  return _impl_.domain_.Release();
}
inline void Config_HostMapping::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.Config.HostMapping.domain)
}

// repeated bytes ip = 3;
inline int Config_HostMapping::_internal_ip_size() const {
  return _internal_ip().size();
}
inline int Config_HostMapping::ip_size() const {
  return _internal_ip_size();
}
inline void Config_HostMapping::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.Clear();
}
inline std::string* Config_HostMapping::add_ip()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_ip()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.app.dns.Config.HostMapping.ip)
  return _s;
}
inline const std::string& Config_HostMapping::ip(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.HostMapping.ip)
  return _internal_ip().Get(index);
}
inline std::string* Config_HostMapping::mutable_ip(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.HostMapping.ip)
  return _internal_mutable_ip()->Mutable(index);
}
inline void Config_HostMapping::set_ip(int index, const std::string& value) {
  _internal_mutable_ip()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::set_ip(int index, std::string&& value) {
  _internal_mutable_ip()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::set_ip(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ip()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::set_ip(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_ip()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::set_ip(int index, absl::string_view value) {
  _internal_mutable_ip()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::add_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ip()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::add_ip(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ip()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::add_ip(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ip()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::add_ip(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ip()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.app.dns.Config.HostMapping.ip)
}
inline void Config_HostMapping::add_ip(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ip()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.app.dns.Config.HostMapping.ip)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config_HostMapping::ip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.dns.Config.HostMapping.ip)
  return _internal_ip();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config_HostMapping::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.dns.Config.HostMapping.ip)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ip();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Config_HostMapping::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Config_HostMapping::_internal_mutable_ip() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ip_;
}

// string proxied_domain = 4;
inline void Config_HostMapping::clear_proxied_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proxied_domain_.ClearToEmpty();
}
inline const std::string& Config_HostMapping::proxied_domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.HostMapping.proxied_domain)
  return _internal_proxied_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config_HostMapping::set_proxied_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proxied_domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.HostMapping.proxied_domain)
}
inline std::string* Config_HostMapping::mutable_proxied_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_proxied_domain();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.HostMapping.proxied_domain)
  return _s;
}
inline const std::string& Config_HostMapping::_internal_proxied_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proxied_domain_.Get();
}
inline void Config_HostMapping::_internal_set_proxied_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proxied_domain_.Set(value, GetArena());
}
inline std::string* Config_HostMapping::_internal_mutable_proxied_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.proxied_domain_.Mutable( GetArena());
}
inline std::string* Config_HostMapping::release_proxied_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.Config.HostMapping.proxied_domain)
  return _impl_.proxied_domain_.Release();
}
inline void Config_HostMapping::set_allocated_proxied_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proxied_domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proxied_domain_.IsDefault()) {
          _impl_.proxied_domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.Config.HostMapping.proxied_domain)
}

// -------------------------------------------------------------------

// Config

// repeated .xray.common.net.Endpoint NameServers = 1 [deprecated = true];
inline int Config::_internal_nameservers_size() const {
  return _internal_nameservers().size();
}
inline int Config::nameservers_size() const {
  return _internal_nameservers_size();
}
inline ::xray::common::net::Endpoint* Config::mutable_nameservers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.NameServers)
  return _internal_mutable_nameservers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::common::net::Endpoint>* Config::mutable_nameservers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.dns.Config.NameServers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nameservers();
}
inline const ::xray::common::net::Endpoint& Config::nameservers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.NameServers)
  return _internal_nameservers().Get(index);
}
inline ::xray::common::net::Endpoint* Config::add_nameservers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::common::net::Endpoint* _add = _internal_mutable_nameservers()->Add();
  // @@protoc_insertion_point(field_add:xray.app.dns.Config.NameServers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::common::net::Endpoint>& Config::nameservers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.dns.Config.NameServers)
  return _internal_nameservers();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::common::net::Endpoint>&
Config::_internal_nameservers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nameservers_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::common::net::Endpoint>*
Config::_internal_mutable_nameservers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nameservers_;
}

// repeated .xray.app.dns.NameServer name_server = 5;
inline int Config::_internal_name_server_size() const {
  return _internal_name_server().size();
}
inline int Config::name_server_size() const {
  return _internal_name_server_size();
}
inline void Config::clear_name_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_server_.Clear();
}
inline ::xray::app::dns::NameServer* Config::mutable_name_server(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.name_server)
  return _internal_mutable_name_server()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer>* Config::mutable_name_server()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.dns.Config.name_server)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_name_server();
}
inline const ::xray::app::dns::NameServer& Config::name_server(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.name_server)
  return _internal_name_server().Get(index);
}
inline ::xray::app::dns::NameServer* Config::add_name_server() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::dns::NameServer* _add = _internal_mutable_name_server()->Add();
  // @@protoc_insertion_point(field_add:xray.app.dns.Config.name_server)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer>& Config::name_server() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.dns.Config.name_server)
  return _internal_name_server();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer>&
Config::_internal_name_server() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_server_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::NameServer>*
Config::_internal_mutable_name_server() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.name_server_;
}

// map<string, .xray.common.net.IPOrDomain> Hosts = 2 [deprecated = true];
inline int Config::_internal_hosts_size() const {
  return _internal_hosts().size();
}
inline int Config::hosts_size() const {
  return _internal_hosts_size();
}
inline const ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>& Config::_internal_hosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hosts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>& Config::hosts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:xray.app.dns.Config.Hosts)
  return _internal_hosts();
}
inline ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>* Config::_internal_mutable_hosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.hosts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::xray::common::net::IPOrDomain>* Config::mutable_hosts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:xray.app.dns.Config.Hosts)
  return _internal_mutable_hosts();
}

// bytes client_ip = 3;
inline void Config::clear_client_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_ip_.ClearToEmpty();
}
inline const std::string& Config::client_ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.client_ip)
  return _internal_client_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_client_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_ip_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.client_ip)
}
inline std::string* Config::mutable_client_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_ip();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.client_ip)
  return _s;
}
inline const std::string& Config::_internal_client_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_ip_.Get();
}
inline void Config::_internal_set_client_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_ip_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_client_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_ip_.Mutable( GetArena());
}
inline std::string* Config::release_client_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.Config.client_ip)
  return _impl_.client_ip_.Release();
}
inline void Config::set_allocated_client_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_ip_.IsDefault()) {
          _impl_.client_ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.Config.client_ip)
}

// repeated .xray.app.dns.Config.HostMapping static_hosts = 4;
inline int Config::_internal_static_hosts_size() const {
  return _internal_static_hosts().size();
}
inline int Config::static_hosts_size() const {
  return _internal_static_hosts_size();
}
inline void Config::clear_static_hosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.static_hosts_.Clear();
}
inline ::xray::app::dns::Config_HostMapping* Config::mutable_static_hosts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.static_hosts)
  return _internal_mutable_static_hosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::Config_HostMapping>* Config::mutable_static_hosts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.dns.Config.static_hosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_static_hosts();
}
inline const ::xray::app::dns::Config_HostMapping& Config::static_hosts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.static_hosts)
  return _internal_static_hosts().Get(index);
}
inline ::xray::app::dns::Config_HostMapping* Config::add_static_hosts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::dns::Config_HostMapping* _add = _internal_mutable_static_hosts()->Add();
  // @@protoc_insertion_point(field_add:xray.app.dns.Config.static_hosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::Config_HostMapping>& Config::static_hosts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.dns.Config.static_hosts)
  return _internal_static_hosts();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::dns::Config_HostMapping>&
Config::_internal_static_hosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.static_hosts_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::dns::Config_HostMapping>*
Config::_internal_mutable_static_hosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.static_hosts_;
}

// string tag = 6;
inline void Config::clear_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& Config::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Config::set_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.tag)
}
inline std::string* Config::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:xray.app.dns.Config.tag)
  return _s;
}
inline const std::string& Config::_internal_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tag_.Get();
}
inline void Config::_internal_set_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(value, GetArena());
}
inline std::string* Config::_internal_mutable_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tag_.Mutable( GetArena());
}
inline std::string* Config::release_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.dns.Config.tag)
  return _impl_.tag_.Release();
}
inline void Config::set_allocated_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tag_.IsDefault()) {
          _impl_.tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.dns.Config.tag)
}

// bool disableCache = 8;
inline void Config::clear_disablecache() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disablecache_ = false;
}
inline bool Config::disablecache() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.disableCache)
  return _internal_disablecache();
}
inline void Config::set_disablecache(bool value) {
  _internal_set_disablecache(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.disableCache)
}
inline bool Config::_internal_disablecache() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disablecache_;
}
inline void Config::_internal_set_disablecache(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disablecache_ = value;
}

// .xray.app.dns.QueryStrategy query_strategy = 9;
inline void Config::clear_query_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.query_strategy_ = 0;
}
inline ::xray::app::dns::QueryStrategy Config::query_strategy() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.query_strategy)
  return _internal_query_strategy();
}
inline void Config::set_query_strategy(::xray::app::dns::QueryStrategy value) {
  _internal_set_query_strategy(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.query_strategy)
}
inline ::xray::app::dns::QueryStrategy Config::_internal_query_strategy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::app::dns::QueryStrategy>(_impl_.query_strategy_);
}
inline void Config::_internal_set_query_strategy(::xray::app::dns::QueryStrategy value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.query_strategy_ = value;
}

// bool disableFallback = 10;
inline void Config::clear_disablefallback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disablefallback_ = false;
}
inline bool Config::disablefallback() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.disableFallback)
  return _internal_disablefallback();
}
inline void Config::set_disablefallback(bool value) {
  _internal_set_disablefallback(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.disableFallback)
}
inline bool Config::_internal_disablefallback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disablefallback_;
}
inline void Config::_internal_set_disablefallback(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disablefallback_ = value;
}

// bool disableFallbackIfMatch = 11;
inline void Config::clear_disablefallbackifmatch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disablefallbackifmatch_ = false;
}
inline bool Config::disablefallbackifmatch() const {
  // @@protoc_insertion_point(field_get:xray.app.dns.Config.disableFallbackIfMatch)
  return _internal_disablefallbackifmatch();
}
inline void Config::set_disablefallbackifmatch(bool value) {
  _internal_set_disablefallbackifmatch(value);
  // @@protoc_insertion_point(field_set:xray.app.dns.Config.disableFallbackIfMatch)
}
inline bool Config::_internal_disablefallbackifmatch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disablefallbackifmatch_;
}
inline void Config::_internal_set_disablefallbackifmatch(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disablefallbackifmatch_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace dns
}  // namespace app
}  // namespace xray


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::xray::app::dns::DomainMatchingType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::app::dns::DomainMatchingType>() {
  return ::xray::app::dns::DomainMatchingType_descriptor();
}
template <>
struct is_proto_enum<::xray::app::dns::QueryStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::app::dns::QueryStrategy>() {
  return ::xray::app::dns::QueryStrategy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_app_2fdns_2fconfig_2eproto_2epb_2eh
