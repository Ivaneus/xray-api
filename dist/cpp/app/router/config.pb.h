// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app/router/config.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_app_2frouter_2fconfig_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_app_2frouter_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common/net/port.pb.h"
#include "common/net/network.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_app_2frouter_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_app_2frouter_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_app_2frouter_2fconfig_2eproto;
namespace xray {
namespace app {
namespace router {
class BalancingRule;
struct BalancingRuleDefaultTypeInternal;
extern BalancingRuleDefaultTypeInternal _BalancingRule_default_instance_;
class CIDR;
struct CIDRDefaultTypeInternal;
extern CIDRDefaultTypeInternal _CIDR_default_instance_;
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Domain;
struct DomainDefaultTypeInternal;
extern DomainDefaultTypeInternal _Domain_default_instance_;
class Domain_Attribute;
struct Domain_AttributeDefaultTypeInternal;
extern Domain_AttributeDefaultTypeInternal _Domain_Attribute_default_instance_;
class GeoIP;
struct GeoIPDefaultTypeInternal;
extern GeoIPDefaultTypeInternal _GeoIP_default_instance_;
class GeoIPList;
struct GeoIPListDefaultTypeInternal;
extern GeoIPListDefaultTypeInternal _GeoIPList_default_instance_;
class GeoSite;
struct GeoSiteDefaultTypeInternal;
extern GeoSiteDefaultTypeInternal _GeoSite_default_instance_;
class GeoSiteList;
struct GeoSiteListDefaultTypeInternal;
extern GeoSiteListDefaultTypeInternal _GeoSiteList_default_instance_;
class RoutingRule;
struct RoutingRuleDefaultTypeInternal;
extern RoutingRuleDefaultTypeInternal _RoutingRule_default_instance_;
class RoutingRule_AttributesEntry_DoNotUse;
struct RoutingRule_AttributesEntry_DoNotUseDefaultTypeInternal;
extern RoutingRule_AttributesEntry_DoNotUseDefaultTypeInternal _RoutingRule_AttributesEntry_DoNotUse_default_instance_;
}  // namespace router
}  // namespace app
}  // namespace xray
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xray {
namespace app {
namespace router {
enum Domain_Type : int {
  Domain_Type_Plain = 0,
  Domain_Type_Regex = 1,
  Domain_Type_Domain = 2,
  Domain_Type_Full = 3,
  Domain_Type_Domain_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Domain_Type_Domain_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Domain_Type_IsValid(int value);
extern const uint32_t Domain_Type_internal_data_[];
constexpr Domain_Type Domain_Type_Type_MIN = static_cast<Domain_Type>(0);
constexpr Domain_Type Domain_Type_Type_MAX = static_cast<Domain_Type>(3);
constexpr int Domain_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Domain_Type_descriptor();
template <typename T>
const std::string& Domain_Type_Name(T value) {
  static_assert(std::is_same<T, Domain_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Domain_Type_Name(static_cast<Domain_Type>(value));
}
template <>
inline const std::string& Domain_Type_Name(Domain_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Domain_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Domain_Type_Parse(absl::string_view name, Domain_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Domain_Type>(
      Domain_Type_descriptor(), name, value);
}
enum Config_DomainStrategy : int {
  Config_DomainStrategy_AsIs = 0,
  Config_DomainStrategy_UseIp = 1,
  Config_DomainStrategy_IpIfNonMatch = 2,
  Config_DomainStrategy_IpOnDemand = 3,
  Config_DomainStrategy_Config_DomainStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Config_DomainStrategy_Config_DomainStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Config_DomainStrategy_IsValid(int value);
extern const uint32_t Config_DomainStrategy_internal_data_[];
constexpr Config_DomainStrategy Config_DomainStrategy_DomainStrategy_MIN = static_cast<Config_DomainStrategy>(0);
constexpr Config_DomainStrategy Config_DomainStrategy_DomainStrategy_MAX = static_cast<Config_DomainStrategy>(3);
constexpr int Config_DomainStrategy_DomainStrategy_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Config_DomainStrategy_descriptor();
template <typename T>
const std::string& Config_DomainStrategy_Name(T value) {
  static_assert(std::is_same<T, Config_DomainStrategy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DomainStrategy_Name().");
  return Config_DomainStrategy_Name(static_cast<Config_DomainStrategy>(value));
}
template <>
inline const std::string& Config_DomainStrategy_Name(Config_DomainStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DomainStrategy_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Config_DomainStrategy_Parse(absl::string_view name, Config_DomainStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DomainStrategy>(
      Config_DomainStrategy_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RoutingRule_AttributesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RoutingRule_AttributesEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RoutingRule_AttributesEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RoutingRule_AttributesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutingRule_AttributesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RoutingRule_AttributesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RoutingRule_AttributesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RoutingRule_AttributesEntry_DoNotUse*>(
        &_RoutingRule_AttributesEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "xray.app.router.RoutingRule.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "xray.app.router.RoutingRule.AttributesEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Domain_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.Domain.Attribute) */ {
 public:
  inline Domain_Attribute() : Domain_Attribute(nullptr) {}
  ~Domain_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Domain_Attribute(::google::protobuf::internal::ConstantInitialized);

  inline Domain_Attribute(const Domain_Attribute& from)
      : Domain_Attribute(nullptr, from) {}
  Domain_Attribute(Domain_Attribute&& from) noexcept
    : Domain_Attribute() {
    *this = ::std::move(from);
  }

  inline Domain_Attribute& operator=(const Domain_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Domain_Attribute& operator=(Domain_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Domain_Attribute& default_instance() {
    return *internal_default_instance();
  }
  enum TypedValueCase {
    kBoolValue = 2,
    kIntValue = 3,
    TYPED_VALUE_NOT_SET = 0,
  };

  static inline const Domain_Attribute* internal_default_instance() {
    return reinterpret_cast<const Domain_Attribute*>(
               &_Domain_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Domain_Attribute& a, Domain_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Domain_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Domain_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Domain_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Domain_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Domain_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Domain_Attribute& from) {
    Domain_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Domain_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.Domain.Attribute";
  }
  protected:
  explicit Domain_Attribute(::google::protobuf::Arena* arena);
  Domain_Attribute(::google::protobuf::Arena* arena, const Domain_Attribute& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kIntValueFieldNumber = 3,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bool bool_value = 2;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  // int64 int_value = 3;
  bool has_int_value() const;
  void clear_int_value() ;
  ::int64_t int_value() const;
  void set_int_value(::int64_t value);

  private:
  ::int64_t _internal_int_value() const;
  void _internal_set_int_value(::int64_t value);

  public:
  void clear_typed_value();
  TypedValueCase typed_value_case() const;
  // @@protoc_insertion_point(class_scope:xray.app.router.Domain.Attribute)
 private:
  class _Internal;
  void set_has_bool_value();
  void set_has_int_value();

  inline bool has_typed_value() const;
  inline void clear_has_typed_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    union TypedValueUnion {
      constexpr TypedValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool bool_value_;
      ::int64_t int_value_;
    } typed_value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class CIDR final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.CIDR) */ {
 public:
  inline CIDR() : CIDR(nullptr) {}
  ~CIDR() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CIDR(::google::protobuf::internal::ConstantInitialized);

  inline CIDR(const CIDR& from)
      : CIDR(nullptr, from) {}
  CIDR(CIDR&& from) noexcept
    : CIDR() {
    *this = ::std::move(from);
  }

  inline CIDR& operator=(const CIDR& from) {
    CopyFrom(from);
    return *this;
  }
  inline CIDR& operator=(CIDR&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CIDR& default_instance() {
    return *internal_default_instance();
  }
  static inline const CIDR* internal_default_instance() {
    return reinterpret_cast<const CIDR*>(
               &_CIDR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CIDR& a, CIDR& b) {
    a.Swap(&b);
  }
  inline void Swap(CIDR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CIDR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CIDR* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CIDR>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CIDR& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CIDR& from) {
    CIDR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CIDR* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.CIDR";
  }
  protected:
  explicit CIDR(::google::protobuf::Arena* arena);
  CIDR(::google::protobuf::Arena* arena, const CIDR& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPrefixFieldNumber = 2,
  };
  // bytes ip = 1;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // uint32 prefix = 2;
  void clear_prefix() ;
  ::uint32_t prefix() const;
  void set_prefix(::uint32_t value);

  private:
  ::uint32_t _internal_prefix() const;
  void _internal_set_prefix(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.router.CIDR)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::uint32_t prefix_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class BalancingRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.BalancingRule) */ {
 public:
  inline BalancingRule() : BalancingRule(nullptr) {}
  ~BalancingRule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BalancingRule(::google::protobuf::internal::ConstantInitialized);

  inline BalancingRule(const BalancingRule& from)
      : BalancingRule(nullptr, from) {}
  BalancingRule(BalancingRule&& from) noexcept
    : BalancingRule() {
    *this = ::std::move(from);
  }

  inline BalancingRule& operator=(const BalancingRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalancingRule& operator=(BalancingRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalancingRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalancingRule* internal_default_instance() {
    return reinterpret_cast<const BalancingRule*>(
               &_BalancingRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BalancingRule& a, BalancingRule& b) {
    a.Swap(&b);
  }
  inline void Swap(BalancingRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalancingRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalancingRule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalancingRule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BalancingRule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BalancingRule& from) {
    BalancingRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BalancingRule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.BalancingRule";
  }
  protected:
  explicit BalancingRule(::google::protobuf::Arena* arena);
  BalancingRule(::google::protobuf::Arena* arena, const BalancingRule& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutboundSelectorFieldNumber = 2,
    kTagFieldNumber = 1,
    kStrategyFieldNumber = 3,
  };
  // repeated string outbound_selector = 2;
  int outbound_selector_size() const;
  private:
  int _internal_outbound_selector_size() const;

  public:
  void clear_outbound_selector() ;
  const std::string& outbound_selector(int index) const;
  std::string* mutable_outbound_selector(int index);
  void set_outbound_selector(int index, const std::string& value);
  void set_outbound_selector(int index, std::string&& value);
  void set_outbound_selector(int index, const char* value);
  void set_outbound_selector(int index, const char* value, std::size_t size);
  void set_outbound_selector(int index, absl::string_view value);
  std::string* add_outbound_selector();
  void add_outbound_selector(const std::string& value);
  void add_outbound_selector(std::string&& value);
  void add_outbound_selector(const char* value);
  void add_outbound_selector(const char* value, std::size_t size);
  void add_outbound_selector(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& outbound_selector() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_outbound_selector();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_outbound_selector() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_outbound_selector();

  public:
  // string tag = 1;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // string strategy = 3;
  void clear_strategy() ;
  const std::string& strategy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_strategy(Arg_&& arg, Args_... args);
  std::string* mutable_strategy();
  PROTOBUF_NODISCARD std::string* release_strategy();
  void set_allocated_strategy(std::string* value);

  private:
  const std::string& _internal_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy(
      const std::string& value);
  std::string* _internal_mutable_strategy();

  public:
  // @@protoc_insertion_point(class_scope:xray.app.router.BalancingRule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> outbound_selector_;
    ::google::protobuf::internal::ArenaStringPtr tag_;
    ::google::protobuf::internal::ArenaStringPtr strategy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class GeoIP final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.GeoIP) */ {
 public:
  inline GeoIP() : GeoIP(nullptr) {}
  ~GeoIP() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeoIP(::google::protobuf::internal::ConstantInitialized);

  inline GeoIP(const GeoIP& from)
      : GeoIP(nullptr, from) {}
  GeoIP(GeoIP&& from) noexcept
    : GeoIP() {
    *this = ::std::move(from);
  }

  inline GeoIP& operator=(const GeoIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoIP& operator=(GeoIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoIP* internal_default_instance() {
    return reinterpret_cast<const GeoIP*>(
               &_GeoIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GeoIP& a, GeoIP& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoIP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoIP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoIP* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoIP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoIP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GeoIP& from) {
    GeoIP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoIP* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.GeoIP";
  }
  protected:
  explicit GeoIP(::google::protobuf::Arena* arena);
  GeoIP(::google::protobuf::Arena* arena, const GeoIP& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCidrFieldNumber = 2,
    kCountryCodeFieldNumber = 1,
    kReverseMatchFieldNumber = 3,
  };
  // repeated .xray.app.router.CIDR cidr = 2;
  int cidr_size() const;
  private:
  int _internal_cidr_size() const;

  public:
  void clear_cidr() ;
  ::xray::app::router::CIDR* mutable_cidr(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR >*
      mutable_cidr();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>& _internal_cidr() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>* _internal_mutable_cidr();
  public:
  const ::xray::app::router::CIDR& cidr(int index) const;
  ::xray::app::router::CIDR* add_cidr();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR >&
      cidr() const;
  // string country_code = 1;
  void clear_country_code() ;
  const std::string& country_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country_code(Arg_&& arg, Args_... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* value);

  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(
      const std::string& value);
  std::string* _internal_mutable_country_code();

  public:
  // bool reverse_match = 3;
  void clear_reverse_match() ;
  bool reverse_match() const;
  void set_reverse_match(bool value);

  private:
  bool _internal_reverse_match() const;
  void _internal_set_reverse_match(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.router.GeoIP)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR > cidr_;
    ::google::protobuf::internal::ArenaStringPtr country_code_;
    bool reverse_match_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Domain final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.Domain) */ {
 public:
  inline Domain() : Domain(nullptr) {}
  ~Domain() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Domain(::google::protobuf::internal::ConstantInitialized);

  inline Domain(const Domain& from)
      : Domain(nullptr, from) {}
  Domain(Domain&& from) noexcept
    : Domain() {
    *this = ::std::move(from);
  }

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }
  inline Domain& operator=(Domain&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Domain& default_instance() {
    return *internal_default_instance();
  }
  static inline const Domain* internal_default_instance() {
    return reinterpret_cast<const Domain*>(
               &_Domain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Domain& a, Domain& b) {
    a.Swap(&b);
  }
  inline void Swap(Domain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Domain* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Domain* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Domain>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Domain& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Domain& from) {
    Domain::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Domain* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.Domain";
  }
  protected:
  explicit Domain(::google::protobuf::Arena* arena);
  Domain(::google::protobuf::Arena* arena, const Domain& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Attribute = Domain_Attribute;

  using Type = Domain_Type;
  static constexpr Type Plain = Domain_Type_Plain;
  static constexpr Type Regex = Domain_Type_Regex;
  static constexpr Type Domain = Domain_Type_Domain;
  static constexpr Type Full = Domain_Type_Full;
  static inline bool Type_IsValid(int value) {
    return Domain_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Domain_Type_Type_MIN;
  static constexpr Type Type_MAX = Domain_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Domain_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Domain_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Domain_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Domain_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeFieldNumber = 3,
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .xray.app.router.Domain.Attribute attribute = 3;
  int attribute_size() const;
  private:
  int _internal_attribute_size() const;

  public:
  void clear_attribute() ;
  ::xray::app::router::Domain_Attribute* mutable_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain_Attribute >*
      mutable_attribute();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain_Attribute>& _internal_attribute() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain_Attribute>* _internal_mutable_attribute();
  public:
  const ::xray::app::router::Domain_Attribute& attribute(int index) const;
  ::xray::app::router::Domain_Attribute* add_attribute();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain_Attribute >&
      attribute() const;
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .xray.app.router.Domain.Type type = 1;
  void clear_type() ;
  ::xray::app::router::Domain_Type type() const;
  void set_type(::xray::app::router::Domain_Type value);

  private:
  ::xray::app::router::Domain_Type _internal_type() const;
  void _internal_set_type(::xray::app::router::Domain_Type value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.router.Domain)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain_Attribute > attribute_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class RoutingRule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.RoutingRule) */ {
 public:
  inline RoutingRule() : RoutingRule(nullptr) {}
  ~RoutingRule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoutingRule(::google::protobuf::internal::ConstantInitialized);

  inline RoutingRule(const RoutingRule& from)
      : RoutingRule(nullptr, from) {}
  RoutingRule(RoutingRule&& from) noexcept
    : RoutingRule() {
    *this = ::std::move(from);
  }

  inline RoutingRule& operator=(const RoutingRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingRule& operator=(RoutingRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingRule& default_instance() {
    return *internal_default_instance();
  }
  enum TargetTagCase {
    kTag = 1,
    kBalancingTag = 12,
    TARGET_TAG_NOT_SET = 0,
  };

  static inline const RoutingRule* internal_default_instance() {
    return reinterpret_cast<const RoutingRule*>(
               &_RoutingRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoutingRule& a, RoutingRule& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingRule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingRule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutingRule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoutingRule& from) {
    RoutingRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoutingRule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.RoutingRule";
  }
  protected:
  explicit RoutingRule(::google::protobuf::Arena* arena);
  RoutingRule(::google::protobuf::Arena* arena, const RoutingRule& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 2,
    kCidrFieldNumber = 3,
    kSourceCidrFieldNumber = 6,
    kUserEmailFieldNumber = 7,
    kInboundTagFieldNumber = 8,
    kProtocolFieldNumber = 9,
    kGeoipFieldNumber = 10,
    kSourceGeoipFieldNumber = 11,
    kNetworksFieldNumber = 13,
    kAttributesFieldNumber = 15,
    kDomainMatcherFieldNumber = 17,
    kPortRangeFieldNumber = 4,
    kNetworkListFieldNumber = 5,
    kPortListFieldNumber = 14,
    kSourcePortListFieldNumber = 16,
    kTagFieldNumber = 1,
    kBalancingTagFieldNumber = 12,
  };
  // repeated .xray.app.router.Domain domain = 2;
  int domain_size() const;
  private:
  int _internal_domain_size() const;

  public:
  void clear_domain() ;
  ::xray::app::router::Domain* mutable_domain(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain >*
      mutable_domain();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>& _internal_domain() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>* _internal_mutable_domain();
  public:
  const ::xray::app::router::Domain& domain(int index) const;
  ::xray::app::router::Domain* add_domain();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain >&
      domain() const;
  // repeated .xray.app.router.CIDR cidr = 3 [deprecated = true];
  [[deprecated]]  int cidr_size() const;
  private:
  int _internal_cidr_size() const;

  public:
  [[deprecated]]  void clear_cidr() ;
  [[deprecated]] ::xray::app::router::CIDR* mutable_cidr(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR >*
      mutable_cidr();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>& _internal_cidr() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>* _internal_mutable_cidr();
  public:
  [[deprecated]] const ::xray::app::router::CIDR& cidr(int index) const;
  [[deprecated]] ::xray::app::router::CIDR* add_cidr();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR >&
      cidr() const;
  // repeated .xray.app.router.CIDR source_cidr = 6 [deprecated = true];
  [[deprecated]]  int source_cidr_size() const;
  private:
  int _internal_source_cidr_size() const;

  public:
  [[deprecated]]  void clear_source_cidr() ;
  [[deprecated]] ::xray::app::router::CIDR* mutable_source_cidr(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR >*
      mutable_source_cidr();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>& _internal_source_cidr() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>* _internal_mutable_source_cidr();
  public:
  [[deprecated]] const ::xray::app::router::CIDR& source_cidr(int index) const;
  [[deprecated]] ::xray::app::router::CIDR* add_source_cidr();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR >&
      source_cidr() const;
  // repeated string user_email = 7;
  int user_email_size() const;
  private:
  int _internal_user_email_size() const;

  public:
  void clear_user_email() ;
  const std::string& user_email(int index) const;
  std::string* mutable_user_email(int index);
  void set_user_email(int index, const std::string& value);
  void set_user_email(int index, std::string&& value);
  void set_user_email(int index, const char* value);
  void set_user_email(int index, const char* value, std::size_t size);
  void set_user_email(int index, absl::string_view value);
  std::string* add_user_email();
  void add_user_email(const std::string& value);
  void add_user_email(std::string&& value);
  void add_user_email(const char* value);
  void add_user_email(const char* value, std::size_t size);
  void add_user_email(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& user_email() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_user_email();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_user_email() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_user_email();

  public:
  // repeated string inbound_tag = 8;
  int inbound_tag_size() const;
  private:
  int _internal_inbound_tag_size() const;

  public:
  void clear_inbound_tag() ;
  const std::string& inbound_tag(int index) const;
  std::string* mutable_inbound_tag(int index);
  void set_inbound_tag(int index, const std::string& value);
  void set_inbound_tag(int index, std::string&& value);
  void set_inbound_tag(int index, const char* value);
  void set_inbound_tag(int index, const char* value, std::size_t size);
  void set_inbound_tag(int index, absl::string_view value);
  std::string* add_inbound_tag();
  void add_inbound_tag(const std::string& value);
  void add_inbound_tag(std::string&& value);
  void add_inbound_tag(const char* value);
  void add_inbound_tag(const char* value, std::size_t size);
  void add_inbound_tag(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& inbound_tag() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_inbound_tag();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_inbound_tag() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_inbound_tag();

  public:
  // repeated string protocol = 9;
  int protocol_size() const;
  private:
  int _internal_protocol_size() const;

  public:
  void clear_protocol() ;
  const std::string& protocol(int index) const;
  std::string* mutable_protocol(int index);
  void set_protocol(int index, const std::string& value);
  void set_protocol(int index, std::string&& value);
  void set_protocol(int index, const char* value);
  void set_protocol(int index, const char* value, std::size_t size);
  void set_protocol(int index, absl::string_view value);
  std::string* add_protocol();
  void add_protocol(const std::string& value);
  void add_protocol(std::string&& value);
  void add_protocol(const char* value);
  void add_protocol(const char* value, std::size_t size);
  void add_protocol(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& protocol() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_protocol();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_protocol() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_protocol();

  public:
  // repeated .xray.app.router.GeoIP geoip = 10;
  int geoip_size() const;
  private:
  int _internal_geoip_size() const;

  public:
  void clear_geoip() ;
  ::xray::app::router::GeoIP* mutable_geoip(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >*
      mutable_geoip();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& _internal_geoip() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* _internal_mutable_geoip();
  public:
  const ::xray::app::router::GeoIP& geoip(int index) const;
  ::xray::app::router::GeoIP* add_geoip();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >&
      geoip() const;
  // repeated .xray.app.router.GeoIP source_geoip = 11;
  int source_geoip_size() const;
  private:
  int _internal_source_geoip_size() const;

  public:
  void clear_source_geoip() ;
  ::xray::app::router::GeoIP* mutable_source_geoip(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >*
      mutable_source_geoip();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& _internal_source_geoip() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* _internal_mutable_source_geoip();
  public:
  const ::xray::app::router::GeoIP& source_geoip(int index) const;
  ::xray::app::router::GeoIP* add_source_geoip();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >&
      source_geoip() const;
  // repeated .xray.common.net.Network networks = 13;
  int networks_size() const;
  private:
  int _internal_networks_size() const;

  public:
  void clear_networks() ;
  public:
  ::xray::common::net::Network networks(int index) const;
  void set_networks(int index, ::xray::common::net::Network value);
  void add_networks(::xray::common::net::Network value);
  const ::google::protobuf::RepeatedField<int>& networks() const;
  ::google::protobuf::RepeatedField<int>* mutable_networks();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_networks() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_networks();

  public:
  // map<string, string> attributes = 15;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  const ::google::protobuf::Map<std::string, std::string>& attributes() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_attributes();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_attributes() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_attributes();

  public:
  // string domain_matcher = 17;
  void clear_domain_matcher() ;
  const std::string& domain_matcher() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain_matcher(Arg_&& arg, Args_... args);
  std::string* mutable_domain_matcher();
  PROTOBUF_NODISCARD std::string* release_domain_matcher();
  void set_allocated_domain_matcher(std::string* value);

  private:
  const std::string& _internal_domain_matcher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain_matcher(
      const std::string& value);
  std::string* _internal_mutable_domain_matcher();

  public:
  // .xray.common.net.PortRange port_range = 4 [deprecated = true];
  [[deprecated]]  bool has_port_range() const;
  [[deprecated]]  void clear_port_range() ;
  [[deprecated]] const ::xray::common::net::PortRange& port_range() const;
  [[deprecated]] PROTOBUF_NODISCARD ::xray::common::net::PortRange* release_port_range();
  [[deprecated]] ::xray::common::net::PortRange* mutable_port_range();
  [[deprecated]] void set_allocated_port_range(::xray::common::net::PortRange* value);
  [[deprecated]] void unsafe_arena_set_allocated_port_range(::xray::common::net::PortRange* value);
  [[deprecated]] ::xray::common::net::PortRange* unsafe_arena_release_port_range();

  private:
  const ::xray::common::net::PortRange& _internal_port_range() const;
  ::xray::common::net::PortRange* _internal_mutable_port_range();

  public:
  // .xray.common.net.NetworkList network_list = 5 [deprecated = true];
  [[deprecated]]  bool has_network_list() const;
  [[deprecated]]  void clear_network_list() ;
  [[deprecated]] const ::xray::common::net::NetworkList& network_list() const;
  [[deprecated]] PROTOBUF_NODISCARD ::xray::common::net::NetworkList* release_network_list();
  [[deprecated]] ::xray::common::net::NetworkList* mutable_network_list();
  [[deprecated]] void set_allocated_network_list(::xray::common::net::NetworkList* value);
  [[deprecated]] void unsafe_arena_set_allocated_network_list(::xray::common::net::NetworkList* value);
  [[deprecated]] ::xray::common::net::NetworkList* unsafe_arena_release_network_list();

  private:
  const ::xray::common::net::NetworkList& _internal_network_list() const;
  ::xray::common::net::NetworkList* _internal_mutable_network_list();

  public:
  // .xray.common.net.PortList port_list = 14;
  bool has_port_list() const;
  void clear_port_list() ;
  const ::xray::common::net::PortList& port_list() const;
  PROTOBUF_NODISCARD ::xray::common::net::PortList* release_port_list();
  ::xray::common::net::PortList* mutable_port_list();
  void set_allocated_port_list(::xray::common::net::PortList* value);
  void unsafe_arena_set_allocated_port_list(::xray::common::net::PortList* value);
  ::xray::common::net::PortList* unsafe_arena_release_port_list();

  private:
  const ::xray::common::net::PortList& _internal_port_list() const;
  ::xray::common::net::PortList* _internal_mutable_port_list();

  public:
  // .xray.common.net.PortList source_port_list = 16;
  bool has_source_port_list() const;
  void clear_source_port_list() ;
  const ::xray::common::net::PortList& source_port_list() const;
  PROTOBUF_NODISCARD ::xray::common::net::PortList* release_source_port_list();
  ::xray::common::net::PortList* mutable_source_port_list();
  void set_allocated_source_port_list(::xray::common::net::PortList* value);
  void unsafe_arena_set_allocated_source_port_list(::xray::common::net::PortList* value);
  ::xray::common::net::PortList* unsafe_arena_release_source_port_list();

  private:
  const ::xray::common::net::PortList& _internal_source_port_list() const;
  ::xray::common::net::PortList* _internal_mutable_source_port_list();

  public:
  // string tag = 1;
  bool has_tag() const;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // string balancing_tag = 12;
  bool has_balancing_tag() const;
  void clear_balancing_tag() ;
  const std::string& balancing_tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balancing_tag(Arg_&& arg, Args_... args);
  std::string* mutable_balancing_tag();
  PROTOBUF_NODISCARD std::string* release_balancing_tag();
  void set_allocated_balancing_tag(std::string* value);

  private:
  const std::string& _internal_balancing_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balancing_tag(
      const std::string& value);
  std::string* _internal_mutable_balancing_tag();

  public:
  void clear_target_tag();
  TargetTagCase target_tag_case() const;
  // @@protoc_insertion_point(class_scope:xray.app.router.RoutingRule)
 private:
  class _Internal;
  void set_has_tag();
  void set_has_balancing_tag();

  inline bool has_target_tag() const;
  inline void clear_has_target_tag();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 17, 10,
      121, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain > domain_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR > cidr_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::CIDR > source_cidr_;
    ::google::protobuf::RepeatedPtrField<std::string> user_email_;
    ::google::protobuf::RepeatedPtrField<std::string> inbound_tag_;
    ::google::protobuf::RepeatedPtrField<std::string> protocol_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP > geoip_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP > source_geoip_;
    ::google::protobuf::RepeatedField<int> networks_;
    mutable ::google::protobuf::internal::CachedSize _networks_cached_byte_size_;
    ::google::protobuf::internal::MapField<RoutingRule_AttributesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        attributes_;
    ::google::protobuf::internal::ArenaStringPtr domain_matcher_;
    ::xray::common::net::PortRange* port_range_;
    ::xray::common::net::NetworkList* network_list_;
    ::xray::common::net::PortList* port_list_;
    ::xray::common::net::PortList* source_port_list_;
    union TargetTagUnion {
      constexpr TargetTagUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr tag_;
      ::google::protobuf::internal::ArenaStringPtr balancing_tag_;
    } target_tag_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class GeoSite final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.GeoSite) */ {
 public:
  inline GeoSite() : GeoSite(nullptr) {}
  ~GeoSite() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeoSite(::google::protobuf::internal::ConstantInitialized);

  inline GeoSite(const GeoSite& from)
      : GeoSite(nullptr, from) {}
  GeoSite(GeoSite&& from) noexcept
    : GeoSite() {
    *this = ::std::move(from);
  }

  inline GeoSite& operator=(const GeoSite& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoSite& operator=(GeoSite&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoSite& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoSite* internal_default_instance() {
    return reinterpret_cast<const GeoSite*>(
               &_GeoSite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GeoSite& a, GeoSite& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoSite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoSite* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoSite* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoSite>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoSite& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GeoSite& from) {
    GeoSite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoSite* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.GeoSite";
  }
  protected:
  explicit GeoSite(::google::protobuf::Arena* arena);
  GeoSite(::google::protobuf::Arena* arena, const GeoSite& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 2,
    kCountryCodeFieldNumber = 1,
  };
  // repeated .xray.app.router.Domain domain = 2;
  int domain_size() const;
  private:
  int _internal_domain_size() const;

  public:
  void clear_domain() ;
  ::xray::app::router::Domain* mutable_domain(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain >*
      mutable_domain();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>& _internal_domain() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>* _internal_mutable_domain();
  public:
  const ::xray::app::router::Domain& domain(int index) const;
  ::xray::app::router::Domain* add_domain();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain >&
      domain() const;
  // string country_code = 1;
  void clear_country_code() ;
  const std::string& country_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country_code(Arg_&& arg, Args_... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* value);

  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(
      const std::string& value);
  std::string* _internal_mutable_country_code();

  public:
  // @@protoc_insertion_point(class_scope:xray.app.router.GeoSite)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::Domain > domain_;
    ::google::protobuf::internal::ArenaStringPtr country_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class GeoIPList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.GeoIPList) */ {
 public:
  inline GeoIPList() : GeoIPList(nullptr) {}
  ~GeoIPList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeoIPList(::google::protobuf::internal::ConstantInitialized);

  inline GeoIPList(const GeoIPList& from)
      : GeoIPList(nullptr, from) {}
  GeoIPList(GeoIPList&& from) noexcept
    : GeoIPList() {
    *this = ::std::move(from);
  }

  inline GeoIPList& operator=(const GeoIPList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoIPList& operator=(GeoIPList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoIPList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoIPList* internal_default_instance() {
    return reinterpret_cast<const GeoIPList*>(
               &_GeoIPList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GeoIPList& a, GeoIPList& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoIPList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoIPList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoIPList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoIPList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoIPList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GeoIPList& from) {
    GeoIPList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoIPList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.GeoIPList";
  }
  protected:
  explicit GeoIPList(::google::protobuf::Arena* arena);
  GeoIPList(::google::protobuf::Arena* arena, const GeoIPList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .xray.app.router.GeoIP entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;

  public:
  void clear_entry() ;
  ::xray::app::router::GeoIP* mutable_entry(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >*
      mutable_entry();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& _internal_entry() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* _internal_mutable_entry();
  public:
  const ::xray::app::router::GeoIP& entry(int index) const;
  ::xray::app::router::GeoIP* add_entry();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP >&
      entry() const;
  // @@protoc_insertion_point(class_scope:xray.app.router.GeoIPList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoIP > entry_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class GeoSiteList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.GeoSiteList) */ {
 public:
  inline GeoSiteList() : GeoSiteList(nullptr) {}
  ~GeoSiteList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeoSiteList(::google::protobuf::internal::ConstantInitialized);

  inline GeoSiteList(const GeoSiteList& from)
      : GeoSiteList(nullptr, from) {}
  GeoSiteList(GeoSiteList&& from) noexcept
    : GeoSiteList() {
    *this = ::std::move(from);
  }

  inline GeoSiteList& operator=(const GeoSiteList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoSiteList& operator=(GeoSiteList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoSiteList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoSiteList* internal_default_instance() {
    return reinterpret_cast<const GeoSiteList*>(
               &_GeoSiteList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GeoSiteList& a, GeoSiteList& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoSiteList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoSiteList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoSiteList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoSiteList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeoSiteList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GeoSiteList& from) {
    GeoSiteList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GeoSiteList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.GeoSiteList";
  }
  protected:
  explicit GeoSiteList(::google::protobuf::Arena* arena);
  GeoSiteList(::google::protobuf::Arena* arena, const GeoSiteList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .xray.app.router.GeoSite entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;

  public:
  void clear_entry() ;
  ::xray::app::router::GeoSite* mutable_entry(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoSite >*
      mutable_entry();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoSite>& _internal_entry() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoSite>* _internal_mutable_entry();
  public:
  const ::xray::app::router::GeoSite& entry(int index) const;
  ::xray::app::router::GeoSite* add_entry();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoSite >&
      entry() const;
  // @@protoc_insertion_point(class_scope:xray.app.router.GeoSiteList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::GeoSite > entry_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xray.app.router.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Config(::google::protobuf::internal::ConstantInitialized);

  inline Config(const Config& from)
      : Config(nullptr, from) {}
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "xray.app.router.Config";
  }
  protected:
  explicit Config(::google::protobuf::Arena* arena);
  Config(::google::protobuf::Arena* arena, const Config& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DomainStrategy = Config_DomainStrategy;
  static constexpr DomainStrategy AsIs = Config_DomainStrategy_AsIs;
  static constexpr DomainStrategy UseIp = Config_DomainStrategy_UseIp;
  static constexpr DomainStrategy IpIfNonMatch = Config_DomainStrategy_IpIfNonMatch;
  static constexpr DomainStrategy IpOnDemand = Config_DomainStrategy_IpOnDemand;
  static inline bool DomainStrategy_IsValid(int value) {
    return Config_DomainStrategy_IsValid(value);
  }
  static constexpr DomainStrategy DomainStrategy_MIN = Config_DomainStrategy_DomainStrategy_MIN;
  static constexpr DomainStrategy DomainStrategy_MAX = Config_DomainStrategy_DomainStrategy_MAX;
  static constexpr int DomainStrategy_ARRAYSIZE = Config_DomainStrategy_DomainStrategy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DomainStrategy_descriptor() {
    return Config_DomainStrategy_descriptor();
  }
  template <typename T>
  static inline const std::string& DomainStrategy_Name(T value) {
    return Config_DomainStrategy_Name(value);
  }
  static inline bool DomainStrategy_Parse(absl::string_view name, DomainStrategy* value) {
    return Config_DomainStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRuleFieldNumber = 2,
    kBalancingRuleFieldNumber = 3,
    kDomainStrategyFieldNumber = 1,
  };
  // repeated .xray.app.router.RoutingRule rule = 2;
  int rule_size() const;
  private:
  int _internal_rule_size() const;

  public:
  void clear_rule() ;
  ::xray::app::router::RoutingRule* mutable_rule(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::RoutingRule >*
      mutable_rule();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::RoutingRule>& _internal_rule() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::RoutingRule>* _internal_mutable_rule();
  public:
  const ::xray::app::router::RoutingRule& rule(int index) const;
  ::xray::app::router::RoutingRule* add_rule();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::RoutingRule >&
      rule() const;
  // repeated .xray.app.router.BalancingRule balancing_rule = 3;
  int balancing_rule_size() const;
  private:
  int _internal_balancing_rule_size() const;

  public:
  void clear_balancing_rule() ;
  ::xray::app::router::BalancingRule* mutable_balancing_rule(int index);
  ::google::protobuf::RepeatedPtrField< ::xray::app::router::BalancingRule >*
      mutable_balancing_rule();
  private:
  const ::google::protobuf::RepeatedPtrField<::xray::app::router::BalancingRule>& _internal_balancing_rule() const;
  ::google::protobuf::RepeatedPtrField<::xray::app::router::BalancingRule>* _internal_mutable_balancing_rule();
  public:
  const ::xray::app::router::BalancingRule& balancing_rule(int index) const;
  ::xray::app::router::BalancingRule* add_balancing_rule();
  const ::google::protobuf::RepeatedPtrField< ::xray::app::router::BalancingRule >&
      balancing_rule() const;
  // .xray.app.router.Config.DomainStrategy domain_strategy = 1;
  void clear_domain_strategy() ;
  ::xray::app::router::Config_DomainStrategy domain_strategy() const;
  void set_domain_strategy(::xray::app::router::Config_DomainStrategy value);

  private:
  ::xray::app::router::Config_DomainStrategy _internal_domain_strategy() const;
  void _internal_set_domain_strategy(::xray::app::router::Config_DomainStrategy value);

  public:
  // @@protoc_insertion_point(class_scope:xray.app.router.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::RoutingRule > rule_;
    ::google::protobuf::RepeatedPtrField< ::xray::app::router::BalancingRule > balancing_rule_;
    int domain_strategy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_app_2frouter_2fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Domain_Attribute

// string key = 1;
inline void Domain_Attribute::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Domain_Attribute::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.Domain.Attribute.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Domain_Attribute::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.Domain.Attribute.key)
}
inline std::string* Domain_Attribute::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:xray.app.router.Domain.Attribute.key)
  return _s;
}
inline const std::string& Domain_Attribute::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void Domain_Attribute::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* Domain_Attribute::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* Domain_Attribute::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.Domain.Attribute.key)
  return _impl_.key_.Release();
}
inline void Domain_Attribute::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.Domain.Attribute.key)
}

// bool bool_value = 2;
inline bool Domain_Attribute::has_bool_value() const {
  return typed_value_case() == kBoolValue;
}
inline void Domain_Attribute::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void Domain_Attribute::clear_bool_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kBoolValue) {
    _impl_.typed_value_.bool_value_ = false;
    clear_has_typed_value();
  }
}
inline bool Domain_Attribute::bool_value() const {
  // @@protoc_insertion_point(field_get:xray.app.router.Domain.Attribute.bool_value)
  return _internal_bool_value();
}
inline void Domain_Attribute::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:xray.app.router.Domain.Attribute.bool_value)
}
inline bool Domain_Attribute::_internal_bool_value() const {
  if (typed_value_case() == kBoolValue) {
    return _impl_.typed_value_.bool_value_;
  }
  return false;
}
inline void Domain_Attribute::_internal_set_bool_value(bool value) {
  if (typed_value_case() != kBoolValue) {
    clear_typed_value();
    set_has_bool_value();
  }
  _impl_.typed_value_.bool_value_ = value;
}

// int64 int_value = 3;
inline bool Domain_Attribute::has_int_value() const {
  return typed_value_case() == kIntValue;
}
inline void Domain_Attribute::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void Domain_Attribute::clear_int_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (typed_value_case() == kIntValue) {
    _impl_.typed_value_.int_value_ = ::int64_t{0};
    clear_has_typed_value();
  }
}
inline ::int64_t Domain_Attribute::int_value() const {
  // @@protoc_insertion_point(field_get:xray.app.router.Domain.Attribute.int_value)
  return _internal_int_value();
}
inline void Domain_Attribute::set_int_value(::int64_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:xray.app.router.Domain.Attribute.int_value)
}
inline ::int64_t Domain_Attribute::_internal_int_value() const {
  if (typed_value_case() == kIntValue) {
    return _impl_.typed_value_.int_value_;
  }
  return ::int64_t{0};
}
inline void Domain_Attribute::_internal_set_int_value(::int64_t value) {
  if (typed_value_case() != kIntValue) {
    clear_typed_value();
    set_has_int_value();
  }
  _impl_.typed_value_.int_value_ = value;
}

inline bool Domain_Attribute::has_typed_value() const {
  return typed_value_case() != TYPED_VALUE_NOT_SET;
}
inline void Domain_Attribute::clear_has_typed_value() {
  _impl_._oneof_case_[0] = TYPED_VALUE_NOT_SET;
}
inline Domain_Attribute::TypedValueCase Domain_Attribute::typed_value_case() const {
  return Domain_Attribute::TypedValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Domain

// .xray.app.router.Domain.Type type = 1;
inline void Domain::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::xray::app::router::Domain_Type Domain::type() const {
  // @@protoc_insertion_point(field_get:xray.app.router.Domain.type)
  return _internal_type();
}
inline void Domain::set_type(::xray::app::router::Domain_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:xray.app.router.Domain.type)
}
inline ::xray::app::router::Domain_Type Domain::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::app::router::Domain_Type>(_impl_.type_);
}
inline void Domain::_internal_set_type(::xray::app::router::Domain_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string value = 2;
inline void Domain::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Domain::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.Domain.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Domain::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.Domain.value)
}
inline std::string* Domain::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:xray.app.router.Domain.value)
  return _s;
}
inline const std::string& Domain::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void Domain::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Domain::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Domain::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.Domain.value)
  return _impl_.value_.Release();
}
inline void Domain::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.Domain.value)
}

// repeated .xray.app.router.Domain.Attribute attribute = 3;
inline int Domain::_internal_attribute_size() const {
  return _internal_attribute().size();
}
inline int Domain::attribute_size() const {
  return _internal_attribute_size();
}
inline void Domain::clear_attribute() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attribute_.Clear();
}
inline ::xray::app::router::Domain_Attribute* Domain::mutable_attribute(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.Domain.attribute)
  return _internal_mutable_attribute()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain_Attribute>* Domain::mutable_attribute()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.Domain.attribute)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attribute();
}
inline const ::xray::app::router::Domain_Attribute& Domain::attribute(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.Domain.attribute)
  return _internal_attribute().Get(index);
}
inline ::xray::app::router::Domain_Attribute* Domain::add_attribute() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::Domain_Attribute* _add = _internal_mutable_attribute()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.Domain.attribute)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain_Attribute>& Domain::attribute() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.Domain.attribute)
  return _internal_attribute();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain_Attribute>&
Domain::_internal_attribute() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attribute_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain_Attribute>*
Domain::_internal_mutable_attribute() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attribute_;
}

// -------------------------------------------------------------------

// CIDR

// bytes ip = 1;
inline void CIDR::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& CIDR::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.CIDR.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CIDR::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.CIDR.ip)
}
inline std::string* CIDR::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:xray.app.router.CIDR.ip)
  return _s;
}
inline const std::string& CIDR::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void CIDR::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* CIDR::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* CIDR::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.CIDR.ip)
  return _impl_.ip_.Release();
}
inline void CIDR::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.CIDR.ip)
}

// uint32 prefix = 2;
inline void CIDR::clear_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prefix_ = 0u;
}
inline ::uint32_t CIDR::prefix() const {
  // @@protoc_insertion_point(field_get:xray.app.router.CIDR.prefix)
  return _internal_prefix();
}
inline void CIDR::set_prefix(::uint32_t value) {
  _internal_set_prefix(value);
  // @@protoc_insertion_point(field_set:xray.app.router.CIDR.prefix)
}
inline ::uint32_t CIDR::_internal_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prefix_;
}
inline void CIDR::_internal_set_prefix(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prefix_ = value;
}

// -------------------------------------------------------------------

// GeoIP

// string country_code = 1;
inline void GeoIP::clear_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_code_.ClearToEmpty();
}
inline const std::string& GeoIP::country_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.GeoIP.country_code)
  return _internal_country_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GeoIP::set_country_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.GeoIP.country_code)
}
inline std::string* GeoIP::mutable_country_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:xray.app.router.GeoIP.country_code)
  return _s;
}
inline const std::string& GeoIP::_internal_country_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.country_code_.Get();
}
inline void GeoIP::_internal_set_country_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_code_.Set(value, GetArena());
}
inline std::string* GeoIP::_internal_mutable_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.country_code_.Mutable( GetArena());
}
inline std::string* GeoIP::release_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.GeoIP.country_code)
  return _impl_.country_code_.Release();
}
inline void GeoIP::set_allocated_country_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.country_code_.IsDefault()) {
          _impl_.country_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.GeoIP.country_code)
}

// repeated .xray.app.router.CIDR cidr = 2;
inline int GeoIP::_internal_cidr_size() const {
  return _internal_cidr().size();
}
inline int GeoIP::cidr_size() const {
  return _internal_cidr_size();
}
inline void GeoIP::clear_cidr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cidr_.Clear();
}
inline ::xray::app::router::CIDR* GeoIP::mutable_cidr(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.GeoIP.cidr)
  return _internal_mutable_cidr()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>* GeoIP::mutable_cidr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.GeoIP.cidr)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cidr();
}
inline const ::xray::app::router::CIDR& GeoIP::cidr(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.GeoIP.cidr)
  return _internal_cidr().Get(index);
}
inline ::xray::app::router::CIDR* GeoIP::add_cidr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::CIDR* _add = _internal_mutable_cidr()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.GeoIP.cidr)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>& GeoIP::cidr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.GeoIP.cidr)
  return _internal_cidr();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>&
GeoIP::_internal_cidr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cidr_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>*
GeoIP::_internal_mutable_cidr() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cidr_;
}

// bool reverse_match = 3;
inline void GeoIP::clear_reverse_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reverse_match_ = false;
}
inline bool GeoIP::reverse_match() const {
  // @@protoc_insertion_point(field_get:xray.app.router.GeoIP.reverse_match)
  return _internal_reverse_match();
}
inline void GeoIP::set_reverse_match(bool value) {
  _internal_set_reverse_match(value);
  // @@protoc_insertion_point(field_set:xray.app.router.GeoIP.reverse_match)
}
inline bool GeoIP::_internal_reverse_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reverse_match_;
}
inline void GeoIP::_internal_set_reverse_match(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reverse_match_ = value;
}

// -------------------------------------------------------------------

// GeoIPList

// repeated .xray.app.router.GeoIP entry = 1;
inline int GeoIPList::_internal_entry_size() const {
  return _internal_entry().size();
}
inline int GeoIPList::entry_size() const {
  return _internal_entry_size();
}
inline void GeoIPList::clear_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entry_.Clear();
}
inline ::xray::app::router::GeoIP* GeoIPList::mutable_entry(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.GeoIPList.entry)
  return _internal_mutable_entry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* GeoIPList::mutable_entry()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.GeoIPList.entry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entry();
}
inline const ::xray::app::router::GeoIP& GeoIPList::entry(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.GeoIPList.entry)
  return _internal_entry().Get(index);
}
inline ::xray::app::router::GeoIP* GeoIPList::add_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::GeoIP* _add = _internal_mutable_entry()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.GeoIPList.entry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& GeoIPList::entry() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.GeoIPList.entry)
  return _internal_entry();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>&
GeoIPList::_internal_entry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entry_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>*
GeoIPList::_internal_mutable_entry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entry_;
}

// -------------------------------------------------------------------

// GeoSite

// string country_code = 1;
inline void GeoSite::clear_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_code_.ClearToEmpty();
}
inline const std::string& GeoSite::country_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.GeoSite.country_code)
  return _internal_country_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GeoSite::set_country_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.GeoSite.country_code)
}
inline std::string* GeoSite::mutable_country_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:xray.app.router.GeoSite.country_code)
  return _s;
}
inline const std::string& GeoSite::_internal_country_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.country_code_.Get();
}
inline void GeoSite::_internal_set_country_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_code_.Set(value, GetArena());
}
inline std::string* GeoSite::_internal_mutable_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.country_code_.Mutable( GetArena());
}
inline std::string* GeoSite::release_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.GeoSite.country_code)
  return _impl_.country_code_.Release();
}
inline void GeoSite::set_allocated_country_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.country_code_.IsDefault()) {
          _impl_.country_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.GeoSite.country_code)
}

// repeated .xray.app.router.Domain domain = 2;
inline int GeoSite::_internal_domain_size() const {
  return _internal_domain().size();
}
inline int GeoSite::domain_size() const {
  return _internal_domain_size();
}
inline void GeoSite::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.Clear();
}
inline ::xray::app::router::Domain* GeoSite::mutable_domain(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.GeoSite.domain)
  return _internal_mutable_domain()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>* GeoSite::mutable_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.GeoSite.domain)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_domain();
}
inline const ::xray::app::router::Domain& GeoSite::domain(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.GeoSite.domain)
  return _internal_domain().Get(index);
}
inline ::xray::app::router::Domain* GeoSite::add_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::Domain* _add = _internal_mutable_domain()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.GeoSite.domain)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>& GeoSite::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.GeoSite.domain)
  return _internal_domain();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>&
GeoSite::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>*
GeoSite::_internal_mutable_domain() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.domain_;
}

// -------------------------------------------------------------------

// GeoSiteList

// repeated .xray.app.router.GeoSite entry = 1;
inline int GeoSiteList::_internal_entry_size() const {
  return _internal_entry().size();
}
inline int GeoSiteList::entry_size() const {
  return _internal_entry_size();
}
inline void GeoSiteList::clear_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entry_.Clear();
}
inline ::xray::app::router::GeoSite* GeoSiteList::mutable_entry(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.GeoSiteList.entry)
  return _internal_mutable_entry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoSite>* GeoSiteList::mutable_entry()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.GeoSiteList.entry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entry();
}
inline const ::xray::app::router::GeoSite& GeoSiteList::entry(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.GeoSiteList.entry)
  return _internal_entry().Get(index);
}
inline ::xray::app::router::GeoSite* GeoSiteList::add_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::GeoSite* _add = _internal_mutable_entry()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.GeoSiteList.entry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoSite>& GeoSiteList::entry() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.GeoSiteList.entry)
  return _internal_entry();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoSite>&
GeoSiteList::_internal_entry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entry_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoSite>*
GeoSiteList::_internal_mutable_entry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entry_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RoutingRule

// string tag = 1;
inline bool RoutingRule::has_tag() const {
  return target_tag_case() == kTag;
}
inline void RoutingRule::set_has_tag() {
  _impl_._oneof_case_[0] = kTag;
}
inline void RoutingRule::clear_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() == kTag) {
    _impl_.target_tag_.tag_.Destroy();
    clear_has_target_tag();
  }
}
inline const std::string& RoutingRule::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoutingRule::set_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() != kTag) {
    clear_target_tag();

    set_has_tag();
    _impl_.target_tag_.tag_.InitDefault();
  }
  _impl_.target_tag_.tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.tag)
}
inline std::string* RoutingRule::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.tag)
  return _s;
}
inline const std::string& RoutingRule::_internal_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (target_tag_case() != kTag) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.target_tag_.tag_.Get();
}
inline void RoutingRule::_internal_set_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() != kTag) {
    clear_target_tag();

    set_has_tag();
    _impl_.target_tag_.tag_.InitDefault();
  }
  _impl_.target_tag_.tag_.Set(value, GetArena());
}
inline std::string* RoutingRule::_internal_mutable_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() != kTag) {
    clear_target_tag();

    set_has_tag();
    _impl_.target_tag_.tag_.InitDefault();
  }
  return _impl_.target_tag_.tag_.Mutable( GetArena());
}
inline std::string* RoutingRule::release_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.RoutingRule.tag)
  if (target_tag_case() != kTag) {
    return nullptr;
  }
  clear_has_target_tag();
  return _impl_.target_tag_.tag_.Release();
}
inline void RoutingRule::set_allocated_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_target_tag()) {
    clear_target_tag();
  }
  if (value != nullptr) {
    set_has_tag();
    _impl_.target_tag_.tag_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.RoutingRule.tag)
}

// string balancing_tag = 12;
inline bool RoutingRule::has_balancing_tag() const {
  return target_tag_case() == kBalancingTag;
}
inline void RoutingRule::set_has_balancing_tag() {
  _impl_._oneof_case_[0] = kBalancingTag;
}
inline void RoutingRule::clear_balancing_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() == kBalancingTag) {
    _impl_.target_tag_.balancing_tag_.Destroy();
    clear_has_target_tag();
  }
}
inline const std::string& RoutingRule::balancing_tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.balancing_tag)
  return _internal_balancing_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoutingRule::set_balancing_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() != kBalancingTag) {
    clear_target_tag();

    set_has_balancing_tag();
    _impl_.target_tag_.balancing_tag_.InitDefault();
  }
  _impl_.target_tag_.balancing_tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.balancing_tag)
}
inline std::string* RoutingRule::mutable_balancing_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_balancing_tag();
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.balancing_tag)
  return _s;
}
inline const std::string& RoutingRule::_internal_balancing_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (target_tag_case() != kBalancingTag) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.target_tag_.balancing_tag_.Get();
}
inline void RoutingRule::_internal_set_balancing_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() != kBalancingTag) {
    clear_target_tag();

    set_has_balancing_tag();
    _impl_.target_tag_.balancing_tag_.InitDefault();
  }
  _impl_.target_tag_.balancing_tag_.Set(value, GetArena());
}
inline std::string* RoutingRule::_internal_mutable_balancing_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (target_tag_case() != kBalancingTag) {
    clear_target_tag();

    set_has_balancing_tag();
    _impl_.target_tag_.balancing_tag_.InitDefault();
  }
  return _impl_.target_tag_.balancing_tag_.Mutable( GetArena());
}
inline std::string* RoutingRule::release_balancing_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.RoutingRule.balancing_tag)
  if (target_tag_case() != kBalancingTag) {
    return nullptr;
  }
  clear_has_target_tag();
  return _impl_.target_tag_.balancing_tag_.Release();
}
inline void RoutingRule::set_allocated_balancing_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_target_tag()) {
    clear_target_tag();
  }
  if (value != nullptr) {
    set_has_balancing_tag();
    _impl_.target_tag_.balancing_tag_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.RoutingRule.balancing_tag)
}

// repeated .xray.app.router.Domain domain = 2;
inline int RoutingRule::_internal_domain_size() const {
  return _internal_domain().size();
}
inline int RoutingRule::domain_size() const {
  return _internal_domain_size();
}
inline void RoutingRule::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.Clear();
}
inline ::xray::app::router::Domain* RoutingRule::mutable_domain(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.domain)
  return _internal_mutable_domain()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>* RoutingRule::mutable_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.domain)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_domain();
}
inline const ::xray::app::router::Domain& RoutingRule::domain(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.domain)
  return _internal_domain().Get(index);
}
inline ::xray::app::router::Domain* RoutingRule::add_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::Domain* _add = _internal_mutable_domain()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.domain)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>& RoutingRule::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.domain)
  return _internal_domain();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>&
RoutingRule::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::Domain>*
RoutingRule::_internal_mutable_domain() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.domain_;
}

// repeated .xray.app.router.CIDR cidr = 3 [deprecated = true];
inline int RoutingRule::_internal_cidr_size() const {
  return _internal_cidr().size();
}
inline int RoutingRule::cidr_size() const {
  return _internal_cidr_size();
}
inline void RoutingRule::clear_cidr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cidr_.Clear();
}
inline ::xray::app::router::CIDR* RoutingRule::mutable_cidr(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.cidr)
  return _internal_mutable_cidr()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>* RoutingRule::mutable_cidr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.cidr)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cidr();
}
inline const ::xray::app::router::CIDR& RoutingRule::cidr(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.cidr)
  return _internal_cidr().Get(index);
}
inline ::xray::app::router::CIDR* RoutingRule::add_cidr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::CIDR* _add = _internal_mutable_cidr()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.cidr)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>& RoutingRule::cidr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.cidr)
  return _internal_cidr();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>&
RoutingRule::_internal_cidr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cidr_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>*
RoutingRule::_internal_mutable_cidr() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cidr_;
}

// repeated .xray.app.router.GeoIP geoip = 10;
inline int RoutingRule::_internal_geoip_size() const {
  return _internal_geoip().size();
}
inline int RoutingRule::geoip_size() const {
  return _internal_geoip_size();
}
inline void RoutingRule::clear_geoip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.geoip_.Clear();
}
inline ::xray::app::router::GeoIP* RoutingRule::mutable_geoip(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.geoip)
  return _internal_mutable_geoip()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* RoutingRule::mutable_geoip()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.geoip)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_geoip();
}
inline const ::xray::app::router::GeoIP& RoutingRule::geoip(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.geoip)
  return _internal_geoip().Get(index);
}
inline ::xray::app::router::GeoIP* RoutingRule::add_geoip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::GeoIP* _add = _internal_mutable_geoip()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.geoip)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& RoutingRule::geoip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.geoip)
  return _internal_geoip();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>&
RoutingRule::_internal_geoip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.geoip_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>*
RoutingRule::_internal_mutable_geoip() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.geoip_;
}

// .xray.common.net.PortRange port_range = 4 [deprecated = true];
inline bool RoutingRule::has_port_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.port_range_ != nullptr);
  return value;
}
inline const ::xray::common::net::PortRange& RoutingRule::_internal_port_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::PortRange* p = _impl_.port_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::PortRange&>(::xray::common::net::_PortRange_default_instance_);
}
inline const ::xray::common::net::PortRange& RoutingRule::port_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.port_range)
  return _internal_port_range();
}
inline void RoutingRule::unsafe_arena_set_allocated_port_range(::xray::common::net::PortRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.port_range_);
  }
  _impl_.port_range_ = reinterpret_cast<::xray::common::net::PortRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.router.RoutingRule.port_range)
}
inline ::xray::common::net::PortRange* RoutingRule::release_port_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::PortRange* released = _impl_.port_range_;
  _impl_.port_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::PortRange* RoutingRule::unsafe_arena_release_port_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.RoutingRule.port_range)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xray::common::net::PortRange* temp = _impl_.port_range_;
  _impl_.port_range_ = nullptr;
  return temp;
}
inline ::xray::common::net::PortRange* RoutingRule::_internal_mutable_port_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.port_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::PortRange>(GetArena());
    _impl_.port_range_ = reinterpret_cast<::xray::common::net::PortRange*>(p);
  }
  return _impl_.port_range_;
}
inline ::xray::common::net::PortRange* RoutingRule::mutable_port_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::PortRange* _msg = _internal_mutable_port_range();
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.port_range)
  return _msg;
}
inline void RoutingRule::set_allocated_port_range(::xray::common::net::PortRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.port_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.port_range_ = reinterpret_cast<::xray::common::net::PortRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.RoutingRule.port_range)
}

// .xray.common.net.PortList port_list = 14;
inline bool RoutingRule::has_port_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.port_list_ != nullptr);
  return value;
}
inline const ::xray::common::net::PortList& RoutingRule::_internal_port_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::PortList* p = _impl_.port_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::PortList&>(::xray::common::net::_PortList_default_instance_);
}
inline const ::xray::common::net::PortList& RoutingRule::port_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.port_list)
  return _internal_port_list();
}
inline void RoutingRule::unsafe_arena_set_allocated_port_list(::xray::common::net::PortList* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.port_list_);
  }
  _impl_.port_list_ = reinterpret_cast<::xray::common::net::PortList*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.router.RoutingRule.port_list)
}
inline ::xray::common::net::PortList* RoutingRule::release_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::common::net::PortList* released = _impl_.port_list_;
  _impl_.port_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::PortList* RoutingRule::unsafe_arena_release_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.RoutingRule.port_list)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::xray::common::net::PortList* temp = _impl_.port_list_;
  _impl_.port_list_ = nullptr;
  return temp;
}
inline ::xray::common::net::PortList* RoutingRule::_internal_mutable_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.port_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::PortList>(GetArena());
    _impl_.port_list_ = reinterpret_cast<::xray::common::net::PortList*>(p);
  }
  return _impl_.port_list_;
}
inline ::xray::common::net::PortList* RoutingRule::mutable_port_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::PortList* _msg = _internal_mutable_port_list();
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.port_list)
  return _msg;
}
inline void RoutingRule::set_allocated_port_list(::xray::common::net::PortList* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.port_list_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.port_list_ = reinterpret_cast<::xray::common::net::PortList*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.RoutingRule.port_list)
}

// .xray.common.net.NetworkList network_list = 5 [deprecated = true];
inline bool RoutingRule::has_network_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.network_list_ != nullptr);
  return value;
}
inline const ::xray::common::net::NetworkList& RoutingRule::_internal_network_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::NetworkList* p = _impl_.network_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::NetworkList&>(::xray::common::net::_NetworkList_default_instance_);
}
inline const ::xray::common::net::NetworkList& RoutingRule::network_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.network_list)
  return _internal_network_list();
}
inline void RoutingRule::unsafe_arena_set_allocated_network_list(::xray::common::net::NetworkList* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.network_list_);
  }
  _impl_.network_list_ = reinterpret_cast<::xray::common::net::NetworkList*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.router.RoutingRule.network_list)
}
inline ::xray::common::net::NetworkList* RoutingRule::release_network_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::common::net::NetworkList* released = _impl_.network_list_;
  _impl_.network_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::NetworkList* RoutingRule::unsafe_arena_release_network_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.RoutingRule.network_list)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xray::common::net::NetworkList* temp = _impl_.network_list_;
  _impl_.network_list_ = nullptr;
  return temp;
}
inline ::xray::common::net::NetworkList* RoutingRule::_internal_mutable_network_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.network_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::NetworkList>(GetArena());
    _impl_.network_list_ = reinterpret_cast<::xray::common::net::NetworkList*>(p);
  }
  return _impl_.network_list_;
}
inline ::xray::common::net::NetworkList* RoutingRule::mutable_network_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::NetworkList* _msg = _internal_mutable_network_list();
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.network_list)
  return _msg;
}
inline void RoutingRule::set_allocated_network_list(::xray::common::net::NetworkList* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.network_list_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.network_list_ = reinterpret_cast<::xray::common::net::NetworkList*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.RoutingRule.network_list)
}

// repeated .xray.common.net.Network networks = 13;
inline int RoutingRule::_internal_networks_size() const {
  return _internal_networks().size();
}
inline int RoutingRule::networks_size() const {
  return _internal_networks_size();
}
inline void RoutingRule::clear_networks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.networks_.Clear();
}
inline ::xray::common::net::Network RoutingRule::networks(int index) const {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.networks)
  return static_cast<::xray::common::net::Network>(_internal_networks().Get(index));
}
inline void RoutingRule::set_networks(int index, ::xray::common::net::Network value) {
  _internal_mutable_networks()->Set(index, value);
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.networks)
}
inline void RoutingRule::add_networks(::xray::common::net::Network value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_networks()->Add(value);
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.networks)
}
inline const ::google::protobuf::RepeatedField<int>& RoutingRule::networks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.networks)
  return _internal_networks();
}
inline ::google::protobuf::RepeatedField<int>* RoutingRule::mutable_networks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.networks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_networks();
}
inline const ::google::protobuf::RepeatedField<int>& RoutingRule::_internal_networks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.networks_;
}
inline ::google::protobuf::RepeatedField<int>* RoutingRule::_internal_mutable_networks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.networks_;
}

// repeated .xray.app.router.CIDR source_cidr = 6 [deprecated = true];
inline int RoutingRule::_internal_source_cidr_size() const {
  return _internal_source_cidr().size();
}
inline int RoutingRule::source_cidr_size() const {
  return _internal_source_cidr_size();
}
inline void RoutingRule::clear_source_cidr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_cidr_.Clear();
}
inline ::xray::app::router::CIDR* RoutingRule::mutable_source_cidr(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.source_cidr)
  return _internal_mutable_source_cidr()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>* RoutingRule::mutable_source_cidr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.source_cidr)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_source_cidr();
}
inline const ::xray::app::router::CIDR& RoutingRule::source_cidr(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.source_cidr)
  return _internal_source_cidr().Get(index);
}
inline ::xray::app::router::CIDR* RoutingRule::add_source_cidr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::CIDR* _add = _internal_mutable_source_cidr()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.source_cidr)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>& RoutingRule::source_cidr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.source_cidr)
  return _internal_source_cidr();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>&
RoutingRule::_internal_source_cidr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_cidr_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::CIDR>*
RoutingRule::_internal_mutable_source_cidr() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.source_cidr_;
}

// repeated .xray.app.router.GeoIP source_geoip = 11;
inline int RoutingRule::_internal_source_geoip_size() const {
  return _internal_source_geoip().size();
}
inline int RoutingRule::source_geoip_size() const {
  return _internal_source_geoip_size();
}
inline void RoutingRule::clear_source_geoip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_geoip_.Clear();
}
inline ::xray::app::router::GeoIP* RoutingRule::mutable_source_geoip(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.source_geoip)
  return _internal_mutable_source_geoip()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>* RoutingRule::mutable_source_geoip()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.source_geoip)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_source_geoip();
}
inline const ::xray::app::router::GeoIP& RoutingRule::source_geoip(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.source_geoip)
  return _internal_source_geoip().Get(index);
}
inline ::xray::app::router::GeoIP* RoutingRule::add_source_geoip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::GeoIP* _add = _internal_mutable_source_geoip()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.source_geoip)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>& RoutingRule::source_geoip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.source_geoip)
  return _internal_source_geoip();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>&
RoutingRule::_internal_source_geoip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_geoip_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::GeoIP>*
RoutingRule::_internal_mutable_source_geoip() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.source_geoip_;
}

// .xray.common.net.PortList source_port_list = 16;
inline bool RoutingRule::has_source_port_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_port_list_ != nullptr);
  return value;
}
inline const ::xray::common::net::PortList& RoutingRule::_internal_source_port_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::xray::common::net::PortList* p = _impl_.source_port_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::xray::common::net::PortList&>(::xray::common::net::_PortList_default_instance_);
}
inline const ::xray::common::net::PortList& RoutingRule::source_port_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.source_port_list)
  return _internal_source_port_list();
}
inline void RoutingRule::unsafe_arena_set_allocated_source_port_list(::xray::common::net::PortList* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_port_list_);
  }
  _impl_.source_port_list_ = reinterpret_cast<::xray::common::net::PortList*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xray.app.router.RoutingRule.source_port_list)
}
inline ::xray::common::net::PortList* RoutingRule::release_source_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::common::net::PortList* released = _impl_.source_port_list_;
  _impl_.source_port_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::xray::common::net::PortList* RoutingRule::unsafe_arena_release_source_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.RoutingRule.source_port_list)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::xray::common::net::PortList* temp = _impl_.source_port_list_;
  _impl_.source_port_list_ = nullptr;
  return temp;
}
inline ::xray::common::net::PortList* RoutingRule::_internal_mutable_source_port_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.source_port_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::xray::common::net::PortList>(GetArena());
    _impl_.source_port_list_ = reinterpret_cast<::xray::common::net::PortList*>(p);
  }
  return _impl_.source_port_list_;
}
inline ::xray::common::net::PortList* RoutingRule::mutable_source_port_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xray::common::net::PortList* _msg = _internal_mutable_source_port_list();
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.source_port_list)
  return _msg;
}
inline void RoutingRule::set_allocated_source_port_list(::xray::common::net::PortList* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_port_list_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.source_port_list_ = reinterpret_cast<::xray::common::net::PortList*>(value);
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.RoutingRule.source_port_list)
}

// repeated string user_email = 7;
inline int RoutingRule::_internal_user_email_size() const {
  return _internal_user_email().size();
}
inline int RoutingRule::user_email_size() const {
  return _internal_user_email_size();
}
inline void RoutingRule::clear_user_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_email_.Clear();
}
inline std::string* RoutingRule::add_user_email()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_user_email()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.app.router.RoutingRule.user_email)
  return _s;
}
inline const std::string& RoutingRule::user_email(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.user_email)
  return _internal_user_email().Get(index);
}
inline std::string* RoutingRule::mutable_user_email(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.user_email)
  return _internal_mutable_user_email()->Mutable(index);
}
inline void RoutingRule::set_user_email(int index, const std::string& value) {
  _internal_mutable_user_email()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::set_user_email(int index, std::string&& value) {
  _internal_mutable_user_email()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::set_user_email(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_user_email()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::set_user_email(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_user_email()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::set_user_email(int index, absl::string_view value) {
  _internal_mutable_user_email()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::add_user_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_email()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::add_user_email(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_email()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::add_user_email(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_email()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::add_user_email(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_email()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.app.router.RoutingRule.user_email)
}
inline void RoutingRule::add_user_email(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_email()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.app.router.RoutingRule.user_email)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RoutingRule::user_email() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.user_email)
  return _internal_user_email();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RoutingRule::mutable_user_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.user_email)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_user_email();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RoutingRule::_internal_user_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_email_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RoutingRule::_internal_mutable_user_email() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.user_email_;
}

// repeated string inbound_tag = 8;
inline int RoutingRule::_internal_inbound_tag_size() const {
  return _internal_inbound_tag().size();
}
inline int RoutingRule::inbound_tag_size() const {
  return _internal_inbound_tag_size();
}
inline void RoutingRule::clear_inbound_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inbound_tag_.Clear();
}
inline std::string* RoutingRule::add_inbound_tag()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_inbound_tag()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.app.router.RoutingRule.inbound_tag)
  return _s;
}
inline const std::string& RoutingRule::inbound_tag(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.inbound_tag)
  return _internal_inbound_tag().Get(index);
}
inline std::string* RoutingRule::mutable_inbound_tag(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.inbound_tag)
  return _internal_mutable_inbound_tag()->Mutable(index);
}
inline void RoutingRule::set_inbound_tag(int index, const std::string& value) {
  _internal_mutable_inbound_tag()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::set_inbound_tag(int index, std::string&& value) {
  _internal_mutable_inbound_tag()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::set_inbound_tag(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_inbound_tag()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::set_inbound_tag(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_inbound_tag()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::set_inbound_tag(int index, absl::string_view value) {
  _internal_mutable_inbound_tag()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::add_inbound_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_inbound_tag()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::add_inbound_tag(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_inbound_tag()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::add_inbound_tag(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_inbound_tag()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::add_inbound_tag(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_inbound_tag()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.app.router.RoutingRule.inbound_tag)
}
inline void RoutingRule::add_inbound_tag(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_inbound_tag()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.app.router.RoutingRule.inbound_tag)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RoutingRule::inbound_tag() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.inbound_tag)
  return _internal_inbound_tag();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RoutingRule::mutable_inbound_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.inbound_tag)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_inbound_tag();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RoutingRule::_internal_inbound_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inbound_tag_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RoutingRule::_internal_mutable_inbound_tag() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.inbound_tag_;
}

// repeated string protocol = 9;
inline int RoutingRule::_internal_protocol_size() const {
  return _internal_protocol().size();
}
inline int RoutingRule::protocol_size() const {
  return _internal_protocol_size();
}
inline void RoutingRule::clear_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_.Clear();
}
inline std::string* RoutingRule::add_protocol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_protocol()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.app.router.RoutingRule.protocol)
  return _s;
}
inline const std::string& RoutingRule::protocol(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.protocol)
  return _internal_protocol().Get(index);
}
inline std::string* RoutingRule::mutable_protocol(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.protocol)
  return _internal_mutable_protocol()->Mutable(index);
}
inline void RoutingRule::set_protocol(int index, const std::string& value) {
  _internal_mutable_protocol()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::set_protocol(int index, std::string&& value) {
  _internal_mutable_protocol()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::set_protocol(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_protocol()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::set_protocol(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_protocol()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::set_protocol(int index, absl::string_view value) {
  _internal_mutable_protocol()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::add_protocol(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_protocol()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::add_protocol(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_protocol()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::add_protocol(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_protocol()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::add_protocol(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_protocol()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.app.router.RoutingRule.protocol)
}
inline void RoutingRule::add_protocol(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_protocol()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.app.router.RoutingRule.protocol)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RoutingRule::protocol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.RoutingRule.protocol)
  return _internal_protocol();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RoutingRule::mutable_protocol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.RoutingRule.protocol)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_protocol();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RoutingRule::_internal_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RoutingRule::_internal_mutable_protocol() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.protocol_;
}

// map<string, string> attributes = 15;
inline int RoutingRule::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int RoutingRule::attributes_size() const {
  return _internal_attributes_size();
}
inline void RoutingRule::clear_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attributes_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RoutingRule::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RoutingRule::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:xray.app.router.RoutingRule.attributes)
  return _internal_attributes();
}
inline ::google::protobuf::Map<std::string, std::string>* RoutingRule::_internal_mutable_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.attributes_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RoutingRule::mutable_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:xray.app.router.RoutingRule.attributes)
  return _internal_mutable_attributes();
}

// string domain_matcher = 17;
inline void RoutingRule::clear_domain_matcher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_matcher_.ClearToEmpty();
}
inline const std::string& RoutingRule::domain_matcher() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.RoutingRule.domain_matcher)
  return _internal_domain_matcher();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoutingRule::set_domain_matcher(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_matcher_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.RoutingRule.domain_matcher)
}
inline std::string* RoutingRule::mutable_domain_matcher() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain_matcher();
  // @@protoc_insertion_point(field_mutable:xray.app.router.RoutingRule.domain_matcher)
  return _s;
}
inline const std::string& RoutingRule::_internal_domain_matcher() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_matcher_.Get();
}
inline void RoutingRule::_internal_set_domain_matcher(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_matcher_.Set(value, GetArena());
}
inline std::string* RoutingRule::_internal_mutable_domain_matcher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.domain_matcher_.Mutable( GetArena());
}
inline std::string* RoutingRule::release_domain_matcher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.RoutingRule.domain_matcher)
  return _impl_.domain_matcher_.Release();
}
inline void RoutingRule::set_allocated_domain_matcher(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_matcher_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_matcher_.IsDefault()) {
          _impl_.domain_matcher_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.RoutingRule.domain_matcher)
}

inline bool RoutingRule::has_target_tag() const {
  return target_tag_case() != TARGET_TAG_NOT_SET;
}
inline void RoutingRule::clear_has_target_tag() {
  _impl_._oneof_case_[0] = TARGET_TAG_NOT_SET;
}
inline RoutingRule::TargetTagCase RoutingRule::target_tag_case() const {
  return RoutingRule::TargetTagCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BalancingRule

// string tag = 1;
inline void BalancingRule::clear_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& BalancingRule::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.BalancingRule.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalancingRule::set_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.BalancingRule.tag)
}
inline std::string* BalancingRule::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:xray.app.router.BalancingRule.tag)
  return _s;
}
inline const std::string& BalancingRule::_internal_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tag_.Get();
}
inline void BalancingRule::_internal_set_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tag_.Set(value, GetArena());
}
inline std::string* BalancingRule::_internal_mutable_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tag_.Mutable( GetArena());
}
inline std::string* BalancingRule::release_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.BalancingRule.tag)
  return _impl_.tag_.Release();
}
inline void BalancingRule::set_allocated_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tag_.IsDefault()) {
          _impl_.tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.BalancingRule.tag)
}

// repeated string outbound_selector = 2;
inline int BalancingRule::_internal_outbound_selector_size() const {
  return _internal_outbound_selector().size();
}
inline int BalancingRule::outbound_selector_size() const {
  return _internal_outbound_selector_size();
}
inline void BalancingRule::clear_outbound_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.outbound_selector_.Clear();
}
inline std::string* BalancingRule::add_outbound_selector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_outbound_selector()->Add();
  // @@protoc_insertion_point(field_add_mutable:xray.app.router.BalancingRule.outbound_selector)
  return _s;
}
inline const std::string& BalancingRule::outbound_selector(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.BalancingRule.outbound_selector)
  return _internal_outbound_selector().Get(index);
}
inline std::string* BalancingRule::mutable_outbound_selector(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.BalancingRule.outbound_selector)
  return _internal_mutable_outbound_selector()->Mutable(index);
}
inline void BalancingRule::set_outbound_selector(int index, const std::string& value) {
  _internal_mutable_outbound_selector()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::set_outbound_selector(int index, std::string&& value) {
  _internal_mutable_outbound_selector()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::set_outbound_selector(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_outbound_selector()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::set_outbound_selector(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_outbound_selector()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::set_outbound_selector(int index, absl::string_view value) {
  _internal_mutable_outbound_selector()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::add_outbound_selector(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_outbound_selector()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::add_outbound_selector(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_outbound_selector()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::add_outbound_selector(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_outbound_selector()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::add_outbound_selector(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_outbound_selector()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xray.app.router.BalancingRule.outbound_selector)
}
inline void BalancingRule::add_outbound_selector(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_outbound_selector()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:xray.app.router.BalancingRule.outbound_selector)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BalancingRule::outbound_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.BalancingRule.outbound_selector)
  return _internal_outbound_selector();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BalancingRule::mutable_outbound_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.BalancingRule.outbound_selector)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_outbound_selector();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BalancingRule::_internal_outbound_selector() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outbound_selector_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BalancingRule::_internal_mutable_outbound_selector() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.outbound_selector_;
}

// string strategy = 3;
inline void BalancingRule::clear_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strategy_.ClearToEmpty();
}
inline const std::string& BalancingRule::strategy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.BalancingRule.strategy)
  return _internal_strategy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalancingRule::set_strategy(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.strategy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xray.app.router.BalancingRule.strategy)
}
inline std::string* BalancingRule::mutable_strategy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_strategy();
  // @@protoc_insertion_point(field_mutable:xray.app.router.BalancingRule.strategy)
  return _s;
}
inline const std::string& BalancingRule::_internal_strategy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.strategy_.Get();
}
inline void BalancingRule::_internal_set_strategy(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.strategy_.Set(value, GetArena());
}
inline std::string* BalancingRule::_internal_mutable_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.strategy_.Mutable( GetArena());
}
inline std::string* BalancingRule::release_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:xray.app.router.BalancingRule.strategy)
  return _impl_.strategy_.Release();
}
inline void BalancingRule::set_allocated_strategy(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strategy_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.strategy_.IsDefault()) {
          _impl_.strategy_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:xray.app.router.BalancingRule.strategy)
}

// -------------------------------------------------------------------

// Config

// .xray.app.router.Config.DomainStrategy domain_strategy = 1;
inline void Config::clear_domain_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_strategy_ = 0;
}
inline ::xray::app::router::Config_DomainStrategy Config::domain_strategy() const {
  // @@protoc_insertion_point(field_get:xray.app.router.Config.domain_strategy)
  return _internal_domain_strategy();
}
inline void Config::set_domain_strategy(::xray::app::router::Config_DomainStrategy value) {
  _internal_set_domain_strategy(value);
  // @@protoc_insertion_point(field_set:xray.app.router.Config.domain_strategy)
}
inline ::xray::app::router::Config_DomainStrategy Config::_internal_domain_strategy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::xray::app::router::Config_DomainStrategy>(_impl_.domain_strategy_);
}
inline void Config::_internal_set_domain_strategy(::xray::app::router::Config_DomainStrategy value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.domain_strategy_ = value;
}

// repeated .xray.app.router.RoutingRule rule = 2;
inline int Config::_internal_rule_size() const {
  return _internal_rule().size();
}
inline int Config::rule_size() const {
  return _internal_rule_size();
}
inline void Config::clear_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_.Clear();
}
inline ::xray::app::router::RoutingRule* Config::mutable_rule(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.Config.rule)
  return _internal_mutable_rule()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::RoutingRule>* Config::mutable_rule()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.Config.rule)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rule();
}
inline const ::xray::app::router::RoutingRule& Config::rule(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.Config.rule)
  return _internal_rule().Get(index);
}
inline ::xray::app::router::RoutingRule* Config::add_rule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::RoutingRule* _add = _internal_mutable_rule()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.Config.rule)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::RoutingRule>& Config::rule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.Config.rule)
  return _internal_rule();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::RoutingRule>&
Config::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::RoutingRule>*
Config::_internal_mutable_rule() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rule_;
}

// repeated .xray.app.router.BalancingRule balancing_rule = 3;
inline int Config::_internal_balancing_rule_size() const {
  return _internal_balancing_rule().size();
}
inline int Config::balancing_rule_size() const {
  return _internal_balancing_rule_size();
}
inline void Config::clear_balancing_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.balancing_rule_.Clear();
}
inline ::xray::app::router::BalancingRule* Config::mutable_balancing_rule(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xray.app.router.Config.balancing_rule)
  return _internal_mutable_balancing_rule()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::BalancingRule>* Config::mutable_balancing_rule()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xray.app.router.Config.balancing_rule)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_balancing_rule();
}
inline const ::xray::app::router::BalancingRule& Config::balancing_rule(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xray.app.router.Config.balancing_rule)
  return _internal_balancing_rule().Get(index);
}
inline ::xray::app::router::BalancingRule* Config::add_balancing_rule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::xray::app::router::BalancingRule* _add = _internal_mutable_balancing_rule()->Add();
  // @@protoc_insertion_point(field_add:xray.app.router.Config.balancing_rule)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::BalancingRule>& Config::balancing_rule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xray.app.router.Config.balancing_rule)
  return _internal_balancing_rule();
}
inline const ::google::protobuf::RepeatedPtrField<::xray::app::router::BalancingRule>&
Config::_internal_balancing_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.balancing_rule_;
}
inline ::google::protobuf::RepeatedPtrField<::xray::app::router::BalancingRule>*
Config::_internal_mutable_balancing_rule() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.balancing_rule_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace router
}  // namespace app
}  // namespace xray


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::xray::app::router::Domain_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::app::router::Domain_Type>() {
  return ::xray::app::router::Domain_Type_descriptor();
}
template <>
struct is_proto_enum<::xray::app::router::Config_DomainStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::xray::app::router::Config_DomainStrategy>() {
  return ::xray::app::router::Config_DomainStrategy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_app_2frouter_2fconfig_2eproto_2epb_2eh
